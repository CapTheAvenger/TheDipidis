#!/usr/bin/env python3
"""
Card Scraper Shared Module
===========================
Shared utilities and helper functions extracted from unified_card_scraper.py

NOW USING: CardDataManager (unified English + Japanese databases)
Previously used CardDatabaseLookup which loaded individual CSVs.

Provides:
  - CardDatabaseLookup: Wrapper around CardDataManager for backward compatibility
  - Card aggregation and analysis functions
  - CSV output formatting and saving
  - Helper functions for both single-source and unified scrapers

This module allows current_meta_analysis_scraper.py and other analysis tools
to share the same card extraction and aggregation logic.

Usage:
  from card_scraper_shared import CardDatabaseLookup, aggregate_card_data, save_to_csv
  
  card_db = CardDatabaseLookup()  # Now auto-loads from CardDataManager
  all_decks = scrape_limited_online(settings, card_db)
  aggregated = aggregate_card_data(all_decks, card_db)
  save_to_csv(aggregated, 'output.csv')
"""

import urllib.request
import urllib.parse
import csv
import re
import time
import json
import os
import sys
from datetime import datetime, timedelta
from html.parser import HTMLParser
from typing import List, Dict, Optional, Tuple, Any
from collections import defaultdict

# Import the new unified card data manager
try:
    from card_data_manager import CardDataManager
    _CARD_DATA_MANAGER_AVAILABLE = True
except ImportError:
    _CARD_DATA_MANAGER_AVAILABLE = False
    print("[WARNING] CardDataManager not available, falling back to CSV loading")

# ============================================================================
# ACE SPEC KNOWN CARDS DATABASE
# ============================================================================
# Ace Specs are automatically fetched from Limitless TCG by ace_spec_scraper.py
# Fallback list is used if the automated scraper hasn't run yet.
# Source: https://limitlesstcg.com/cards?q=is%3Aace

def load_ace_specs_from_json() -> set:
    """
    Load Ace Specs from data/ace_specs.json (generated by ace_spec_scraper.py).
    Falls back to hardcoded list if file doesn't exist.
    """
    import json
    
    json_file = os.path.join('data', 'ace_specs.json')
    
    # Try to load from JSON
    if os.path.exists(json_file):
        try:
            with open(json_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
                ace_specs = set(data.get('ace_specs', []))
                if ace_specs:
                    return ace_specs
        except Exception as e:
            print(f"[Warning] Could not load ace_specs.json: {e}, using fallback list")
    
    # Fallback: Hardcoded list
    return FALLBACK_ACE_SPECS

# Fallback hardcoded Ace Specs (for when ace_spec_scraper hasn't run yet)
FALLBACK_ACE_SPECS = {
    # Format: "card_name" (normalized lowercase)
    
    # Sword & Shield Era
    "max rod",
    "maximum belt",
    "prime catcher",
    "scoop up cyclone",
    "sparkling crystal",
    "treasure tracker",
    "amulet of hope",
    "brilliant blender",
    "energy search pro",
    "megaton blower",
    "miracle headset",
    "precious trolley",
    "scramble switch",
    "enriching energy",
    "deluxe bomb",
    "grand tree",
    "dangerous laser",
    "neutralization zone",
    "pokÃ© vital a",
    "hyper aroma",
    "secret box",
    "survival brace",
    "unfair stamp",
    "legacy energy",
    "awakening drum",
    "hero's cape",
    "master ball",
    "reboot pod",
    "neo upper energy",
    
    # Additional known Ace Specs from earlier formats
    "boss's orders",
    "lillie's determination",
    "judge",
    "carmine",
    "hilda",
    "kieran",
    "ciphermaniac's codebreaking",
    "colress's tenacity",
    "morty's conviction",
    "xerosic's machinations",
    "black belt's training",
    "tarragon",
    "explorer's guidance",
    "salvatore",
    "team rocket's petrel",
    "night stretcher",
    "fighting gong",
    "pokÃ© pad",
    "premium power pro",
    "ultra ball",
    "switch",
    "tool scrapper",
    "pokÃ©gear 3.0",
    "air balloon",
    "gravity mountain",
    "battle cage",
    "team rocket's watchtower",
    "jamming tower",
}

# Load Ace Specs (from JSON or fallback)
KNOWN_ACE_SPECS = load_ace_specs_from_json()

def normalize_card_name_for_ace_check(name: str) -> str:
    """Normalize card name for Ace Spec checking (lowercase, strip whitespace)"""
    return name.lower().strip()

# ============================================================================
# UTILITIES
# ============================================================================

def get_app_path() -> str:
    """Get the directory where the executable/script is located."""
    if getattr(sys, 'frozen', False):
        return os.path.dirname(sys.executable)
    else:
        return os.path.dirname(os.path.abspath(__file__))

def get_data_dir() -> str:
    """Get the shared data directory for CSV outputs."""
    app_path = get_app_path()
    
    # Always use workspace root/data directory
    parts = app_path.replace('\\', '/').split('/')
    
    # Find workspace root (before 'dist' or use current if not in dist)
    if 'dist' in parts:
        dist_index = parts.index('dist')
        workspace_root = '/'.join(parts[:dist_index])  # Everything before 'dist'
    else:
        # Running from workspace root or as script
        workspace_root = app_path
    
    # Ensure data directory exists
    data_dir = os.path.join(workspace_root, 'data')
    os.makedirs(data_dir, exist_ok=True)
    
    return data_dir

def fetch_page(url: str, timeout: int = 30) -> str:
    """Fetch a webpage and return its HTML content."""
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        req = urllib.request.Request(url, headers=headers)
        with urllib.request.urlopen(req, timeout=timeout) as response:
            return response.read().decode('utf-8', errors='ignore')
    except Exception as e:
        print(f"  Error fetching {url}: {e}")
        return ""

def normalize_archetype_name(archetype: str) -> str:
    """Normalize archetype names to consistent Title Case format.
    
    This ensures "alakazam dragapult", "Alakazam Dragapult", and "ALAKAZAM DRAGAPULT" 
    all become "Alakazam Dragapult" for consistency.
    """
    name = archetype.strip()
    
    # Convert to Title Case (first letter of each word capitalized)
    name = name.title()
    
    # ONLY remove single-letter prefixes that are trainer names (N's Zoroark)
    name = re.sub(r'^N\s+', '', name, flags=re.IGNORECASE)   # "N Zoroark" -> "Zoroark"
    name = re.sub(r'^Ns\s+', '', name, flags=re.IGNORECASE)  # "Ns Zoroark" -> "Zoroark"
    
    # Move "-Mega" suffix to "Mega " prefix for each Pokemon
    # "Abomasnow-Mega" â†’ "Mega Abomasnow"
    # "Absol-Mega Kangaskhan-Mega" â†’ "Mega Absol Mega Kangaskhan"
    name = re.sub(r'(\w+)-Mega\b', r'Mega \1', name, flags=re.IGNORECASE)
    
    # DO NOT remove Ex/V/Vstar/Vmax - these are important variant markers
    # DO NOT remove 3-letter words - could be partner Pokemon names (Meg = Mega Diance)
    
    return name.strip()

# ============================================================================
# CARD DATABASE LOOKUP - Now a Wrapper around CardDataManager
# ============================================================================

class CardDatabaseLookup:
    """
    Wrapper around CardDataManager for backward compatibility.
    Provides same API as the old CardDatabaseLookup which loaded from CSV.
    
    NOW: Automatically loads merged English + Japanese databases.
    
    Usage:
        card_db = CardDatabaseLookup()  # No path needed - auto-loads
        card_info = card_db.lookup_card('Boss\'s Orders')
    """
    
    # Rarity priority (lower = better) - LOW RARITY preferred!
    RARITY_PRIORITY = {
        'Common': 1,
        'Uncommon': 2,
        'Double Rare': 3,
        'Rare': 4,
        'Art Rare': 20,
        'Ultra Rare': 21,
        'Secret Rare': 30,
        'Special Illustration Rare': 31,
        'Hyper Rare': 32,
        'Illustration Rare': 33,
        'Promo': 5
    }
    
    # Set order priority (higher = newer/better)
    SET_ORDER = {
    # Mega (2025-2026)
    'ASC': 130, 'PFL': 129, 'MEG': 128, 'MEE': 128, 'MEP': 128,
    # Scarlet & Violet (2023-2025)
    'BLK': 127, 'WHT': 126, 'DRI': 125, 'JTG': 124, 'PRE': 123,
    'SSP': 122, 'SCR': 121, 'SFA': 120, 'TWM': 119, 'TEF': 118,
    'PAF': 117, 'PAR': 116, 'MEW': 115, 'OBF': 114, 'PAL': 113,
    'SVI': 112, 'SVE': 112, 'SVP': 112,
    # Sword & Shield (2020-2023)
    'CRZ': 111, 'SIT': 110, 'LOR': 109, 'PGO': 108, 'ASR': 107,
    'BRS': 106, 'FST': 105, 'CEL': 104, 'EVS': 103, 'CRE': 102,
    'BST': 101, 'SHF': 100, 'VIV': 99, 'CPA': 98, 'DAA': 97,
    'RCL': 96, 'SSH': 95, 'SP': 95,
    # Sun & Moon (2017-2019)
    'CEC': 94, 'HIF': 93, 'UNM': 92, 'UNB': 91, 'DET': 90,
    'TEU': 89, 'LOT': 88, 'DRM': 87, 'CES': 86, 'FLI': 85,
    'UPR': 84, 'CIN': 83, 'SLG': 82, 'BUS': 81, 'GRI': 80,
    'SUM': 79, 'SMP': 79,
    # XY (2014-2016)
    'EVO': 78, 'STS': 77, 'FCO': 76, 'GEN': 75, 'BKP': 74,
    'BKT': 73, 'AOR': 72, 'ROS': 71, 'DCR': 70, 'PRC': 69,
    'PHF': 68, 'FFI': 67, 'FLF': 66, 'XY': 65, 'XYP': 65,
    # Black & White (2011-2013)
    'LTR': 64, 'PLB': 63, 'PLF': 62, 'PLS': 61, 'BCR': 60,
    'DRX': 59, 'DEX': 58, 'NXD': 57, 'NVI': 56, 'EPO': 55,
    'BLW': 54, 'BWP': 54,
    # HeartGold & SoulSilver (2010-2011)
    'CL': 53, 'TM': 52, 'UD': 51, 'UL': 50, 'HS': 49,
    # Platinum (2009-2010)
    'AR': 48, 'SV': 47, 'RR': 46, 'PL': 45, 'SF': 44,
    # Diamond & Pearl (2007-2009)
    'LA': 43, 'MD': 42, 'GE': 41, 'SW': 40, 'MT': 39, 'DP': 38,
    # EX (2003-2007)
    'PK': 37, 'DF': 36, 'CG': 35, 'HP': 34, 'LM': 33, 'DS': 32,
    'UF': 31, 'EM': 30, 'DX': 29, 'TRR': 28, 'RG': 27, 'HL': 26,
    'MA': 25, 'DR': 24, 'SS': 23, 'RS': 22,
    # e-Card & Neo (2000-2003)
    'E3': 21, 'E2': 20, 'E1': 19, 'LC': 18, 'N4': 17, 'N3': 16,
    'N2': 15, 'N1': 14,
    # Classic (1999-2000)
    'G2': 13, 'G1': 12, 'TR': 11, 'BS2': 10, 'FO': 9, 'JU': 8, 'BS': 7,
    # Older Special Sets
    'M3': 20, 'MC': 15, 'MP1': 50
    }
    
    def __init__(self, csv_path: str = None):
        """
        Initialize CardDatabaseLookup.
        
        Args:
            csv_path: (deprecated, ignored) For backward compatibility only.
        
        Internally uses CardDataManager to load merged databases.
        """
        if csv_path:
            print(f"[CardDatabaseLookup] Note: csv_path parameter is deprecated")
            print(f"[CardDatabaseLookup] Now using unified CardDataManager instead of {csv_path}")
        
        if not _CARD_DATA_MANAGER_AVAILABLE:
            raise ImportError("CardDataManager not available! Install or ensure card_data_manager.py is in the path")
        
        # Load the unified card database
        print("[CardDatabaseLookup] Loading unified card database (English + Japanese)...")
        self.manager = CardDataManager()
        self.cards = {}  # name -> list of card variants (for compatibility)
        self._build_name_index()
    
    def _build_name_index(self):
        """Build a name-based index for compatibility with old code."""
        print("[CardDatabaseLookup] Building name index...")
        
        for card in self.manager.get_all_cards():
            name = card.get('name', '')
            normalized = self.normalize_name(name)
            
            if normalized not in self.cards:
                self.cards[normalized] = []
            
            self.cards[normalized].append({
                'name': name,
                'set_code': card.get('set', ''),
                'set_number': card.get('number', ''),
                'rarity': card.get('rarity', ''),
                'type': card.get('type', ''),
                'card_type': card.get('type', 'Pokemon'),
                'image_url': card.get('image_url', ''),
                '_source': card.get('_source', 'english')
            })
        
        print(f"[CardDatabaseLookup] âœ“ Indexed {len(self.cards)} unique card names")
        return True
    
    def normalize_name(self, name: str) -> str:
        """Normalize card name for matching."""
        normalized = name.strip().lower()
        normalized = normalized.replace("'", "'").replace("'", "'").replace("`", "'")
        normalized = normalized.replace('-', ' ').replace('.', '')
        normalized = ' '.join(normalized.split())
        return normalized
    
    def is_japanese_set(self, set_code: str) -> bool:
        """Check if set code is Japanese."""
        # Simple heuristic: Japanese sets are typically 1-3 lowercase letters
        # English sets are typically 2-3 uppercase letters
        return not set_code or set_code[0].islower()
    
    def is_card_trainer_or_energy(self, variants: List[Dict[str, str]]) -> bool:
        """Check if this card is a Trainer or Energy card based on type."""
        if not variants:
            return False
        card_type = variants[0].get('card_type', '') or variants[0].get('type', '')
        card_type_lower = card_type.lower()
        return any(t in card_type_lower for t in ['trainer', 'supporter', 'energy', 'stadium', 'tool'])
    
    def is_card_trainer_or_energy_by_name(self, card_name: str) -> bool:
        """Check if a card (by name) is a Trainer or Energy card."""
        normalized = self.normalize_name(card_name)
        if normalized in self.cards:
            return self.is_card_trainer_or_energy(self.cards[normalized])
        return False
    
    def is_ace_spec_by_name(self, card_name: str) -> bool:
        """Check if a card is an Ace Spec."""
        normalized = self.normalize_name(card_name)
        if normalized not in self.cards:
            return False
        
        variants = self.cards[normalized]
        if not variants:
            return False
        
        # Check rarity and type
        first = variants[0]
        rarity = first.get('rarity', '').lower()
        card_type = (first.get('card_type', '') or first.get('type', '')).lower()
        
        return ('ultra rare' in rarity or 'special' in rarity) and any(
            t in card_type for t in ['trainer', 'supporter', 'tool', 'item', 'stadium']
        )
    
    def is_ace_spec(self, variants: List[Dict[str, str]]) -> bool:
        """Check if card variants represent an Ace Spec."""
        if not variants:
            return False
        
        for variant in variants:
            rarity = variant.get('rarity', '').lower()
            card_type = (variant.get('card_type', '') or variant.get('type', '')).lower()
            
            if ('ultra rare' in rarity or 'special' in rarity) and any(
                t in card_type for t in ['trainer', 'supporter', 'tool', 'item', 'stadium']
            ):
                return True
        
        return False
    
    def get_latest_low_rarity_version(self, card_name: str) -> Optional[Any]:
        """Get the latest LOW RARITY version of a Trainer/Energy card."""
        normalized = self.normalize_name(card_name)
        
        # Force SVE for basic energies
        basic_energy_map = {
            'grass energy': ('SVE', '17'),
            'fire energy': ('SVE', '18'),
            'water energy': ('SVE', '19'),
            'lightning energy': ('SVE', '20'),
            'psychic energy': ('SVE', '21'),
            'fighting energy': ('SVE', '22'),
            'darkness energy': ('SVE', '23'),
            'metal energy': ('SVE', '24'),
            'fairy energy': ('SVE', '25')
        }
        
        if normalized in basic_energy_map:
            set_code, set_number = basic_energy_map[normalized]
            class CardInfo:
                def __init__(self):
                    self.name = card_name
                    self.set_code = set_code
                    self.number = set_number
                    self.rarity = 'Basic Energy'
                    self.supertype = 'Energy'
            return CardInfo()
        
        if normalized not in self.cards:
            return None
        
        variants = self.cards[normalized]
        LOW_RARITIES = {'Common', 'Uncommon', 'Promo'}
        
        low_rarity_variants = [v for v in variants if v.get('rarity', '') in LOW_RARITIES]
        if not low_rarity_variants:
            low_rarity_variants = variants
        
        best_card = None
        best_set_order = -1
        
        for variant in low_rarity_variants:
            set_code = variant.get('set_code', '')
            set_order = self.SET_ORDER.get(set_code, 0)
            
            if set_order > best_set_order:
                best_card = variant
                best_set_order = set_order
        
        if not best_card:
            return None
        
        class CardInfo:
            def __init__(self, data):
                self.name = data.get('name', '')
                self.set_code = data.get('set_code', '')
                self.number = data.get('set_number', '')
                self.rarity = data.get('rarity', '')
                self.supertype = data.get('card_type', '') or data.get('type', '')
        
        return CardInfo(best_card)
    
    def lookup_card(self, card_name: str) -> Optional[Any]:
        """Lookup card in database and return CardInfo object."""
        normalized = self.normalize_name(card_name)
        
        if normalized not in self.cards:
            return None
        
        variants = self.cards[normalized]
        if not variants:
            return None
        
        best_card = variants[0]
        
        class CardInfo:
            def __init__(self, data):
                self.name = data.get('name', '')
                self.set_code = data.get('set_code', '')
                self.number = data.get('set_number', '')
                self.rarity = data.get('rarity', '')
                self.supertype = data.get('card_type', '') or data.get('type', '')
        
        return CardInfo(best_card)
    
    def is_ace_spec_by_name(self, card_name: str) -> bool:
        """
        Check if a card (by name) is an Ace Spec card.
        Uses multiple detection methods:
        1. Check known Ace Specs list (most reliable)
        2. Fallback: Check 'Ultra Rare' rarity with Trainer/Stadium/Tool/Item type
        3. Fallback: Check for 'ace spec' in card type text
        """
        normalized = normalize_card_name_for_ace_check(card_name)
        
        # Method 1: Check known Ace Specs list (most reliable)
        if normalized in KNOWN_ACE_SPECS:
            return True
        
        # Method 2: Not in known list - check database with fallback logic
        normalized_db = self.normalize_name(card_name)
        if normalized_db in self.cards:
            variants = self.cards[normalized_db]
            return self.is_ace_spec_from_variants(variants)
        
        return False
    
    def is_ace_spec(self, variants: List[Dict[str, str]]) -> bool:
        """
        Check if this card is an Ace Spec based on variants from database.
        Uses multiple detection methods as fallback.
        """
        if not variants:
            return False
        return self.is_ace_spec_from_variants(variants)
    
    def is_ace_spec_from_variants(self, variants: List[Dict[str, str]]) -> bool:
        """
        Core Ace Spec detection logic using multiple fallback methods:
        1. Check for 'ace spec' in card type (direct indication)
        2. Check if Ultra Rare + Trainer/Stadium/Tool/Item type (probabilistic)
        3. Return False if neither match
        """
        if not variants:
            return False
        
        first_variant = variants[0]
        card_type = first_variant.get('card_type', '') or first_variant.get('type', '')
        rarity = first_variant.get('rarity', '')
        
        card_type_lower = card_type.lower()
        rarity_lower = rarity.lower()
        
        # Method 1: Direct check - if card type contains 'ace spec', it definitely is one
        if 'ace spec' in card_type_lower:
            return True
        
        # Method 2: Heuristic check - Ultra Rare + Trainer-like card
        # Ace Specs are typically "Ultra Rare" rarity with specific types
        is_ultra_rare = 'ultra rare' in rarity_lower or 'ur' in rarity_lower
        is_trainer_type = any(t in card_type_lower for t in ['trainer', 'supporter', 'tool', 'item', 'stadium', 'special energy'])
        
        if is_ultra_rare and is_trainer_type:
            # This is likely an Ace Spec (but not 100% certain without known list)
            return True
        
        return False
    
    def get_latest_low_rarity_version(self, card_name: str) -> Optional[Any]:
        """
        Get the latest LOW RARITY version of a Trainer/Energy card.
        Returns a CardInfo object with set_code, number, rarity, etc.
        
        For Basic Energy: Force SVE set (17-25)
        For Trainer/Energy cards: Filter to LOW RARITY only (Common, Uncommon, Promo),
        then select NEWEST set from those low-rarity versions.
        """
        normalized = self.normalize_name(card_name)
        
        # Force SVE for basic energies
        basic_energy_map = {
            'grass energy': ('SVE', '17'),
            'fire energy': ('SVE', '18'),
            'water energy': ('SVE', '19'),
            'lightning energy': ('SVE', '20'),
            'psychic energy': ('SVE', '21'),
            'fighting energy': ('SVE', '22'),
            'darkness energy': ('SVE', '23'),
            'metal energy': ('SVE', '24'),
            'fairy energy': ('SVE', '25')
        }
        
        if normalized in basic_energy_map:
            set_code, set_number = basic_energy_map[normalized]
            class CardInfo:
                def __init__(self):
                    self.name = card_name
                    self.set_code = set_code
                    self.number = set_number
                    self.rarity = 'Basic Energy'
                    self.supertype = 'Energy'
            return CardInfo()
        
        if normalized not in self.cards:
            return None
        
        variants = self.cards[normalized]
        
        # Define LOW RARITY values
        LOW_RARITIES = {'Common', 'Uncommon', 'Promo'}
        
        # Filter to only LOW RARITY variants
        low_rarity_variants = [v for v in variants if v.get('rarity', '') in LOW_RARITIES]
        
        # If no low rarity version exists, fallback to ANY rarity (prefer newest set)
        if not low_rarity_variants:
            low_rarity_variants = variants  # Use all variants as fallback
        
        # Find the NEWEST set among available variants
        best_card = None
        best_set_order = -1
        
        for variant in low_rarity_variants:
            set_code = variant.get('set_code', '')
            set_order = self.SET_ORDER.get(set_code, 0)
            
            if set_order > best_set_order:
                best_card = variant
                best_set_order = set_order
        
        if not best_card:
            return None
        
        # Return a CardInfo-like object
        class CardInfo:
            def __init__(self, data):
                self.name = data.get('name', '')
                self.set_code = data.get('set_code', '')
                self.number = data.get('set_number', '')
                self.rarity = data.get('rarity', '')
                self.supertype = data.get('card_type', '') or data.get('type', '')
        
        return CardInfo(best_card)
    
    def lookup_card(self, card_name: str) -> Optional[Any]:
        """
        Lookup card in database and return CardInfo object with supertype, set_code, etc.
        Used for determining card type (Pokemon vs Trainer vs Energy).
        """
        normalized = self.normalize_name(card_name)
        
        if normalized not in self.cards:
            return None
        
        variants = self.cards[normalized]
        if not variants:
            return None
        
        # Return first variant as CardInfo object
        class CardInfo:
            def __init__(self, data):
                self.name = data.get('name', '')
                self.set_code = data.get('set_code', '')
                self.number = data.get('set_number', '')
                self.rarity = data.get('rarity', '')
                card_type = data.get('card_type', '') or data.get('type', '')
                # Normalize supertype
                if 'pokemon' in card_type.lower() or card_type == '':
                    self.supertype = 'PokÃ©mon'
                elif 'energy' in card_type.lower():
                    self.supertype = 'Energy'
                elif any(x in card_type.lower() for x in ['trainer', 'supporter', 'item', 'tool', 'stadium']):
                    self.supertype = 'Trainer'
                else:
                    self.supertype = 'PokÃ©mon'  # Default
        
        return CardInfo(variants[0])

    def generate_limitless_image_url(self, set_code: str, card_number: str, rarity: str) -> str:
        """Generate Limitless CDN image URL for EN or JP cards."""
        set_code = set_code.upper()
        card_number_raw = card_number.replace('-', '_')
        card_number_no_pad = card_number_raw.lstrip('0') or '0'
        card_number_padded = card_number_no_pad.zfill(3)
        rarity_short = 'R'
        
        # Check if Japanese set
        is_japanese = self.is_japanese_set(set_code)
        
        if is_japanese:
            # Japanese card: use /tpc/, _JP_, NO padding (41 bleibt 41, nicht 041)
            url = (
                f"https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpc/"
                f"{set_code}/{set_code}_{card_number_no_pad}_{rarity_short}_JP_LG.png"
            )
        else:
            # English card: use /tpci/, _EN_, WITH padding (41 wird 041)
            url = (
                f"https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpci/"
                f"{set_code}/{set_code}_{card_number_padded}_{rarity_short}_EN_LG.png"
            )
        
        return url
    
    def get_card_info(self, card_name: str) -> Optional[Dict[str, str]]:
        """Get card info with proper handling of basic energies and card selection."""
        # Force SVE EN variant for standard basic energies
        basic_energy_map = {
            'grass energy': ('SVE', '17'),
            'fire energy': ('SVE', '18'),
            'water energy': ('SVE', '19'),
            'lightning energy': ('SVE', '20'),
            'psychic energy': ('SVE', '21'),
            'fighting energy': ('SVE', '22'),
            'darkness energy': ('SVE', '23'),
            'metal energy': ('SVE', '24'),
            'fairy energy': ('SVE', '25')
        }
        norm_name = self.normalize_name(card_name)
        if norm_name in basic_energy_map:
            set_code, set_number = basic_energy_map[norm_name]
            rarity = 'Basic Energy'
            image_url = self.generate_limitless_image_url(set_code, set_number, rarity)
            return {
                'set_code': set_code,
                'set_name': 'SVE',
                'number': set_number,
                'rarity': rarity,
                'type': 'Energy',
                'image_url': image_url
            }
        
        """For Trainer/Energy cards: Use NEWEST set (ASC > MEG > BRS...) regardless of rarity
        For Pokemon cards: Use LOWEST rarity (Common > Uncommon) regardless of set
        """
        normalized = self.normalize_name(card_name)
        
        # Try exact match first
        if normalized in self.cards:
            variants = self.cards[normalized]
            # Prefer EN variant if available
            en_variant = None
            jp_variant = None
            for variant in variants:
                set_code = variant.get('set_code', '').upper()
                # EN cards: set_code is not MC, not a pure number, not JP-only
                if set_code and not set_code.startswith('MC') and not set_code.isdigit():
                    en_variant = variant
                    break
                # MC or numeric set_code is JP
                if set_code.startswith('MC') or set_code.isdigit():
                    jp_variant = variant
            best_card = en_variant if en_variant else jp_variant if jp_variant else variants[0]
            image_url = self.generate_limitless_image_url(
                best_card['set_code'],
                best_card['set_number'],
                best_card['rarity']
            )
            return {
                'set_code': best_card['set_code'],
                'set_name': '',  # Not in CSV
                'number': best_card['set_number'],
                'rarity': best_card['rarity'],
                'type': best_card.get('type', ''),
                'image_url': image_url
            }
        
        # Try partial match (for cards with ex/V suffixes or truncated names)
        # First try: cards where input is contained in database name
        for db_name, variants in self.cards.items():
            if normalized in db_name:
                # Determine if this is a Trainer/Energy card
                is_trainer_energy = self.is_card_trainer_or_energy(variants)
                
                best_card = None
                best_priority = 999
                best_set_order = -1
                
                for variant in variants:
                    set_order = self.SET_ORDER.get(variant['set_code'], 0)
                    
                    if is_trainer_energy:
                        # For Trainer/Energy: Prefer NEWEST set only
                        if set_order > best_set_order:
                            best_card = variant
                            best_set_order = set_order
                    else:
                        # For Pokemon: Prefer LOWEST rarity, then NEWEST set
                        rarity = variant['rarity']
                        priority = self.RARITY_PRIORITY.get(rarity, 50)
                        if priority < best_priority or (priority == best_priority and set_order > best_set_order):
                            best_card = variant
                            best_priority = priority
                            best_set_order = set_order
                
                if best_card:
                    image_url = self.generate_limitless_image_url(
                        best_card['set_code'],
                        best_card['set_number'],
                        best_card['rarity']
                    )
                    
                    return {
                        'set_code': best_card['set_code'],
                        'set_name': '',
                        'number': best_card['set_number'],
                        'rarity': best_card['rarity'],
                        'type': best_card.get('type', ''),
                        'image_url': image_url
                    }
        
        # Second try: database name is contained in input (for cases where scraped name is longer)
        for db_name, variants in self.cards.items():
            if db_name in normalized and len(db_name) > 3:  # Only if db_name is meaningful length
                # Determine if this is a Trainer/Energy card
                is_trainer_energy = self.is_card_trainer_or_energy(variants)
                
                best_card = None
                best_priority = 999
                best_set_order = -1
                
                for variant in variants:
                    set_order = self.SET_ORDER.get(variant['set_code'], 0)
                    
                    if is_trainer_energy:
                        # For Trainer/Energy: Prefer NEWEST set only
                        if set_order > best_set_order:
                            best_card = variant
                            best_set_order = set_order
                    else:
                        # For Pokemon: Prefer LOWEST rarity, then NEWEST set
                        rarity = variant['rarity']
                        priority = self.RARITY_PRIORITY.get(rarity, 50)
                        if priority < best_priority or (priority == best_priority and set_order > best_set_order):
                            best_card = variant
                            best_priority = priority
                            best_set_order = set_order
                
                if best_card:
                    image_url = self.generate_limitless_image_url(
                        best_card['set_code'],
                        best_card['set_number'],
                        best_card['rarity']
                    )
                    
                    return {
                        'set_code': best_card['set_code'],
                        'set_name': '',
                        'number': best_card['set_number'],
                        'rarity': best_card['rarity'],
                        'type': best_card.get('type', ''),
                        'image_url': image_url
                    }
        
        return None
    
    def get_card_info_by_set_number(self, card_name: str, set_code: str, card_number: str) -> Optional[Dict[str, str]]:
        """Get card info for a specific set and number.
        
        For Pokemon cards: Return the exact card from the specified set/number
        For Trainer/Energy: Return the exact card from the specified set/number
        
        This preserves the original card selection from the source (Limitless/Tournament)
        without re-selecting based on rarity or set order.
        """
        # Normalize card name for lookup
        normalized = self.normalize_name(card_name)
        
        if normalized not in self.cards:
            return None
        
        variants = self.cards[normalized]
        
        # Find the exact variant matching the set and number
        for variant in variants:
            if variant['set_code'] == set_code and variant['set_number'] == card_number:
                image_url = self.generate_limitless_image_url(set_code, card_number, variant['rarity'])
                return {
                    'set_code': variant['set_code'],
                    'set_name': '',
                    'number': variant['set_number'],
                    'rarity': variant['rarity'],
                    'type': variant.get('type', ''),
                    'image_url': image_url
                }
        
        return None
    
    def get_name_by_set_number(self, set_code: str, card_number: str) -> Optional[str]:
        """Lookup card name by set code and number."""
        if not set_code or not card_number:
            return None

        normalized_set = set_code.strip().upper()
        normalized_number = card_number.strip().lstrip('0') or card_number.strip()
        
        # Search through all cards for matching set+number
        for db_name, variants in self.cards.items():
            for variant in variants:
                variant_set = (variant['set_code'] or '').strip().upper()
                variant_number = (variant['set_number'] or '').strip()
                variant_number_norm = variant_number.lstrip('0') or variant_number

                if variant_set == normalized_set and (
                    variant_number == card_number.strip() or variant_number_norm == normalized_number
                ):
                    return variant['name']
        
        return None

# ============================================================================
# CARD PARSING
# ============================================================================

def parse_copy_button_decklist(copy_text: str, card_db: CardDatabaseLookup) -> List[Dict[str, Any]]:
    """Parse decklist from 'Copy to Clipboard' button format.
    
    Format:
    PokÃ©mon: 21
    4 Dreepy TWM 128
    4 Drakloak TWM 129
    ...
    Trainer: 32
    4 Lillie's Determination MEG 119
    ...
    Energy: 7
    3 Luminous Energy PAL 191
    1 Fire Energy MEE 2
    
    Pokemon: Keep original set+number from copy button
    Trainer/Energy: Database lookup for low-rarity version (Common/Uncommon)
    Basic Energy: Force SVE set
    """
    cards = []
    lines = copy_text.strip().split('\n')
    
    for line in lines:
        line = line.strip()
        if not line or ':' in line and not any(char.isdigit() for char in line.split(':')[0]):
            # Skip section headers like "PokÃ©mon: 21"
            continue
        
        # Parse format: "4 Card Name SET 123"
        match = re.match(r'^(\d+)\s+(.+?)\s+([A-Z0-9]+)\s+(\d+)$', line)
        if match:
            count = int(match.group(1))
            card_name = match.group(2).strip()
            set_code = match.group(3).strip()
            set_number = match.group(4).strip()
            
            # Check if basic energy
            norm_name = card_db.normalize_name(card_name)
            basic_energies = ['grass energy', 'fire energy', 'water energy', 'lightning energy',
                            'psychic energy', 'fighting energy', 'darkness energy', 'metal energy', 'fairy energy']
            
            if norm_name in basic_energies:
                # Force SVE set for basic energies
                basic_energy_map = {
                    'grass energy': '17', 'fire energy': '18', 'water energy': '19',
                    'lightning energy': '20', 'psychic energy': '21', 'fighting energy': '22',
                    'darkness energy': '23', 'metal energy': '24', 'fairy energy': '25'
                }
                cards.append({
                    'name': card_name,
                    'count': count,
                    'set_code': 'SVE',
                    'set_number': basic_energy_map[norm_name]
                })
            else:
                # Check card type
                db_card = card_db.lookup_card(card_name)
                
                if db_card and db_card.supertype == 'PokÃ©mon':
                    # Pokemon: Keep original set+number from copy button
                    cards.append({
                        'name': card_name,
                        'count': count,
                        'set_code': set_code,
                        'set_number': set_number
                    })
                else:
                    # Trainer/Energy: Get low-rarity version from database
                    latest_card = card_db.get_latest_low_rarity_version(card_name)
                    if latest_card:
                        cards.append({
                            'name': card_name,
                            'count': count,
                            'set_code': latest_card.set_code,
                            'set_number': latest_card.number
                        })
                    else:
                        # Fallback: Keep original if no low-rarity found
                        cards.append({
                            'name': card_name,
                            'count': count,
                            'set_code': set_code,
                            'set_number': set_number
                        })
    
    return cards

# ============================================================================
# DATA AGGREGATION
# ============================================================================

def aggregate_card_data(all_decks: List[Dict[str, Any]], card_db: CardDatabaseLookup, meta_source: str = None) -> List[Dict[str, Any]]:
    """Aggregate card data from all sources with archetype percentages.
    
    Args:
        all_decks: List of deck dictionaries
        card_db: Card database lookup
        meta_source: Meta field value (e.g. 'City League', 'Limitless'). If None, extracts from first deck.
    """
    print("\n" + "="*60)
    print("AGGREGATING CARD DATA")
    print("="*60)
    
    # Determine meta source
    if meta_source is None and all_decks:
        meta_source = all_decks[0].get('meta', 'Domestic')
    elif meta_source is None:
        meta_source = 'Domestic'
    
    # Check if we're grouping by tournament_date (if most decks have tournament_date)
    decks_with_date = sum(1 for deck in all_decks if deck.get('tournament_date'))
    group_by_date = decks_with_date > len(all_decks) * 0.5  # If >50% have dates, group by date
    
    if group_by_date:
        print("  â„¹ï¸  Grouping by tournament_date + archetype + card")
        # Structure: {(date, archetype): {card_name: {'total_count': X, ...}}}
        archetype_cards = defaultdict(lambda: defaultdict(lambda: {'total_count': 0, 'deck_count': 0, 'max_count': 0, 'decks': [], 'set_codes': {}}))
        archetype_deck_counts = defaultdict(int)  # Total decks per (date, archetype)
        archetype_total_seen = defaultdict(int)
    else:
        print("  â„¹ï¸  Grouping by archetype + card (no date)")
        # Structure: {archetype: {card_name: {'total_count': X, ...}}}
        archetype_cards = defaultdict(lambda: defaultdict(lambda: {'total_count': 0, 'deck_count': 0, 'max_count': 0, 'decks': [], 'set_codes': {}}))
        archetype_deck_counts = defaultdict(int)  # Total decks per archetype
        archetype_total_seen = defaultdict(int)
    
    # Aggregate data
    decks_with_cards = 0
    decks_without_cards = 0
    
    for i, deck in enumerate(all_decks):
        # NORMALIZE ARCHETYPE NAME to merge variants like "Ceruledge Ex" and "Ceruledge"
        archetype_raw = deck['archetype']
        archetype = normalize_archetype_name(archetype_raw)
        tournament_date = deck.get('tournament_date', '') if group_by_date else ''
        
        # Group key: (date, archetype) if grouping by date, else just archetype
        group_key = (tournament_date, archetype) if group_by_date else archetype
        
        archetype_total_seen[group_key] += 1
        
        # Skip decks without card lists (from City League/Limitless Online)
        if not deck.get('cards'):
            decks_without_cards += 1
            continue
        
        decks_with_cards += 1
        archetype_deck_counts[group_key] += 1
        
        # Track which cards appear in this deck
        cards_in_deck = set()
        
        for card in deck['cards']:
            card_name = card['name']
            count = card['count']
            
            # Prefer set+number lookup to avoid truncated or incorrect names
            set_code = card.get('set_code', '')
            card_number = card.get('set_number', '')
            if set_code and card_number:
                looked_up_name = card_db.get_name_by_set_number(set_code, card_number)
                if looked_up_name:
                    if (not card_name or card_name.strip() == '' or
                        card_db.normalize_name(card_name) != card_db.normalize_name(looked_up_name)):
                        card_name = looked_up_name
                        card['name'] = card_name  # Update the card dict
            
            # If card name is still empty, skip
            if not card_name or card_name.strip() == '':
                continue
            
            archetype_cards[group_key][card_name]['total_count'] += count
            
            # Track max count across all decks
            if count > archetype_cards[group_key][card_name]['max_count']:
                archetype_cards[group_key][card_name]['max_count'] = count
            
            # Track set/number information for Pokemon cards
            if set_code and card_number:
                set_key = f"{set_code}_{card_number}"
                if set_key not in archetype_cards[group_key][card_name]['set_codes']:
                    archetype_cards[group_key][card_name]['set_codes'][set_key] = {'set_code': set_code, 'set_number': card_number, 'count': 0}
                archetype_cards[group_key][card_name]['set_codes'][set_key]['count'] += 1
            
            if card_name not in cards_in_deck:
                archetype_cards[group_key][card_name]['deck_count'] += 1
                cards_in_deck.add(card_name)
    
    print(f"\nðŸ“Š Data Summary:")
    print(f"  â€¢ Total decks collected: {len(all_decks)}")
    print(f"  â€¢ Decks WITH card lists: {decks_with_cards}")
    print(f"  â€¢ Decks WITHOUT card lists: {decks_without_cards}")
    print(f"  â€¢ Unique archetypes: {len(archetype_deck_counts)}")
    
    # Build final output
    result = []
    
    print(f"\nðŸ” Looking up set/number info from card database...")
    card_count = 0
    successful_lookups = 0
    failed_lookups = 0
    
    for group_key, cards in archetype_cards.items():
        # Extract tournament_date and archetype from group_key
        if group_by_date:
            tournament_date, archetype = group_key
        else:
            tournament_date = ''
            archetype = group_key
        
        # Use only decks WITH cards for percentage calculation
        total_decks_with_cards = archetype_deck_counts[group_key]
        
        if total_decks_with_cards == 0:
            continue  # Skip archetypes with no card data
        
        for card_name, data in cards.items():
            # Calculate percentage based on decks that have card lists
            percentage = (data['deck_count'] / total_decks_with_cards * 100) if total_decks_with_cards > 0 else 0
            
            card_count += 1
            if card_count % 50 == 0:
                print(f"  Processed {card_count} unique cards... ({successful_lookups} found, {failed_lookups} not found)")
            
            # Determine which set/number to use
            card_info = None
            final_set_code = ''
            final_card_number = ''
            
            # If we have tracked set/numbers from the source (Pokemon case), use the most common one
            if data['set_codes']:
                # Find the most frequently occurring set/number combination
                most_common = max(data['set_codes'].items(), key=lambda x: x[1]['count'])
                set_code = most_common[1]['set_code']
                card_number = most_common[1]['set_number']
                
                # Check if this is a Trainer/Energy card
                is_trainer_energy = card_db.is_card_trainer_or_energy_by_name(card_name)
                
                # For Pokemon: Use the exact set/number from source
                # For Trainer/Energy: Use latest LOW RARITY version (Common/Uncommon)
                if not is_trainer_energy:
                    # Pokemon card - keep the EXACT set/number from source
                    card_info = card_db.get_card_info_by_set_number(card_name, set_code, card_number)
                    if card_info:
                        final_set_code = card_info['set_code']
                        final_card_number = card_info['number']
                    else:
                        # Fallback for Pokemon if exact lookup fails
                        card_info = card_db.get_card_info(card_name)
                        if card_info:
                            final_set_code = card_info['set_code']
                            final_card_number = card_info['number']
                        else:
                            # Use source data as last resort
                            final_set_code = set_code
                            final_card_number = card_number
                else:
                    # Trainer/Energy - use latest LOW RARITY version (ignore source set/number)
                    latest_card = card_db.get_latest_low_rarity_version(card_name)
                    if latest_card:
                        # Convert to dict format
                        image_url = card_db.generate_limitless_image_url(latest_card.set_code, latest_card.number, latest_card.rarity)
                        card_info = {
                            'set_code': latest_card.set_code,
                            'set_name': '',
                            'number': latest_card.number,
                            'rarity': latest_card.rarity,
                            'type': latest_card.supertype,
                            'image_url': image_url
                        }
                        final_set_code = latest_card.set_code
                        final_card_number = latest_card.number
                    else:
                        # Fallback: Try any version from database
                        card_info = card_db.get_card_info(card_name)
                        if card_info:
                            final_set_code = card_info['set_code']
                            final_card_number = card_info['number']
                        elif set_code and card_number:
                            # Last resort: Use source set/number
                            image_url = card_db.generate_limitless_image_url(set_code, card_number, 'Common')
                            # Try to get type from database
                            fallback_info = card_db.get_card_info(card_name)
                            card_type = fallback_info.get('type', 'Trainer') if fallback_info else 'Trainer'
                            card_info = {
                                'set_code': set_code,
                                'set_name': '',
                                'number': card_number,
                                'rarity': 'Unknown',
                                'type': card_type,
                                'image_url': image_url
                            }
                            final_set_code = set_code
                            final_card_number = card_number
            else:
                # No set_codes tracked (Limitless online archetype-only data)
                card_info = card_db.get_card_info(card_name)
                if card_info:
                    final_set_code = card_info['set_code']
                    final_card_number = card_info['number']
            
            # Track if lookup was successful
            if card_info:
                successful_lookups += 1
            else:
                failed_lookups += 1
            
            result.append({
                'meta': meta_source,
                'tournament_date': tournament_date,
                'archetype': archetype,
                'card_name': card_name,
                'card_identifier': f"{final_set_code} {final_card_number}".strip(),
                'total_count': data['total_count'],
                'max_count': data['max_count'],
                'deck_count': data['deck_count'],
                'total_decks_in_archetype': total_decks_with_cards,
                'percentage_in_archetype': round(percentage, 2),
                'set_code': card_info['set_code'] if card_info else '',
                'set_name': card_info['set_name'] if card_info else '',
                'set_number': card_info['number'] if card_info else '',
                'rarity': card_info['rarity'] if card_info else '',
                'type': card_info['type'] if card_info else '',
                'image_url': card_info['image_url'] if card_info else '',
                'is_ace_spec': 'Yes' if card_db.is_ace_spec_by_name(card_name) else 'No'
            })
    
    # Sort by tournament_date (if present), then archetype, then type, then percentage descending
    def sort_key(card):
        tournament_date = card.get('tournament_date', '')
        archetype = card['archetype']
        card_type = card['type']
        percentage = card['percentage_in_archetype']
        card_name = card['card_name']
        
        # Type sorting order: G,R,W,L,P,F,D,M,N,C (element) then Basic,Stage1,Stage2 (evolution)
        # Trainer/Energy cards sort after Pokemon (Z prefix)
        element_order = {'G': '1', 'R': '2', 'W': '3', 'L': '4', 'P': '5', 'F': '6', 'D': '7', 'M': '8', 'N': '9', 'C': 'A'}
        evolution_order = {'Basic': '1', 'Stage1': '2', 'Stage2': '3'}
        
        if card_type.startswith(tuple(element_order.keys())):
            # Pokemon card (e.g., "GBasic", "RStage1")
            element = card_type[0] if card_type else 'Z'
            evolution = card_type[1:] if len(card_type) > 1 else ''
            type_sort = element_order.get(element, 'Z') + evolution_order.get(evolution, '9')
        else:
            # Trainer/Energy - sort after all Pokemon
            type_sort = 'Z' + card_type
        
        return (tournament_date, archetype, type_sort, -percentage, card_name)
    
    result.sort(key=sort_key)
    
    print(f"\nâœ… Final Results:")
    print(f"  â€¢ {len(result)} card entries across {len(archetype_cards)} archetypes")
    print(f"  â€¢ Lookup Summary: {successful_lookups} found âœ“, {failed_lookups} not found âœ—")
    if failed_lookups > 0:
        print(f"  âš ï¸  {failed_lookups} cards missing set/number info (check all_cards_database.csv)")
    return result

# ============================================================================
# CSV OUTPUT
# ============================================================================

def save_to_csv(data: List[Dict[str, Any]], output_file: str, append_mode: bool = False):
    """Save aggregated data to CSV.
    
    Args:
        data: List of card data dictionaries
        output_file: Output filename (will be saved in data/ directory)
        append_mode: If True, append to existing CSV (dedup by tournament_date+archetype+card_name)
    """
    if not data:
        print("No data to save.")
        return
    
    output_path = os.path.join(get_data_dir(), output_file)
    
    # Ensure output directory exists
    os.makedirs(os.path.dirname(output_path), exist_ok=True)
    
    # Load existing data if append mode
    existing_data = []
    if append_mode and os.path.exists(output_path):
        print(f"Loading existing data from: {output_path}")
        try:
            with open(output_path, 'r', newline='', encoding='utf-8-sig') as f:
                reader = csv.DictReader(f, delimiter=';')
                existing_data = list(reader)
                # Convert percentage back from comma to dot
                for row in existing_data:
                    if 'percentage_in_archetype' in row:
                        row['percentage_in_archetype'] = row['percentage_in_archetype'].replace(',', '.')
                print(f"  Loaded {len(existing_data)} existing entries")
        except Exception as e:
            print(f"  Warning: Could not load existing data: {e}")
            existing_data = []
    
    # Merge data if append mode (dedup by tournament_date + archetype + card_name)
    if append_mode and existing_data:
        print("Merging with new data (deduplicating)...")
        # Create lookup key: tournament_date|archetype|card_name
        new_keys = {f"{row.get('tournament_date', '')}|{row['archetype']}|{row['card_name']}" for row in data}
        
        # Keep existing entries that don't conflict with new data
        merged_data = [row for row in existing_data 
                      if f"{row.get('tournament_date', '')}|{row['archetype']}|{row['card_name']}" not in new_keys]
        merged_data.extend(data)
        
        print(f"  Kept {len(existing_data) - (len(existing_data) - len(merged_data) + len(data))} existing entries")
        print(f"  Added {len(data)} new entries")
        print(f"  Total: {len(merged_data)} entries")
        
        data = merged_data
    
    print(f"\nSaving data to: {output_path}")
    
    fieldnames = ['meta', 'tournament_date', 'archetype', 'card_name', 'card_identifier', 'total_count', 'max_count', 'deck_count', 
                  'total_decks_in_archetype', 'percentage_in_archetype',
                  'set_code', 'set_name', 'set_number', 'rarity', 'type', 'image_url', 'is_ace_spec']
    
    try:
        with open(output_path, 'w', newline='', encoding='utf-8-sig') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames, delimiter=';')
            writer.writeheader()
            
            for row in data:
                # Format percentage with comma for German Excel
                row_formatted = row.copy()
                row_formatted['percentage_in_archetype'] = str(row['percentage_in_archetype']).replace('.', ',')
                writer.writerow(row_formatted)
        
        print(f"Successfully saved {len(data)} entries to {output_file}")
    except Exception as e:
        print(f"Error saving to CSV: {e}")
