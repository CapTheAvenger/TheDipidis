<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:,">
    <title>Pokemon Deck Viewer & Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .tab-btn.active {
            background: white;
            color: #667eea;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .content-wrapper {
            margin-top: 60px;
            padding: 20px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 3px solid #667eea;
        }
        
        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .control-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .variant-selector {
            background: #e8f4f8;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .variant-selector h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .variant-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            cursor: pointer;
        }

        .variant-toggle {
            display: inline-block;
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
            border: 3px solid #1d3557;
            cursor: pointer;
            transition: transform 0.3s ease;
            overflow: hidden;
        }

        /* Mittlerer schwarzer Ring */
        .variant-toggle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 6px;
            background: #1d3557;
            z-index: 2;
        }

        /* Wei√üer Knopf in der Mitte */
        .variant-toggle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 14px;
            height: 14px;
            background: white;
            border: 3px solid #1d3557;
            border-radius: 50%;
            z-index: 3;
            transition: all 0.3s ease;
        }

        /* Geschlossener Pok√©ball */
        .variant-toggle.collapsed {
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
        }

        /* Offener Pok√©ball - H√§lften auseinander */
        .variant-toggle:not(.collapsed) {
            background: linear-gradient(to bottom, 
                #e63946 0%, #e63946 35%, 
                transparent 35%, transparent 65%, 
                white 65%, white 100%);
        }

        .variant-toggle:not(.collapsed)::after {
            box-shadow: 0 0 0 4px rgba(29, 53, 87, 0.2);
        }

        .variant-toggle:hover {
            transform: scale(1.1);
            filter: brightness(1.1);
        }
        
        .variant-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .variant-search-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .variant-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .variant-checkbox {
            display: flex;
            align-items: center;
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .variant-checkbox:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .variant-checkbox input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        .variant-checkbox.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .deck-select-wrapper {
            position: relative;
        }
        
        .deck-select-wrapper input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
        }
        
        .deck-select-wrapper input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .stats-section {
            padding: 30px;
            background: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        
        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }
        
        .matchups {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .matchup-box {
            padding: 20px;
            border-radius: 10px;
            background: #f8f9fa;
        }
        
        .matchup-box h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .matchup-box.good {
            border-left: 5px solid #28a745;
        }
        
        .matchup-box.bad {
            border-left: 5px solid #dc3545;
        }
        
        .matchup-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .cards-section {
            padding: 30px;
            background: #f8f9fa;
        }
        
        .cards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .cards-table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0 15px 0;
            cursor: pointer;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .cards-table-header:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .cards-header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .cards-toggle {
            display: inline-block;
            position: relative;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
            border: 3px solid #1d3557;
            cursor: pointer;
            transition: transform 0.3s ease;
            overflow: hidden;
            flex-shrink: 0;
        }

        .cards-toggle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 5px;
            background: #1d3557;
            z-index: 2;
        }

        .cards-toggle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: white;
            border: 3px solid #1d3557;
            border-radius: 50%;
            z-index: 3;
            transition: all 0.3s ease;
        }

        .cards-toggle.collapsed {
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
        }

        .cards-toggle:not(.collapsed) {
            background: linear-gradient(to bottom, 
                #e63946 0%, #e63946 35%, 
                transparent 35%, transparent 65%, 
                white 65%, white 100%);
        }

        .cards-toggle:not(.collapsed)::after {
            box-shadow: 0 0 0 3px rgba(29, 53, 87, 0.2);
        }

        .cards-toggle:hover {
            transform: scale(1.1);
            filter: brightness(1.1);
        }
        
        .card-search-input {
            width: 100%;
            max-width: 400px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .card-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .deck-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .deck-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            max-height: 800px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .card-visual {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            background: #f0f0f0;
        }
        
        .card-visual:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        
        .card-visual img {
            width: 90px;
            height: 126px;
            display: block;
            object-fit: cover;
        }
        
        .card-visual .card-count-badge {
            position: absolute;
            top: 3px;
            right: 3px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
            z-index: 2;
        }
        
        .card-visual .card-name-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: white;
            padding: 10px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        /* Compact image view f√ºr Mobilansicht */
        /* Mobile Card View f√ºr Karten-Liste */
        .cards-list-mobile {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-top: 15px;
        }
        
        @media (max-width: 768px) {
            .cards-list-mobile {
                grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                gap: 12px;
                padding: 10px;
            }
        }
        
        .card-item {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            background: white;
        }
        
        .card-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        
        .card-item img {
            width: 100%;
            aspect-ratio: 2.5/3.5;
            display: block;
            object-fit: cover;
        }
        
        .card-item-info {
            padding: 8px;
            background: white;
            font-size: 0.75em;
            text-align: center;
        }
        
        .card-item-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .card-item-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: 600;
            margin-bottom: 3px;
            color: #333;
        }
        
        .card-item-set {
            color: #666;
            font-size: 0.85em;
        }
        
        .card-item-actions {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            justify-content: center;
        }
        
        .card-item-actions button {
            padding: 4px 8px;
            font-size: 0.75em;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .card-item-actions .btn-add {
            background: #28a745;
            color: white;
            flex: 1;
        }
        
        .card-item-actions .btn-add:active {
            background: #218838;
        }
        
        .cards-list-hidden {
            display: none !important;
        }
        
        /* Desktop vs Mobile Ansichts-Toggle */
        #cardsTableDesktop {
            display: block;
        }
        
        #cardsGridMobile {
            display: none;
        }
        
        @media (max-width: 768px) {
            #cardsTableDesktop {
                display: none;
            }
            
            #cardsGridMobile {
                display: grid !important;
            }
        }

        .compact-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 4px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .compact-card {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            background: #f0f0f0;
        }
        
        .compact-card:active {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .compact-card img {
            width: 50px;
            height: 70px;
            display: block;
            object-fit: cover;
        }
        
        .compact-card .compact-badge {
            position: absolute;
            top: 1px;
            right: 1px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 9px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            z-index: 2;
        }
        
        .image-view-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
            padding: 10px;
        }
        
        .image-view-modal.show {
            display: flex;
            flex-direction: column;
        }
        
        .image-view-content {
            background: white;
            border-radius: 15px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            margin: auto;
        }
        
        .image-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .image-view-header h3 {
            margin: 0;
            color: #333;
        }
        
        .image-view-close {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .image-view-close:hover {
            background: #c82333;
        }
        
        .card-visual.no-image {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 210px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: center;
        }
        
        .card-visual.no-image .fallback-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .card-visual.no-image .fallback-icon {
            font-size: 3em;
        }
        
        .cards-table {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        th.col-image {
            width: 100px;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .card-thumbnail {
            width: 80px;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .card-thumbnail:hover {
            transform: scale(1.1);
        }
        
        .card-thumbnail-placeholder {
            width: 80px;
            height: 110px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2em;
        }
        
        tbody tr:hover {
            background: #f8f9fa;
        }
        
        .card-count {
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
        }
        
        .deck-builder {
            padding: 30px;
            background: white;
            border-top: 3px solid #667eea;
        }
        
        .deck-builder h2 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .builder-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        @media (max-width: 768px) {
            .builder-controls {
                gap: 8px;
            }
            
            .btn {
                padding: 10px 12px;
                font-size: 0.85em;
                flex: 1;
                min-width: 80px;
            }
            
            .matchups-grid {
                grid-template-columns: 1fr !important;
            }
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-warning:hover {
            background: #e0a800;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
        }
        
        .deck-list {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }

        .card-filter-section {
            padding: 30px;
            background: #ffffff;
            border-top: 3px solid #667eea;
        }

        .card-filter-section h2 {
            margin-bottom: 10px;
            color: #333;
        }

        .card-filter-section p {
            color: #666;
            margin-bottom: 20px;
        }

        .filtered-cards-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: none;
        }

        .filtered-cards-visual.show {
            display: block;
        }

        .filtered-cards-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }

        .filtered-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            max-height: 800px;
            overflow-y: auto;
            padding: 10px;
        }

        .filter-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-type-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .dropdown-container {
            position: relative;
            width: 100%;
        }

        .dropdown-button {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #f8f9fa;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .dropdown-button:hover {
            border-color: #667eea;
            background: #eef2ff;
        }

        .dropdown-button.open {
            border-color: #667eea;
            background: #eef2ff;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-top: none;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .dropdown-menu.open {
            max-height: 250px;
            overflow-y: auto;
        }

        .dropdown-menu label {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .dropdown-menu label:hover {
            background: #f8f9fa;
        }

        .dropdown-menu input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        #cardTypeFilters {
            display: none;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .filter-summary {
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }
        
        .deck-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }
        
        .deck-card-controls {
            display: flex;
            gap: 5px;
        }
        
        .deck-card-controls button {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .btn-add {
            background: #28a745;
            color: white;
        }
        
        .btn-remove {
            background: #dc3545;
            color: white;
        }
        
        .deck-summary {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            text-align: center;
        }
        
        .deck-summary h3 {
            font-size: 1.5em;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }
        
        .error {
            background: #dc3545;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .percentage-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .percentage-high {
            background: #28a745;
            color: white;
        }
        
        .percentage-medium {
            background: #ffc107;
            color: #333;
        }
        
        .percentage-low {
            background: #6c757d;
            color: white;
        }
        
        /* Limitless Online Comparison Styling */
        #limitlessContent {
            padding: 30px;
        }
        
        .limitless-comparison .meta-info {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .limitless-comparison .meta-info span {
            display: inline-block;
            margin: 0 15px;
            font-weight: bold;
        }
        
        .limitless-comparison .section {
            margin-bottom: 40px;
        }
        
        .limitless-comparison .section h2 {
            color: #34495e;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .limitless-comparison .section h3 {
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .limitless-comparison .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .limitless-comparison .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .limitless-comparison .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .limitless-comparison .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .limitless-comparison .stat-card p {
            margin: 10px 0 0 0;
            font-size: 0.95em;
        }
        
        .limitless-comparison table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .limitless-comparison table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .limitless-comparison table td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .limitless-comparison table tr:hover {
            background-color: #f8f9fa;
        }
        
        .limitless-comparison .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .limitless-comparison .badge-new {
            background-color: #2ecc71;
            color: white;
        }
        
        .limitless-comparison .badge-disappeared {
            background-color: #e74c3c;
            color: white;
        }
        
        .limitless-comparison .badge-stable {
            background-color: #95a5a6;
            color: white;
        }
        
        .limitless-comparison .badge-up {
            background-color: #3498db;
            color: white;
        }
        
        .limitless-comparison .badge-down {
            background-color: #e67e22;
            color: white;
        }
        
        .limitless-comparison .positive {
            color: #27ae60;
            font-weight: bold;
        }
        
        .limitless-comparison .negative {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .limitless-comparison .neutral {
            color: #95a5a6;
        }
        
        .limitless-comparison .rank-change {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .limitless-comparison .rank-up {
            background-color: #d4edda;
            color: #155724;
        }
        
        .limitless-comparison .rank-down {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <!-- Tab Navigation -->
    <div class="tab-navigation">
        <button class="tab-btn active" onclick="switchTab('deck-viewer')">üÉè Deck Viewer & Builder</button>
        <button class="tab-btn" onclick="switchTab('karten-filter')">üß∞ Karten-Filter</button>
        <button class="tab-btn" onclick="switchTab('city-league')">üáØüáµ City League Development</button>
        <button class="tab-btn" onclick="switchTab('limitless-online')">üéÆ Limitless Online Comparison</button>
    </div>

    <div class="content-wrapper">
        <!-- Tab 1: Deck Viewer -->
        <div id="deck-viewer" class="tab-content active">
            <div class="container">
                <div class="header">
            <h1>ü¶Ö Pokemon Deck Viewer & Builder</h1>
            <p>Analyze and Build Decks</p>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label for="deckSearch">üîç Deck suchen:</label>
                    <input type="text" id="deckSearch" placeholder="Deck-Name eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                </div>
                <div class="control-group">
                    <label for="deckSelect">üéØ Deck Archetype w√§hlen:</label>
                    <select id="deckSelect" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                        <option value="">-- Bitte Deck ausw√§hlen --</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="filterSelect">ü¶Ç Karten Filter:</label>
                    <select id="filterSelect">
                        <option value="all">Alle Karten</option>
                        <option value="90">Karten in >90% der Decks (Core)</option>
                        <option value="70">Karten in >70% der Decks</option>
                        <option value="50">Karten in >50% der Decks</option>
                    </select>
                </div>
                <div class="control-group" style="order: -1; width: 100%;">
                    <label for="metaMainFilterDropdown">üåü Meta:</label>
                    <div class="custom-multiselect" id="metaMainFilterDropdown" tabindex="0" style="width: 100%; position: relative;">
                        <div class="multiselect-selected" id="metaMainFilterSelected" style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 8px; font-size: 16px; background: #f8f9fa; cursor: pointer; user-select: none;">Alle</div>
                        <div class="multiselect-options" id="metaMainFilterOptions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #fff; border: 2px solid #667eea; border-top: none; border-radius: 0 0 8px 8px; z-index: 10; max-height: 220px; overflow-y: auto;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="stats-section" id="statsSection" style="display: none;">
            <div class="variant-selector" id="variantSelector" style="display: none;">
                <div class="variant-header" onclick="toggleVariantSelector()">
                    <h3>üîÑ Weitere Deck-Varianten dazupacken:</h3>
                    <span class="variant-toggle collapsed" id="variantToggle"></span>
                </div>
                <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">
                    W√§hle zus√§tzliche Varianten aus, um mehr Karten-Optionen f√ºr dein Custom-Deck zu sehen
                </p>
                <input type="text" id="variantSearchInput" placeholder="üîç Varianten durchsuchen..." class="variant-search-input" oninput="onVariantSearchInput()">
                <div class="variant-options" id="variantOptions"></div>
            </div>
            
            <h2>üìä Deck Statistiken</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="label">Ranking</div>
                    <div class="value" id="statRanking">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Total Win Rate</div>
                    <div class="value" id="statWinRate">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">√ò Platzierung</div>
                    <div class="value" id="statMatches">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Vs Top 20</div>
                    <div class="value" id="statBalance">-</div>
                </div>
            </div>
            
            <div class="matchups" id="matchupsSection" style="display: none; margin-top: 30px;">
                <div style="margin-bottom: 20px; background: #f8f9fa; padding: 20px; border-radius: 8px;">
                    <h2 style="color: #2c3e50; margin-top: 0;">üéØ Matchup-Analyse</h2>
                    <h3 style="color: #667eea; margin-top: 10px; margin-bottom: 20px;" id="matchupsDeckTitle">Deck Name</h3>
                    
                    <div class="matchups-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <!-- Best Matchups -->
                        <div>
                            <h4 style="color: #27ae60; margin-bottom: 10px;">‚úÖ Best Matchups</h4>
                            <table style="box-shadow: none; width: 100%;">
                                <tr style="background: #d4edda;">
                                    <th style="background: #27ae60; color: white; padding: 8px; text-align: left;">Opponent</th>
                                    <th style="background: #27ae60; color: white; padding: 8px; text-align: right;">Win Rate</th>
                                    <th style="background: #27ae60; color: white; padding: 8px; text-align: right;">Record</th>
                                </tr>
                                <tbody id="topMatchups"></tbody>
                            </table>
                        </div>
                        
                        <!-- Worst Matchups -->
                        <div>
                            <h4 style="color: #e74c3c; margin-bottom: 10px;">‚ùå Worst Matchups</h4>
                            <table style="box-shadow: none; width: 100%;">
                                <tr style="background: #f8d7da;">
                                    <th style="background: #e74c3c; color: white; padding: 8px; text-align: left;">Opponent</th>
                                    <th style="background: #e74c3c; color: white; padding: 8px; text-align: right;">Win Rate</th>
                                    <th style="background: #e74c3c; color: white; padding: 8px; text-align: right;">Record</th>
                                </tr>
                                <tbody id="worstMatchups"></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Opponent Analyzer -->
                    <div style="background: linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(46, 204, 113, 0.1)); padding: 20px; border-radius: 10px; border-left: 5px solid #3498db; margin-top: 20px;">
                        <h4 style="margin-top: 0; color: #3498db; display: flex; align-items: center; gap: 10px;">
                            <span>üîç</span>
                            <span>Select & Analyze Opponent</span>
                        </h4>
                        <select id="opponentSelect" onchange="showMatchupAnalyzer(this.value)" style="width: 100%; padding: 12px 15px; border: 2px solid #3498db; border-radius: 8px; font-size: 1em; background: white; cursor: pointer; font-weight: 500;">
                            <option value="">-- Choose Opponent Deck --</option>
                        </select>
                        <div id="matchupAnalysisDetails" style="margin-top: 15px; display: none; background: white; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="cards-section">
            <div class="cards-header">
                <h2>üÉè Karten Liste</h2>
                <span style="font-size: 1.1em; color: #333;"><span id="cardCount">0 Karten</span><span id="cardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
            </div>
            
            <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="btn btn-warning" onclick="generateDeckCardsImage()" id="generateDeckCardsBtn" style="display: none;">ÔøΩ Grid</button>
                <button class="btn btn-primary" onclick="copyAllCardsData()" id="copyAllCardsBtn" style="display: none;">üìã Copy</button>
            </div>
        
            <!-- Deck Visualisierung -->
            <div class="deck-visual" id="deckVisual" style="display: none;">
                <h3>üé® Deck √úbersicht</h3>
                <div class="deck-grid" id="deckGrid">
                    <!-- Karten werden hier dynamisch eingef√ºgt -->
                </div>
            </div>
            
            <!-- Toggle f√ºr Karten-Tabelle -->
            <div class="cards-table-header" onclick="toggleCardsTable()">
                <div class="cards-header-left">
                    <span class="cards-toggle collapsed" id="cardsToggle"></span>
                    <h3>üìã Einzelne Karten</h3>
                </div>
            </div>
            
            <div id="cardsTableContent" style="display: none;">
                <input type="text" id="cardSearchInputDeckView" placeholder="üîç Karte suchen..." class="card-search-input" oninput="filterCards()" style="margin-bottom: 15px; width: 100%; max-width: 500px;">
                
                <!-- Desktop Tabellen-Ansicht -->
                <div class="cards-table" id="cardsTableDesktop">
                    <table>
                        <thead>
                            <tr>
                                <th class="col-image">Bild</th>
                                <th>Anzahl</th>
                                <th>Kartenname</th>
                                <th>Set</th>
                                <th>Nummer</th>
                                <th>% in Archetype</th>
                                <th>Aktion</th>
                            </tr>
                        </thead>
                        <tbody id="cardsBody">
                            <tr>
                                <td colspan="7" class="loading">Bitte w√§hle ein Deck aus...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- Mobile Cards Grid-Ansicht -->
                <div class="cards-list-mobile" id="cardsGridMobile" style="display: none;">
                    <!-- Wird dynamisch gef√ºllt -->
                </div>
            </div>
        </div>
        
        <div class="deck-builder">
            <h2>üõ†Ô∏è Deck Builder (60 Karten)</h2>
            <div class="builder-controls">
                <button class="btn btn-primary" onclick="exportToPokemonLive()">üìã Copy</button>
                <button class="btn btn-warning" onclick="generateDeckImage()">üñºÔ∏è Grid</button>
                <button class="btn btn-secondary" onclick="clearDeck()">üóëÔ∏è Clear</button>
                <button class="btn btn-success" onclick="autoComplete()">‚ö° Generate Deck</button>
            </div>
            
            <div class="deck-summary">
                <h3>Aktuell: <span id="deckCardCount">0</span> / 60 Karten <span id="deckCardCountUnique" style="font-weight: normal; font-size: 0.9em; color: #666;">(0 Unique)</span></h3>
            </div>
            
            <div id="myDeckVisual" style="display: none;">
                <h3>üé¥ Dein Deck √úbersicht</h3>
                <div class="deck-grid" id="myDeckGrid"></div>
            </div>
            
            <div class="deck-list" id="deckList">
                <p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>
            </div>
        </div>
    </div>
    
    <script>
        // GitHub Pages base path detection
        const BASE_PATH = window.location.hostname.includes('github.io') ? '/HausiTCG/' : '/';
        
        // Global data storage - MUST be at the top before any functions
        let cardsData = [];
        let allCardsDatabase = [];  // All 8788 cards from all_cards_database.csv for searching all versions
        let matchupsData = [];
        let matchupDetailsData = [];
        let cityLeagueData = [];
        let top20LimitlessArchetypes = [];
        let top10CityLeagueArchetypes = [];
        let limitlessDeckStats = {};
        let myDeck = [];
        let cardTypeDatabase = new Map();
        let filteredCards = [];
        let currentDeckCards = [];
        let currentMainDeckName = '';
        let currentAlternativeDeckName = '';  // Alternative Limitless deck for missing data
        let limitlessMatchupData = {};

                        // Generate matchupDetailsData from cardsData (global)
                        function generateMatchupDetailsData() {
                            matchupDetailsData = [];
                            limitlessMatchupData = {};
                            console.log('Generated matchup details data from cardsData');
                        }

                        function buildLimitlessMatchupData(details = []) {
                            const result = {};
                            console.log('[buildLimitlessMatchupData] Processing', details.length, 'matchup details');
                            details.forEach(row => {
                                const deckName = row.deck_name || row.deck || '';
                                const opponent = row.opponent || row.opponent_deck || '';
                                if (!deckName || !opponent) return;

                                const winRateRaw = String(row.win_rate || '').replace('%', '').trim();
                                const winRateNum = parseFloat(winRateRaw.replace(',', '.'));
                                const winRateNumeric = Number.isNaN(winRateNum) ? 0 : winRateNum;
                                const winRateDisplay = winRateRaw ? `${winRateRaw}%` : '0%';

                                if (!result[deckName]) result[deckName] = {};
                                result[deckName][opponent] = {
                                    opponent_deck: opponent,
                                    win_rate: winRateDisplay,
                                    win_rate_numeric: winRateNumeric,
                                    record: row.record || '',
                                    total_games: parseInt(row.total_games || '0', 10) || 0
                                };
                            });
                            console.log('[buildLimitlessMatchupData] Built matchup data for', Object.keys(result).length, 'decks');
                            return result;
                        }
                // Load Limitless data from CSV (with cache-busting)
                async function loadMatchupsData() {
                    console.log('[loadMatchupsData] START');
                    try {
                        const timestamp = new Date().getTime();
                        const response = await fetch(`${BASE_PATH}data/limitless_online_decks.csv?t=${timestamp}`);
                        if (response.ok) {
                            const text = await response.text();
                            matchupsData = parseCSV(text);
                            console.log('Loaded Limitless decks - Entries:', matchupsData.length);
                            
                            // Load matchups data
                            let matchupsDetailsData = [];
                            try {
                                const matchupsUrl = `${BASE_PATH}data/limitless_online_decks_matchups.csv?t=${timestamp}`;
                                console.log('[loadMatchupsData] Fetching from:', matchupsUrl);
                                const matchupsResponse = await fetch(matchupsUrl);
                                console.log('[loadMatchupsData] Matchups response status:', matchupsResponse.status, matchupsResponse.ok);
                                if (matchupsResponse.ok) {
                                    const matchupsText = await matchupsResponse.text();
                                    console.log('[loadMatchupsData] Fetched CSV, parsing...');
                                    matchupsDetailsData = parseCSV(matchupsText);
                                    matchupDetailsData = matchupsDetailsData;
                                    console.log('[loadMatchupsData] Parsed', matchupsDetailsData.length, 'matchup rows');
                                    console.log('[loadMatchupsData] First row:', matchupsDetailsData[0]);
                                    limitlessMatchupData = buildLimitlessMatchupData(matchupsDetailsData);
                                    console.log('[loadMatchupsData] Built global limitlessMatchupData, decks:', Object.keys(limitlessMatchupData).length);
                                    console.log('[loadMatchupsData] First deck matchups:', Object.keys(limitlessMatchupData)[0], '->', Object.keys(limitlessMatchupData[Object.keys(limitlessMatchupData)[0]] || {}).length, 'opponents');
                                } else {
                                    console.warn('[loadMatchupsData] Matchups CSV not found (status:', matchupsResponse.status, ')');
                                }
                            } catch (e) {
                                console.warn('[loadMatchupsData] Catch error:', e);
                            }
                            
                            renderLimitlessTable(matchupsDetailsData);
                        } else {
                            console.warn('Limitless decks data not found - generating from cardsData');
                            generateMatchupsDataFallback();
                        }
                    } catch (error) {
                        console.error('Error loading matchups data:', error);
                        generateMatchupsDataFallback();
                    }
                }

        // Helper function to escape HTML entities
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Loads cardsData from CSV (now global)
        async function loadCardsData() {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(BASE_PATH + `data/unified_card_data.csv?t=${timestamp}`);
                if (response.ok) {
                    const text = await response.text();
                    cardsData = parseCSV(text);
                    console.log('Loaded cards data - Entries:', cardsData.length);
                    console.log('First card:', cardsData[0]);
                    
                    // Debug: Check Ace Spec cards
                    const aceSpecCards = cardsData.filter(c => c.is_ace_spec === 'Yes' || c.is_ace_spec === true);
                    console.log('Ace Spec cards found:', aceSpecCards.length);
                    if (aceSpecCards.length > 0) {
                        console.log('Sample Ace Spec cards:', aceSpecCards.slice(0, 3).map(c => ({
                            name: c.card_name,
                            is_ace_spec: c.is_ace_spec,
                            archetype: c.archetype,
                            percentage: c.percentage_in_archetype
                        })));
                    }
                } else {
                    console.warn('Cards data not found');
                }
            } catch (error) {
                console.error('Error loading cards data:', error);
            }
        }

        // Load all cards from all_cards_database.csv for searching all versions
        async function loadAllCardsDatabase() {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(BASE_PATH + `all_cards_database.csv?t=${timestamp}`);
                if (response.ok) {
                    const text = await response.text();
                    allCardsDatabase = parseCSV(text);
                    console.log('‚úÖ Loaded all_cards_database - Entries:', allCardsDatabase.length);
                    if (allCardsDatabase.length > 0) {
                        console.log('First card:', allCardsDatabase[0]);
                    }
                } else {
                    console.warn('all_cards_database.csv not found');
                }
            } catch (error) {
                console.error('Error loading all_cards_database:', error);
            }
        }

        // Load CardMarket prices from data/cardmarket_prices.csv
        let cardmarketPrices = new Map(); // Key: "SET/NUMBER", Value: {price, url}
        async function loadCardMarketPrices() {
            try {
                const timestamp = new Date().getTime();
            const response = await fetch(BASE_PATH + `data/cardmarket_prices.csv?t=${timestamp}`);
                if (response.ok) {
                    const text = await response.text();
                    // Parse CSV with proper handling of quoted fields (comma-delimited)
                    const lines = text.split('\n');
                    if (lines.length === 0) return;
                    
                    // Parse header
                    let headerLine = lines[0];
                    if (headerLine.charCodeAt(0) === 0xFEFF) {
                        headerLine = headerLine.substr(1);
                    }
                    const headers = parseCSVLine(headerLine);
                    
                    // Parse data rows
                    for (let i = 1; i < lines.length; i++) {
                        const line = lines[i].trim();
                        if (!line) continue;
                        
                        const values = parseCSVLine(line);
                        const row = {};
                        headers.forEach((header, index) => {
                            row[header] = values[index] || '';
                        });
                        
                        const set = (row.set || '').trim().toUpperCase();
                        const num = (row.number || '').trim();
                        const version = (row.version || '').trim();
                        
                        if (set && num && version) {
                            // Key: SET/NUMBER/VERSION (e.g., "MEG/184/3")
                            const key = set + '/' + num + '/' + version;
                            cardmarketPrices.set(key, {
                                price: (row.price_eur || '').trim(),
                                url: (row.cardmarket_url || '').trim(),
                                version: version
                            });
                        }
                    }
                    
                    console.log('‚úÖ Loaded CardMarket Prices - Entries:', cardmarketPrices.size);
                    if (cardmarketPrices.size > 0) {
                        const sample = Array.from(cardmarketPrices.entries())[0];
                        console.log('Sample:', sample[0], '->', sample[1]);
                    }
                } else {
                    console.warn('data/cardmarket_prices.csv not found (status:', response.status, ')');
                }
            } catch (error) {
                console.error('Error loading CardMarket prices:', error);
            }
        }
        
        // Helper function to parse CSV line with quoted field support
        function parseCSVLine(line) {
            const fields = [];
            let current = '';
            let insideQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                const nextChar = line[i + 1];
                
                if (char === '"') {
                    if (insideQuotes && nextChar === '"') {
                        // Escaped quote
                        current += '"';
                        i++; // Skip next quote
                    } else {
                        // Toggle quote state
                        insideQuotes = !insideQuotes;
                    }
                } else if (char === ',' && !insideQuotes) {
                    // Field separator
                    let trimmed = current.trim();
                    // Remove surrounding quotes if present
                    if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
                        trimmed = trimmed.slice(1, -1);
                    }
                    fields.push(trimmed);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Add last field
            let trimmed = current.trim();
            // Remove surrounding quotes if present
            if (trimmed.startsWith('"') && trimmed.endsWith('"')) {
                trimmed = trimmed.slice(1, -1);
            }
            fields.push(trimmed);
            return fields;
        }

        // Load data on page load
        document.addEventListener('DOMContentLoaded', async () => {
            await loadCardsData();
            await loadAllCardsDatabase();  // Load all versions
            await loadCardMarketPrices();  // Load CardMarket prices
            await loadCityLeagueData();
            await loadMatchupsData();
            buildMetaOptionsFromCards();
            syncMetaSetCodeMapFromCards();
            populateDeckDropdown();  // Call after all data is loaded
            initializeCardFilterUI();
            renderMetaMainFilter();
            setupEventListeners();
        });

        // Refresh all data (reload from CSVs with cache-busting)
        function refreshAllData() {
            console.log('üîÑ Lade Daten neu mit cache-busting...');
            try {
                loadCityLeagueData();
                loadMatchupsData();
                console.log('‚úÖ Daten erfolgreich aktualisiert');
                alert('‚úÖ Comparison-Daten wurden aktualisiert!');
            } catch (error) {
                console.error('‚ùå Fehler beim Aktualisieren der Daten:', error);
                alert('‚ùå Fehler beim Aktualisieren der Daten');
            }
        }
                // --- Meta Filter (fixe Reihenfolge + optionale neue Metas) ---
                let metaMainOptions = [
                    { label: 'Alle', value: 'all' },
                    { label: 'City Leagues', value: 'city_leagues' },
                    { label: 'SVI - PFL', value: 'SVI-PFL' },
                    { label: 'SVI - MEG', value: 'SVI-MEG' },
                    { label: 'SVI - BLK/WHT', value: 'SVI-BLK' },
                    { label: 'SVI - DRI', value: 'SVI-DRI' },
                    { label: 'SVI - JTG', value: 'SVI-JTG' },
                    { label: 'BRS - PRE', value: 'BRS-PRE' },
                    { label: 'BRS - SSP', value: 'BRS-SSP' },
                    { label: 'BRS - SCR', value: 'BRS-SCR' },
                    { label: 'BRS - SFA', value: 'BRS-SFA' },
                    { label: 'BRS - TWM', value: 'BRS-TWM' },
                    { label: 'BRS - TEF', value: 'BRS-TEF' },
                    { label: 'BST - PAR', value: 'BST-PAR' },
                ];

                const metaFieldKeys = ['meta', 'meta_code', 'meta_group', 'meta_name'];
                const metaSetCodeMap = {
                    'SVI-PFL': new Set(),
                    'SVI-MEG': new Set(),
                    'SVI-BLK': new Set(),
                    'SVI-DRI': new Set(),
                    'SVI-JTG': new Set(),
                    'BRS-PRE': new Set(),
                    'BRS-SSP': new Set(),
                    'BRS-SCR': new Set(),
                    'BRS-SFA': new Set(),
                    'BRS-TWM': new Set(),
                    'BRS-TEF': new Set(),
                    'BST-PAR': new Set(),
                };

                let metaMainSelected = new Set(['all']); // Default: alle

                function getCardMetaValue(card) {
                    for (const key of metaFieldKeys) {
                        const value = card[key];
                        if (value && String(value).trim()) {
                            return String(value).trim();
                        }
                    }
                    return '';
                }

                function buildMetaOptionsFromCards() {
                    // Optional: neue Meta-Keys direkt nach City Leagues einf√ºgen, falls Daten eine Meta-Spalte liefern
                    const existing = new Set(metaMainOptions.map(opt => opt.value));
                    const discovered = new Set();
                    cardsData.forEach(card => {
                        const metaValue = getCardMetaValue(card);
                        if (metaValue && !existing.has(metaValue)) {
                            discovered.add(metaValue);
                        }
                    });
                    
                    if (discovered.size > 0) {
                        // Find insertion point and remove any existing duplicates first
                        const insertIndex = metaMainOptions.findIndex(opt => opt.value === 'city_leagues') + 1;
                        
                        // Remove any discovered metas that might already exist (prevent duplicates)
                        metaMainOptions = metaMainOptions.filter(opt => !discovered.has(opt.value));
                        
                        // Now add the discovered metas in sorted order
                        const ordered = Array.from(discovered).sort();
                        metaMainOptions.splice(insertIndex, 0, ...ordered.map(m => ({ label: m, value: m })));
                    }
                    
                    console.log('Meta options:', metaMainOptions.map(o => o.value));
                }

                function syncMetaSetCodeMapFromCards() {
                    const hasMetaField = cardsData.some(card => getCardMetaValue(card));
                    if (hasMetaField) {
                        return;
                    }
                    if (metaSetCodeMap['SVI-PFL'].size === 0) {
                        cardsData.forEach(card => {
                            if (card.set_code && String(card.set_code).trim()) {
                                metaSetCodeMap['SVI-PFL'].add(String(card.set_code).trim());
                            }
                        });
                    }
                }

                function renderMetaMainFilter() {
                    const selectedDiv = document.getElementById('metaMainFilterSelected');
                    const optionsDiv = document.getElementById('metaMainFilterOptions');
                    if (!selectedDiv || !optionsDiv) return;

                    // Default: only 'all' selected
                    metaMainSelected = new Set(['all']);
                    updateMetaMainSelectedText();

                    optionsDiv.innerHTML = '';
                    // --- 'Alle' Checkbox ---
                    const allLabel = document.createElement('label');
                    allLabel.style.display = 'block';
                    allLabel.style.padding = '8px 12px';
                    allLabel.style.cursor = 'pointer';
                    const allCheckbox = document.createElement('input');
                    allCheckbox.type = 'checkbox';
                    allCheckbox.value = 'all';
                    allCheckbox.checked = true;
                    allCheckbox.style.marginRight = '8px';
                    allCheckbox.addEventListener('change', () => {
                        if (allCheckbox.checked) {
                            metaMainSelected = new Set(metaMainOptions.map(opt => opt.value));
                            // Check all other checkboxes
                            optionsDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; });
                        } else {
                            metaMainSelected.clear();
                            // Uncheck all other checkboxes
                            optionsDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
                        }
                        updateMetaMainSelectedText();
                        populateDeckDropdown(); // Re-filter deck dropdown
                        updateCardsDisplay();
                    });
                    allLabel.appendChild(allCheckbox);
                    allLabel.appendChild(document.createTextNode('Alle'));
                    optionsDiv.appendChild(allLabel);
                    // --- Other Meta Checkboxes ---
                    metaMainOptions.filter(opt => opt.value !== 'all').forEach((opt, idx) => {
                        const label = document.createElement('label');
                        label.style.display = 'block';
                        label.style.padding = '8px 12px';
                        label.style.cursor = 'pointer';
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = opt.value;
                        checkbox.checked = false; // Start unchecked
                        checkbox.style.marginRight = '8px';
                        checkbox.addEventListener('change', () => {
                            if (checkbox.checked) {
                                metaMainSelected.delete('all'); // Deselect 'all' when selecting specific meta
                                metaMainSelected.add(opt.value);
                                allCheckbox.checked = false;
                            } else {
                                metaMainSelected.delete(opt.value);
                                // If no meta selected, select 'all'
                                if (metaMainSelected.size === 0) {
                                    metaMainSelected.add('all');
                                    allCheckbox.checked = true;
                                }
                            }
                            // Update 'Alle' checkbox state
                            const allChecked = metaMainOptions.filter(opt => opt.value !== 'all').every(opt => metaMainSelected.has(opt.value));
                            allCheckbox.checked = allChecked;
                            if (allChecked) metaMainSelected.add('all'); else metaMainSelected.delete('all');
                            updateMetaMainSelectedText();
                            populateDeckDropdown(); // Re-filter deck dropdown
                            updateCardsDisplay();
                        });
                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(opt.label));
                        optionsDiv.appendChild(label);
                    });

                    // Dropdown open/close logic
                    const dropdown = document.getElementById('metaMainFilterDropdown');
                    function openMetaDropdown(e) {
                        e.stopPropagation();
                        optionsDiv.style.display = optionsDiv.style.display === 'block' ? 'none' : 'block';
                        optionsDiv.style.zIndex = 10000;
                        optionsDiv.style.pointerEvents = 'auto';
                    }
                    dropdown.addEventListener('click', openMetaDropdown);
                    selectedDiv.addEventListener('click', openMetaDropdown);
                    selectedDiv.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            openMetaDropdown(e);
                        }
                    });
                    // Close on outside click
                    document.addEventListener('click', (e) => {
                        if (!dropdown.contains(e.target) && !optionsDiv.contains(e.target)) {
                            optionsDiv.style.display = 'none';
                        }
                    });
                    // Accessibility: allow tab focus
                    selectedDiv.setAttribute('tabindex', '0');
                    selectedDiv.setAttribute('role', 'button');
                    selectedDiv.setAttribute('aria-haspopup', 'listbox');
                    selectedDiv.setAttribute('aria-expanded', 'false');
                    optionsDiv.setAttribute('role', 'listbox');
                }

                function updateMetaMainSelectedText() {
                    const selectedDiv = document.getElementById('metaMainFilterSelected');
                    if (!selectedDiv) return;
                    if (metaMainSelected.size === 0 || metaMainSelected.has('all') || metaMainSelected.size === metaMainOptions.length) {
                        selectedDiv.textContent = 'Alle';
                    } else {
                        selectedDiv.textContent = Array.from(metaMainOptions)
                            .filter(opt => metaMainSelected.has(opt.value) && opt.value !== 'all')
                            .map(opt => opt.label)
                            .join(', ');
                    }
                }

                function getSelectedMetaMainOptions() {
                    // If "all" is selected, treat as empty selection (show all)
                    if (metaMainSelected.has('all') || metaMainSelected.size === 0) {
                        return new Set();
                    }
                    return new Set(metaMainSelected);
                }

                function cardMatchesMetaValue(card, metaValue) {
                    if (!metaValue) return false;
                    const cardMeta = getCardMetaValue(card);
                    if (cardMeta) {
                        return cardMeta === metaValue;
                    }
                    const setMap = metaSetCodeMap[metaValue];
                    if (setMap && card.set_code) {
                        return setMap.has(String(card.set_code).trim());
                    }
                    return false;
                }

                function cardMatchesSelectedMeta(card, selectedMeta) {
                    if (!selectedMeta || selectedMeta.size === 0) return true;
                    let matches = false;
                    if (selectedMeta.has('city_leagues')) {
                        const normalize = (str) => str.toLowerCase().trim();
                        if (cityLeagueData.some(j => normalize(j.archetype) === normalize(card.archetype))) {
                            matches = true;
                        }
                    }
                    for (const metaValue of selectedMeta) {
                        if (metaValue === 'all' || metaValue === 'city_leagues') continue;
                        if (cardMatchesMetaValue(card, metaValue)) {
                            matches = true;
                        }
                    }
                    return matches;
                }

                function archetypeMatchesSelectedMeta(archetype, selectedMeta) {
                    if (!selectedMeta || selectedMeta.size === 0) return true;
                    let matches = false;
                    if (selectedMeta.has('city_leagues')) {
                        const normalize = (str) => str.toLowerCase().trim();
                        if (cityLeagueData.some(j => normalize(j.archetype) === normalize(archetype))) {
                            matches = true;
                        }
                    }
                    for (const metaValue of selectedMeta) {
                        if (metaValue === 'all' || metaValue === 'city_leagues') continue;
                        if (cardsData.some(card => card.archetype === archetype && cardMatchesMetaValue(card, metaValue))) {
                            matches = true;
                        }
                    }
                    return matches;
                }
        
// Load City League data from CSV (with cache-busting)
                async function loadCityLeagueData() {
                    try {
                        const timestamp = new Date().getTime();
                        const response = await fetch(`${BASE_PATH}data/city_league_archetypes_comparison.csv?t=${timestamp}`);
                        if (response.ok) {
                            const text = await response.text();
                            cityLeagueData = parseCSV(text);
                            console.log('Loaded City League development - Entries:', cityLeagueData.length);
                            
                            // Load tournament count and date range from main archetype CSV
                            let tournamentCount = 0;
                            let dateRange = '';
                            try {
                                const tournamentsResponse = await fetch(`${BASE_PATH}data/city_league_archetypes.csv?t=${timestamp}`);
                                if (tournamentsResponse.ok) {
                                    const tournamentsText = await tournamentsResponse.text();
                                    const tournamentsData = parseCSV(tournamentsText);
                                    const uniqueTournaments = new Set(tournamentsData.map(d => d.tournament_id));
                                    tournamentCount = uniqueTournaments.size;
                                    
                                    // Extract date range with proper date parsing
                                    if (tournamentsData.length > 0) {
                                        const dates = tournamentsData.map(d => d.date).filter(d => d);
                                        if (dates.length > 0) {
                                            // Parse dates in format "DD Mon YY" and convert to comparable format
                                            const parsedDates = dates.map(d => {
                                                const parts = d.split(' ');
                                                if (parts.length >= 3) {
                                                    const day = parts[0];
                                                    const month = parts[1];
                                                    const year = parts[2];
                                                    // Create comparable date string in YYYY-MM-DD format
                                                    const monthMap = {'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06', 
                                                                      'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'};
                                                    const monthNum = monthMap[month] || '01';
                                                    const fullYear = '20' + year;
                                                    return {original: d, comparable: fullYear + monthNum + day.padStart(2, '0')};
                                                }
                                                return {original: d, comparable: '99999999'};
                                            });
                                            
                                            const minDateObj = parsedDates.reduce((a, b) => a.comparable < b.comparable ? a : b);
                                            const maxDateObj = parsedDates.reduce((a, b) => a.comparable > b.comparable ? a : b);
                                            
                                            dateRange = `${minDateObj.original} - ${maxDateObj.original}`;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('Could not load tournament data:', e);
                            }
                            
                            renderCityLeagueTable(tournamentCount, dateRange);
                        } else {
                            console.warn('City League development data not found - generating from cardsData');
                            generateCityLeagueDataFallback();
                        }
                    } catch (error) {
                        console.error('Error loading City League data:', error);
                        generateCityLeagueDataFallback();
                    }
                }

        // Render City League table with full structure matching original HTML
        function renderCityLeagueTable(tournamentCount = 0, dateRange = '') {
            const content = document.getElementById('cityLeagueContent');
            if (!content || !cityLeagueData || cityLeagueData.length === 0) return;

            // Separate data by status and trend
            const newArchetypes = cityLeagueData.filter(d => d.status === 'NEU');
            const disappeared = cityLeagueData.filter(d => d.status === 'VERSCHWUNDEN');
            const increased = cityLeagueData.filter(d => d.status !== 'NEU' && parseInt(d.count_change) > 0).sort((a, b) => parseInt(b.count_change) - parseInt(a.count_change));
            const decreased = cityLeagueData.filter(d => parseInt(d.count_change) < 0).sort((a, b) => parseInt(a.count_change) - parseInt(b.count_change));
            
            // Get max count for threshold filtering
            const maxCountForThreshold = Math.max(...cityLeagueData.map(d => parseInt(d.new_count)));
            const countThreshold = maxCountForThreshold * 0.1;
            
            // Performance improvers/decliners (better/worse avg placement) - with 10% threshold
            const improvers = cityLeagueData.filter(d => parseFloat(d.avg_placement_change) < 0 && parseInt(d.new_count) >= countThreshold).sort((a, b) => parseFloat(a.avg_placement_change) - parseFloat(b.avg_placement_change));
            const decliners = cityLeagueData.filter(d => parseFloat(d.avg_placement_change) > 0 && parseInt(d.new_count) >= countThreshold).sort((a, b) => parseFloat(b.avg_placement_change) - parseFloat(a.avg_placement_change));
            
            // Most active (by count)
            const sorted = [...cityLeagueData].sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count));
            const topActive = sorted.slice(0, 1)[0];
            const totalArchetypes = cityLeagueData.length;

            const now = new Date();
            const generatedDate = now.toLocaleString('de-DE', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // Get top 3 by count and top 3 by avg placement
            const topByCount = [...cityLeagueData].sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count)).slice(0, 3);
            const maxCount = parseInt(topByCount[0].new_count);
            const minCountThreshold = maxCount * 0.1;
            const topByPlacement = [...cityLeagueData]
                .filter(d => parseInt(d.new_count) >= minCountThreshold)
                .sort((a, b) => parseFloat(a.new_avg_placement) - parseFloat(b.new_avg_placement))
                .slice(0, 3);
            
            // Get top 10 changes
            const top10New = [...cityLeagueData].sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count)).slice(0, 10).map(d => d.archetype);
            const top10Old = [...cityLeagueData].sort((a, b) => parseInt(b.old_count) - parseInt(a.old_count)).slice(0, 10).map(d => d.archetype);
            const entries = top10New.filter(arch => !top10Old.includes(arch));
            const exits = top10Old.filter(arch => !top10New.includes(arch));

            let html = `
                
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 30px; text-align: center;">
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">üìÖ Generated: ${generatedDate}</span>
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">üìä Total Archetypes Tracked: ${totalArchetypes}</span>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">üìä Archetype Overview</h3>
                        <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${totalArchetypes}</div>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 15px; text-align: left;">
                            <strong>Top 3 by Count:</strong><br>
                            ${topByCount.map(d => `${d.archetype}: ${d.new_count}x`).join('<br>')}
                            <br><br>
                            <strong>Top 3 by Avg Placement:</strong><br>
                            ${topByPlacement.map(d => `${d.archetype}: ${d.new_avg_placement}`).join('<br>')}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">üîÑ Top 10 Changes</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; text-align: left;">
                            ${entries.length > 0 ? `<strong style="color: #7fff7f;">‚¨Ü Entries:</strong><br>${entries.map(arch => `${arch}`).join('<br>')}<br><br>` : ''}
                            ${exits.length > 0 ? `<strong style="color: #ff6b6b;">‚¨á Exits:</strong><br>${exits.map(arch => `${arch}`).join('<br>')}<br>` : ''}
                            ${entries.length === 0 && exits.length === 0 ? 'No changes in top 10' : ''}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">ÔøΩ Datenquelle</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px;">
                            <strong>Zeitraum:</strong><br>${dateRange || 'N/A'}<br><br>
                            <strong>Turniere:</strong><br>${tournamentCount || 0}
                        </div>
                    </div>
                </div>`;

            // Popularity Decreases
            if (decreased.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìâ Popularity Decreases</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Change</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Avg Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decreased.slice(0, 10).forEach(d => {
                    const change = parseInt(d.count_change);
                    const placement_change = parseFloat(d.avg_placement_change);
                    const placement_color = placement_change < 0 ? '#27ae60' : '#e74c3c';
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center; color: #e74c3c; font-weight: bold;">${change}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: ${placement_color}; font-weight: bold;">(${placement_change > 0 ? '+' : ''}${placement_change.toFixed(2)})</span></td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }

            // Performance Improvers
            if (improvers.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">‚≠ê Performance Improvers (Better Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Improvement</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Best Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                improvers.slice(0, 10).forEach(d => {
                    const improvement = Math.abs(parseFloat(d.avg_placement_change));
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_avg_placement}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                            <td style="padding: 12px; text-align: center; color: #27ae60; font-weight: bold;">-${improvement.toFixed(2)}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_best}</td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }

            // Performance Decliners
            if (decliners.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìâ Performance Decliners (Worse Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Decline</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Best Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decliners.slice(0, 10).forEach(d => {
                    const decline = parseFloat(d.avg_placement_change);
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_avg_placement}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                            <td style="padding: 12px; text-align: center; color: #e74c3c; font-weight: bold;">+${decline.toFixed(2)}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_best}</td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }

            // Full Comparison Table (Top 30)
            html += `
                <div style="margin-bottom: 40px;">
                    <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìã Full Comparison Table (Top 30)</h2>
                    <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Trend</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Count Old</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Count New</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Count Œî</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Avg Placement</th>
                            </tr>
                        </thead>
                        <tbody>`;
            
            sorted.slice(0, 30).forEach(d => {
                const trendColor = d.trend === 'VERBESSERT' ? '#27ae60' : d.trend === 'VERSCHLECHTERT' ? '#e67e22' : '#95a5a6';
                const trendArrow = d.trend === 'VERBESSERT' ? '‚Üë' : d.trend === 'VERSCHLECHTERT' ? '‚Üì' : '‚Üí';
                const changeColor = parseInt(d.count_change) > 0 ? '#27ae60' : '#e74c3c';
                
                html += `
                    <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                        <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                        <td style="padding: 12px; text-align: center; font-size: 1.2em; color: ${trendColor}; font-weight: bold;">${trendArrow}</td>
                        <td style="padding: 12px; text-align: center;">${d.old_count}</td>
                        <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                        <td style="padding: 12px; text-align: center; color: ${changeColor}; font-weight: bold;">(${parseInt(d.count_change) > 0 ? '+' : ''}${parseInt(d.count_change)})</td>
                        <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                    </tr>`;
            });

            html += `</tbody></table></div>`;
            content.innerHTML = html;
        }
        
        // Render Limitless Online table with full structure
        function renderLimitlessTable(matchupsDetailsData = []) {
            const content = document.getElementById('limitlessContent');
            if (!content || !matchupsData || matchupsData.length === 0) return;

            // Sort by rank
            const sorted = [...matchupsData].sort((a, b) => {
                const rankA = parseInt(a.rank) || 999;
                const rankB = parseInt(b.rank) || 999;
                return rankA - rankB;
            });

            const totalEntries = sorted.reduce((sum, d) => sum + (parseInt(d.count) || 0), 0);
            const topDeck = sorted.length > 0 ? sorted[0] : null;

            let html = `
                <div style="margin-bottom: 30px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px;">
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0 0 15px 0; font-size: 1.1em; opacity: 0.9;">üìä Total Decks</h3>
                            <div style="font-size: 2.5em; font-weight: bold;">${totalEntries.toLocaleString()}</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0 0 15px 0; font-size: 1.1em; opacity: 0.9;">üéØ Unique Archetypes</h3>
                            <div style="font-size: 2.5em; font-weight: bold;">${sorted.length}</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0 0 15px 0; font-size: 1.1em; opacity: 0.9;">üèÜ #1 Deck</h3>
                            <div style="font-size: 1.2em; font-weight: bold; word-break: break-word;">${topDeck ? topDeck.deck_name : 'N/A'}</div>
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 40px;">
                    <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üéÆ Deck Rankings</h2>
                    <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                <th style="padding: 12px; text-align: center; font-weight: 600; min-width: 60px;">Rank</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Deck Name</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Entries</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Meta Share</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Wins</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Losses</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Ties</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Win Rate</th>
                            </tr>
                        </thead>
                        <tbody>`;
            
            sorted.forEach((d, idx) => {
                const rank = d.rank || (idx + 1);
                const wins = parseInt(d.wins) || 0;
                const losses = parseInt(d.losses) || 0;
                const winsColor = wins > losses ? '#27ae60' : '#e74c3c';
                const lossesColor = losses > wins ? '#e74c3c' : '#27ae60';
                
                html += `
                    <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                        <td style="padding: 12px; text-align: center; font-weight: bold; color: #667eea; font-size: 1.1em;">#${rank}</td>
                        <td style="padding: 12px; font-weight: bold;">${d.deck_name}</td>
                        <td style="padding: 12px; text-align: center;">${parseInt(d.count).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center;">${d.share}</td>
                        <td style="padding: 12px; text-align: center; color: ${winsColor}; font-weight: bold;">${parseInt(d.wins).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center; color: ${lossesColor}; font-weight: bold;">${parseInt(d.losses).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center;">${parseInt(d.ties).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center; font-weight: bold; color: #667eea;"><strong>${d.win_rate}</strong></td>
                    </tr>`;
            });
            
            html += `</tbody></table></div>`;
            
            // Top 20 Matchups Section
            if (matchupsDetailsData.length > 0) {
                const top20 = sorted.slice(0, 20);
                const top20Names = new Set(top20.map(d => d.deck_name));
                
                html += `<div style="margin-bottom: 40px;">
                    <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üéØ Top 20 Matchup Analysis</h2>`;
                
                top20.forEach((deck, idx) => {
                    const deckName = deck.deck_name;
                    const winRate = parseFloat(deck.win_rate_numeric || 0);
                    const totalWins = parseInt(deck.wins) || 0;
                    const totalLosses = parseInt(deck.losses) || 0;
                    
                    // Find matchups for this deck
                    const deckMatchups = matchupsDetailsData.filter(m => m.deck_name === deckName);
                    
                    // Get good matchups (>54%) against top 20 decks
                    const goodMatchups = deckMatchups.filter(m => {
                        const opponentWR = parseFloat((m.win_rate || '0').replace(',', '.'));
                        return top20Names.has(m.opponent) && 
                               m.opponent !== deckName &&
                               opponentWR > 54;
                    }).sort((a, b) => parseFloat((b.win_rate || '0').replace(',', '.')) - parseFloat((a.win_rate || '0').replace(',', '.'))).slice(0, 5);
                    
                    // Get bad matchups (<45%) against top 20 decks
                    const badMatchups = deckMatchups.filter(m => {
                        const opponentWR = parseFloat((m.win_rate || '0').replace(',', '.'));
                        return top20Names.has(m.opponent) && 
                               m.opponent !== deckName &&
                               opponentWR < 45;
                    }).sort((a, b) => parseFloat((a.win_rate || '0').replace(',', '.')) - parseFloat((b.win_rate || '0').replace(',', '.'))).slice(0, 5);
                    
                    // Count positive vs negative matchups against top 20
                    const allTop20Matchups = deckMatchups.filter(m => top20Names.has(m.opponent) && m.opponent !== deckName);
                    const positiveCount = allTop20Matchups.filter(m => parseFloat((m.win_rate || '0').replace(',', '.')) >= 50).length;
                    const negativeCount = allTop20Matchups.filter(m => parseFloat((m.win_rate || '0').replace(',', '.')) < 50).length;
                    
                    const winRateColor = winRate >= 50 ? '#27ae60' : '#e74c3c';
                    
                    html += `<div style="margin-bottom: 30px; border: 1px solid #ecf0f1; border-radius: 8px; padding: 20px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 20px; margin-bottom: 20px; align-items: start;">
                            <div>
                                <h3 style="margin: 0 0 10px 0; color: #34495e;">#${idx + 1} ${deckName}</h3>
                                <p style="margin: 0; color: #667eea; font-size: 1.1em; font-weight: bold;">WR: <span style="color: ${winRateColor};">${winRate.toFixed(2)}%</span></p>
                            </div>
                            <div style="text-align: center;">
                                <p style="margin: 0; color: #34495e; font-weight: bold; font-size: 0.9em;">Vs Top 20</p>
                                <p style="margin: 5px 0 0 0; color: #27ae60; font-size: 1.1em; font-weight: bold;">${positiveCount}:${negativeCount}</p>
                            </div>
                            <div style="text-align: right; color: #95a5a6; font-size: 0.85em;">
                                ${totalWins}-${totalLosses}
                            </div>
                        </div>`;
                    
                    if (goodMatchups.length > 0 || badMatchups.length > 0) {
                        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">`;
                        
                        if (goodMatchups.length > 0) {
                            html += `<div>
                                <h4 style="color: #27ae60; margin: 0 0 10px 0; font-size: 0.9em;">‚úÖ Good Matchups (>54%)</h4>
                                <ul style="margin: 0; padding-left: 20px; font-size: 0.85em;">`;
                            goodMatchups.forEach(m => {
                                const wr = (m.win_rate || '0').replace(',', '.');
                                html += `<li style="margin-bottom: 5px; color: #34495e;">${m.opponent}<br><span style="color: #27ae60; font-weight: bold;">${wr}%</span></li>`;
                            });
                            html += `</ul>
                            </div>`;
                        }
                        
                        if (badMatchups.length > 0) {
                            html += `<div>
                                <h4 style="color: #e74c3c; margin: 0 0 10px 0; font-size: 0.9em;">‚ùå Bad Matchups (<45%)</h4>
                                <ul style="margin: 0; padding-left: 20px; font-size: 0.85em;">`;
                            badMatchups.forEach(m => {
                                const wr = (m.win_rate || '0').replace(',', '.');
                                html += `<li style="margin-bottom: 5px; color: #34495e;">${m.opponent}<br><span style="color: #e74c3c; font-weight: bold;">${wr}%</span></li>`;
                            });
                            html += `</ul>
                            </div>`;
                        }
                        
                        html += `</div>`;
                    } else {
                        html += `<p style="color: #95a5a6; font-size: 0.9em; margin: 0;">No matchup data available</p>`;
                    }
                    
                    html += `</div>`;
                });
                
                html += `</div>`;
            }
            
            html += `</div>`;
            
            content.innerHTML = html;
        }
        function generateCityLeagueDataFallback() {
            try {
                cityLeagueData = [];
                const archetypeStats = {};

                cardsData.forEach(card => {
                    if (!card.archetype) return;
                    
                    const archetype = card.archetype;
                    if (!archetypeStats[archetype]) {
                        archetypeStats[archetype] = {
                            archetype: archetype,
                            old_count: 0,
                            new_count: 0,
                            count_change: 0,
                            old_avg_placement: 0,
                            new_avg_placement: 0,
                            avg_placement_change: 0,
                            old_best: 999,
                            new_best: 999,
                            status: 'BESTEHEND',
                            trend: 'STABIL'
                        };
                    }
                    
                    const total = parseInt(card.total_decks_in_archetype || '0', 10) || 0;
                    const avgPlace = parseFloat(card.avg_placement || '0') || 0;
                    const best = parseInt(card.best_placement || '999', 10) || 999;
                    
                    archetypeStats[archetype].new_count = Math.max(archetypeStats[archetype].new_count, total);
                    archetypeStats[archetype].new_avg_placement = avgPlace;
                    archetypeStats[archetype].new_best = Math.min(archetypeStats[archetype].new_best, best);
                    
                    if (archetypeStats[archetype].new_best === 999) {
                        archetypeStats[archetype].new_best = 1;
                    }
                });

                cityLeagueData = Object.values(archetypeStats).sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count));
                console.log('Generated City League data from fallback - Entries:', cityLeagueData.length);
                renderCityLeagueTable();
            } catch (error) {
                console.error('Error generating City League data:', error);
            }
        }

        // Fallback: Generate Limitless data from cardsData
        function generateMatchupsDataFallback() {
            try {
                matchupsData = [];
                const deckStats = {};

                cardsData.forEach((card, idx) => {
                    const deckName = card.archetype || `Deck ${idx + 1}`;
                    if (!deckStats[deckName]) {
                        deckStats[deckName] = {
                            rank: 0,
                            deck_name: deckName,
                            count: 0,
                            share: '0%',
                            share_numeric: 0,
                            wins: 0,
                            losses: 0,
                            ties: 0,
                            win_rate: '0%',
                            win_rate_numeric: 0
                        };
                    }
                    const count = parseInt(card.total_count || '0', 10) || 0;
                    deckStats[deckName].count = Math.max(deckStats[deckName].count, count);
                });

                // Calculate total for percentage
                const totalCount = Object.values(deckStats).reduce((sum, d) => sum + d.count, 0);
                
                // Build final array and sort
                matchupsData = Object.values(deckStats).map((d, idx) => ({
                    ...d,
                    rank: idx + 1,
                    share: totalCount > 0 ? ((d.count / totalCount) * 100).toFixed(2) + '%' : '0%',
                    share_numeric: totalCount > 0 ? ((d.count / totalCount) * 100).toFixed(2) : 0,
                    wins: Math.floor(d.count * 0.5),
                    losses: Math.floor(d.count * 0.45),
                    ties: Math.floor(d.count * 0.05),
                    win_rate: '50%',
                    win_rate_numeric: 50
                })).sort((a, b) => b.count - a.count);

                // Recalculate ranks after sort
                matchupsData.forEach((d, idx) => {
                    d.rank = idx + 1;
                });

                console.log('Generated Limitless data from fallback - Entries:', matchupsData.length);
                renderLimitlessTable();
            } catch (error) {
                console.error('Error generating matchups data:', error);
            }
        }
        
        function loadCardImageWithProxy(imgElement, originalUrl, cardName, count) {
            // Try adding _R_ to the URL if not present
            let urlWithR = originalUrl;
            if (originalUrl && !originalUrl.includes('_R_')) {
                // Insert _R_ before the extension
                urlWithR = originalUrl.replace(/\.([^.]+)$/, '_R_.$1');
            }
            
            // If direct load fails, try alternative image services
            const proxies = [
                // Try with _R_ suffix
                urlWithR,
                // Try weserv.nl proxy
                `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`,
                // Try another proxy service  
                `https://via.placeholder.com/200x280?text=${encodeURIComponent(cardName)}`
            ];
            
            let proxyIndex = 0;
            
            function tryNextProxy() {
                if (proxyIndex >= proxies.length) {
                    // All proxies failed, show fallback
                    imgElement.parentElement.classList.add('no-image');
                    imgElement.parentElement.innerHTML = `
                        <div class='fallback-content'>
                            <div class='fallback-icon'>üÉè</div>
                            <div>${cardName}</div>
                            <div class='card-count-badge'>${count}</div>
                        </div>
                    `;
                    return;
                }
                
                const currentUrl = proxies[proxyIndex];
                proxyIndex++;
                
                imgElement.src = currentUrl;
                imgElement.onerror = () => {
                    tryNextProxy();
                };
            }
            
            tryNextProxy();
        }
        
        function parseCSV(text) {
            const lines = text.split('\n');
            if (lines.length === 0) return [];
            
            // Handle BOM if present
            let headerLine = lines[0];
            if (headerLine.charCodeAt(0) === 0xFEFF) {
                headerLine = headerLine.substr(1);
            }
            
            const headers = headerLine.split(';').map(h => {
                return h.trim().replace(/\r$/, '');
            });
            const data = [];
            
            console.log('CSV Headers:', headers); // Debug
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = lines[i].split(';');
                const row = {};
                headers.forEach((header, index) => {
                    const value = values[index] ? values[index].trim().replace(/\r$/, '') : '';
                    row[header] = value;
                });
                data.push(row);
            }
            
            console.log('Parsed', data.length, 'rows'); // Debug
            return data;
        }
        
        function populateDeckDropdown() {
            const deckSelect = document.getElementById('deckSelect');
            const currentSelection = deckSelect.value; // Remember current selection
            deckSelect.innerHTML = '<option value="">-- Bitte Deck w√§hlen --</option>';
            
            // CRITICAL: Normalize City League archetypes to match cardsData format
            const normalize = (str) => str.toLowerCase().trim();
            const cityLeagueArchetypesRaw = [...new Set(cityLeagueData.map(c => c.archetype).filter(Boolean))];
            
            // Create a mapping from normalized names to actual cardsData names
            const cardDataArchetypes = [...new Set(cardsData.map(c => c.archetype).filter(Boolean))];
            const normalizedToActual = {};
            cardDataArchetypes.forEach(arch => {
                normalizedToActual[normalize(arch)] = arch;
            });
            
            // Map city league archetypes to their actual cardsData counterparts
            const cityLeagueArchetypes = cityLeagueArchetypesRaw
                .map(arch => normalizedToActual[normalize(arch)] || arch)
                .filter(arch => cardDataArchetypes.includes(arch)); // Only include if in cardsData
            
            let allArchetypes = [...new Set(cardsData.map(c => c.archetype))];
            const selectedMeta = getSelectedMetaMainOptions();

            // If City Leagues is selected, base list on City League archetypes
            if (selectedMeta.has('city_leagues')) {
                console.log('City Leagues filter active. cityLeagueArchetypes:', cityLeagueArchetypes.length);
                allArchetypes = cityLeagueArchetypes;
            }
            
            // FILTER archetypes based on selected meta
            if (selectedMeta.size > 0 && !selectedMeta.has('all')) {
                allArchetypes = allArchetypes.filter(arch => archetypeMatchesSelectedMeta(arch, selectedMeta));
            }
            
            console.log('Filtered archetypes:', allArchetypes.length, 'Selected meta:', Array.from(selectedMeta));

            // Helper to match archetype names
            const findMatchingArchetype = (deckName) => {
                const normalized = normalize(deckName);
                
                // Exact match (case-insensitive)
                const exact = allArchetypes.find(arch => normalize(arch) === normalized);
                if (exact) {
                    console.log(`‚úì Exact match: "${deckName}" ‚Üí "${exact}"`);
                    return exact;
                }
                
                // Word-based matching: check if all significant words in deckName appear in archetype
                const deckWords = normalized.split(/\s+/).filter(w => w.length > 2);
                const match = allArchetypes.find(arch => {
                    const archWords = normalize(arch).split(/\s+/).filter(w => w.length > 2);
                    return deckWords.every(word => archWords.some(aword => aword.includes(word) || word.includes(aword)));
                });
                if (match) {
                    console.log(`‚úì Word match: "${deckName}" ‚Üí "${match}"`);
                    return match;
                }
                
                // Substring match (either direction)
                const partial = allArchetypes.find(arch => 
                    normalize(arch).includes(normalized) || normalized.includes(normalize(arch))
                );
                if (partial) {
                    console.log(`‚úì Substring match: "${deckName}" ‚Üí "${partial}"`);
                    return partial;
                }
                
                console.log(`‚úó No match found for: "${deckName}" - will use as-is`);
                return deckName; // Return the deck name as-is if no match found
            };

            // Dynamically fetch and parse Top 20 Limitless and Top 10 City League from HTML reports
            Promise.all([
                fetch(BASE_PATH + 'data/limitless_online_decks_comparison.html').then(r => r.text()).catch(() => ''),
                fetch(BASE_PATH + 'data/city_league_archetypes_comparison.html').then(r => r.text()).catch(() => '')
            ]).then(([limitlessHtml, cityHtml]) => {
                console.log('Fetched HTML files successfully');
                
                // Parse Top 20 Limitless from "Full Comparison Table"
                const limitlessDoc = new DOMParser().parseFromString(limitlessHtml, 'text/html');
                let top20Limitless = [];
                const limitlessHeadings = limitlessDoc.querySelectorAll('h2');
                for (const heading of limitlessHeadings) {
                    if (heading.textContent.includes('Full Comparison')) {
                        let table = heading.nextElementSibling;
                        while (table && table.tagName !== 'TABLE') {
                            table = table.nextElementSibling;
                        }
                        if (table) {
                            const rows = Array.from(table.querySelectorAll('tbody tr, tr'));
                            for (const row of rows) {
                                if (top20Limitless.length >= 20) break;
                                const cells = row.querySelectorAll('td');
                                if (cells.length > 0) {
                                    const strong = cells[0].querySelector('strong');
                                    const deckName = strong ? strong.textContent.trim() : cells[0].textContent.trim();
                                    if (deckName) top20Limitless.push(deckName);
                                }
                            }
                        }
                        break;
                    }
                }
                console.log('Top 20 Limitless parsed:', top20Limitless.length, top20Limitless.slice(0, 5));

                // Initialize limitlessDeckStats with rankings based on Top 20 position
                limitlessDeckStats = {};
                top20Limitless.forEach((deckName, index) => {
                    limitlessDeckStats[deckName] = {
                        rank: (index + 1).toString(),
                        wr: null,
                        matchup: null
                    };
                });
                console.log('[TOP 20] Assigned rankings to', Object.keys(limitlessDeckStats).length, 'decks based on Top 20 order');

                // Parse Limitless Deck Stats (WR and Matchup data from h3 headers) - MERGE with existing rankings
                const h3Elements = limitlessDoc.querySelectorAll('h3');
                for (const h3 of h3Elements) {
                    const fullText = h3.textContent;
                    // Extract: "Deckname (Total WR: 51.2%, Vs Top20: 11:8)"
                    const match = fullText.match(/^(.*?)\s*\((Total WR: ([\d.]+%),\s*Vs Top20: (\d+:\d+))\)/);
                    if (match) {
                        const deckName = match[1].trim();
                        const wr = match[3];
                        const matchup = match[4];
                        
                        // Merge with existing entry (preserves ranking if it exists)
                        if (limitlessDeckStats[deckName]) {
                            limitlessDeckStats[deckName].wr = wr;
                            limitlessDeckStats[deckName].matchup = matchup;
                        } else {
                            // Create new entry if deck not in rankings table
                            limitlessDeckStats[deckName] = { wr, matchup, rank: null };
                        }
                    }
                }

                console.log('[H3 STATS] Parsed WR/Matchup data for', Object.entries(limitlessDeckStats).filter(([k,v]) => v.wr).length, 'decks');
                console.log('[STATS] Total decks with rankings:', Object.entries(limitlessDeckStats).filter(([k,v]) => v.rank).length);

                if (matchupDetailsData && matchupDetailsData.length > 0) {
                    limitlessMatchupData = buildLimitlessMatchupData(matchupDetailsData);
                    console.log('[INFO] Matchup data synced from CSV:', Object.keys(limitlessMatchupData).length);
                }

                // Parse Top 10 City League from "Full Comparison Table"
                const cityDoc = new DOMParser().parseFromString(cityHtml, 'text/html');
                let top10City = [];
                const cityHeadings = cityDoc.querySelectorAll('h2');
                for (const heading of cityHeadings) {
                    if (heading.textContent.includes('Full Comparison')) {
                        let table = heading.nextElementSibling;
                        while (table && table.tagName !== 'TABLE') {
                            table = table.nextElementSibling;
                        }
                        if (table) {
                            const rows = Array.from(table.querySelectorAll('tbody tr, tr'));
                            for (const row of rows) {
                                if (top10City.length >= 10) break;
                                const cells = row.querySelectorAll('td');
                                if (cells.length > 0) {
                                    const strong = cells[0].querySelector('strong');
                                    const deckName = strong ? strong.textContent.trim() : cells[0].textContent.trim();
                                    if (deckName) top10City.push(deckName);
                                }
                            }
                        }
                        break;
                    }
                }
                console.log('Top 10 City League parsed:', top10City.length, top10City.slice(0, 5));

                // Debug: Show available archetypes and parsed decknames
                console.log('Available archetypes in cardsData:', allArchetypes.slice(0, 10));
                console.log('All parsed Limitless decks:', top20Limitless);
                console.log('All parsed City League decks:', top10City);

                // Map to archetypes in cardsData
                const top20WithArchetypes = top20Limitless.map(findMatchingArchetype).filter(Boolean);
                const top10WithArchetypes = top10City.map(findMatchingArchetype).filter(Boolean);

                const allowedArchetypes = new Set(allArchetypes.map(a => normalize(a)));
                const top20Display = selectedMeta.size > 0
                    ? top20WithArchetypes.filter(a => allowedArchetypes.has(normalize(a)))
                    : top20WithArchetypes;
                const top10Display = selectedMeta.size > 0
                    ? top10WithArchetypes.filter(a => allowedArchetypes.has(normalize(a)))
                    : top10WithArchetypes;
                
                // Store globally for use in updateCardsDisplay
                top20LimitlessArchetypes = top20WithArchetypes;
                top10CityLeagueArchetypes = top10WithArchetypes;
                
                console.log('Matched Top 20:', top20WithArchetypes.length, 'Matched Top 10:', top10WithArchetypes.length);
                
                const used = new Set([...top20Display, ...top10Display].map(a => normalize(a)));
                const remainingArchetypes = allArchetypes
                    .filter(arch => arch.trim() && !used.has(normalize(arch)))
                    .sort((a, b) => a.localeCompare(b, 'de-DE'));

                // Add Top 20 Limitless
                if (top20Display.length > 0) {
                    const group1 = document.createElement('optgroup');
                    group1.label = 'üèÜ Top 20 Limitless';
                    top20Display.forEach(archetype => {
                        const option = document.createElement('option');
                        option.value = archetype;
                        option.textContent = archetype;
                        group1.appendChild(option);
                    });
                    deckSelect.appendChild(group1);
                }
                // Add Top 10 City League
                if (top10Display.length > 0) {
                    const group2 = document.createElement('optgroup');
                    group2.label = 'üáØüáµ Top 10 Japan City League';
                    top10Display.forEach(archetype => {
                        const option = document.createElement('option');
                        option.value = archetype;
                        option.textContent = archetype;
                        group2.appendChild(option);
                    });
                    deckSelect.appendChild(group2);
                }
                // Add remaining archetypes alphabetically
                const group3 = document.createElement('optgroup');
                group3.label = 'üìã Weitere Decks (alphabetisch)';
                if (remainingArchetypes.length > 0) {
                    remainingArchetypes.forEach(archetype => {
                        const option = document.createElement('option');
                        option.value = archetype;
                        option.textContent = archetype;
                        group3.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'Keine weiteren Decks';
                    option.disabled = true;
                    group3.appendChild(option);
                }
                deckSelect.appendChild(group3);
            }).catch(err => {
                console.error('Error loading meta reports:', err);
                // Fallback: show all alphabetically
                const group3 = document.createElement('optgroup');
                group3.label = 'üìã Alle Decks (alphabetisch)';
                allArchetypes.filter(a => a.trim()).sort((a, b) => a.localeCompare(b, 'de-DE')).forEach(archetype => {
                    const option = document.createElement('option');
                    option.value = archetype;
                    option.textContent = archetype;
                    group3.appendChild(option);
                });
                deckSelect.appendChild(group3);
            });
        }
        
        function setupEventListeners() {
            document.getElementById('deckSelect').addEventListener('change', onDeckChange);
            document.getElementById('filterSelect').addEventListener('change', updateCardsDisplay);
            document.getElementById('deckSearch').addEventListener('input', filterDeckList);
            const setFilter = document.getElementById('setFilterSelect');
            if (setFilter) {
                setFilter.addEventListener('change', applyCardFilters);
            }
            // cardSearchInput uses oninput="applyCardFilters()" so no need for addEventListener
            
            // Event delegation for card image clicks
            document.addEventListener('click', (e) => {
                const cardElement = e.target.closest('.card-visual, .compact-card, .card-thumbnail, [data-image-url]');
                if (cardElement && cardElement.dataset.imageUrl && cardElement.dataset.cardName) {
                    e.preventDefault();
                    showCardImage(cardElement.dataset.imageUrl, cardElement.dataset.cardName);
                    return;
                }
                
                // Handle add to deck button
                if (e.target.classList.contains('btn-add')) {
                    e.preventDefault();
                    const btn = e.target;
                    const identifier = btn.dataset.identifier;
                    const maxCount = parseInt(btn.dataset.maxCount) || 4;
                    const cardName = btn.dataset.cardName;
                    const imageUrl = btn.dataset.imageUrl || '';
                    const setCode = btn.dataset.setCode || '';
                    const setNumber = btn.dataset.setNumber || '';
                    addToDeck(identifier, maxCount, cardName, imageUrl, setCode, setNumber);
                    return;
                }
                
                // Handle remove from deck button
                if (e.target.classList.contains('btn-remove')) {
                    e.preventDefault();
                    const cardName = e.target.dataset.cardName;
                    removeFromDeck(cardName);
                    return;
                }
            });
        }

        function initializeCardFilterUI() {
            populateSetFilterOptions();
            renderCardTypeFilters();
            applyCardFilters();
        }

        function populateSetFilterOptions() {
            const setSelect = document.getElementById('setFilterSelect');
            if (!setSelect) return;

            // Set release dates (newest to oldest)
            const setReleaseDates = {
                'ASC': new Date('2026-01-30').getTime(),
                'PFL': new Date('2025-11-14').getTime(),
                'MEG': new Date('2025-09-26').getTime(),
                'MEE': new Date('2025-09-25').getTime(),
                'MEP': new Date('2025-09-24').getTime(), // Estimated
                'BLK': new Date('2025-07-18').getTime(),
                'WHT': new Date('2025-07-18').getTime(),
                'DRI': new Date('2025-05-30').getTime(),
                'JTG': new Date('2025-03-28').getTime(),
                'PRE': new Date('2025-01-17').getTime(),
                'SSP': new Date('2024-11-08').getTime(),
                'SCR': new Date('2024-09-13').getTime(),
                'SFA': new Date('2024-08-02').getTime(),
                'TWM': new Date('2024-05-24').getTime(),
                'TEF': new Date('2024-03-22').getTime(),
                'PAF': new Date('2024-01-26').getTime(),
                'PAR': new Date('2023-11-03').getTime(),
                'MEW': new Date('2023-09-22').getTime(),
                'OBF': new Date('2023-08-11').getTime(),
                'PAL': new Date('2023-06-09').getTime(),
                'SVI': new Date('2023-03-31').getTime(),
                'SVE': new Date('2023-03-30').getTime(),
                'SVP': new Date('2023-03-30').getTime(), // Promos
                'CRZ': new Date('2023-01-20').getTime(),
                'SIT': new Date('2022-11-11').getTime(),
                'LOR': new Date('2022-09-09').getTime(),
                'PGO': new Date('2022-07-01').getTime(),
                'ASR': new Date('2022-05-27').getTime(),
                'BRS': new Date('2022-02-25').getTime(),
                'FST': new Date('2021-11-12').getTime(),
                'CEL': new Date('2021-10-08').getTime(),
                'EVS': new Date('2021-08-27').getTime(),
                'CRE': new Date('2021-06-18').getTime(),
                'BST': new Date('2021-03-19').getTime(),
                'SHF': new Date('2021-02-19').getTime(),
                'VIV': new Date('2020-11-13').getTime(),
                'CPA': new Date('2020-09-25').getTime(),
                'DAA': new Date('2020-08-14').getTime(),
                'RCL': new Date('2020-05-01').getTime(),
                'SSH': new Date('2020-02-07').getTime(),
                'SP': new Date('2020-02-01').getTime()   // Promos
            };

            const sets = [...new Set(cardsData.map(c => (c.set_code || '').trim()).filter(Boolean))]
                .sort((a, b) => {
                    const dateA = setReleaseDates[a] || 0;
                    const dateB = setReleaseDates[b] || 0;
                    return dateB - dateA; // Newest first
                });

            sets.forEach(setCode => {
                const option = document.createElement('option');
                option.value = setCode;
                option.textContent = setCode;
                setSelect.appendChild(option);
            });
        }

        function renderCardTypeFilters() {
            const container = document.getElementById('cardTypeFiltersContainer');
            if (!container) return;

            container.innerHTML = '';

            const button = document.createElement('button');
            button.className = 'dropdown-button';
            button.type = 'button';
            button.innerHTML = 'Alle' + '<span style="margin-left: auto;">‚ñº</span>';

            const menu = document.createElement('div');
            menu.className = 'dropdown-menu';

            const cardTypes = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];

            cardTypes.forEach(type => {
                const label = document.createElement('label');
                label.style.margin = '0';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = type;
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    updateTypeFilterButton();
                    applyCardFilters();
                });

                const span = document.createElement('span');
                span.textContent = type;

                label.appendChild(checkbox);
                label.appendChild(span);
                menu.appendChild(label);
            });

            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = button.classList.toggle('open');
                menu.classList.toggle('open', isOpen);
            });

            container.appendChild(button);
            container.appendChild(menu);

            document.addEventListener('click', () => {
                button.classList.remove('open');
                menu.classList.remove('open');
            });

            updateTypeFilterButton();
        }

        function updateTypeFilterButton() {
            const button = document.querySelector('.dropdown-button');
            if (!button) return;

            const selected = getSelectedCardTypes();
            const cardTypes = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
            const allSelected = cardTypes.every(t => selected.has(t));

            if (allSelected) {
                button.innerHTML = 'Alle' + '<span style="margin-left: auto;">‚ñº</span>';
            } else if (selected.size === 0) {
                button.innerHTML = 'Keine' + '<span style="margin-left: auto;">‚ñº</span>';
            } else {
                button.innerHTML = `${selected.size} ausgew√§hlt` + '<span style="margin-left: auto;">‚ñº</span>';
            }
        }

        function getSelectedCardTypes() {
            const container = document.getElementById('cardTypeFiltersContainer');
            if (!container) return new Set();

            const selected = new Set();
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (cb.checked) selected.add(cb.value);
            });
            return selected;
        }

        function handleCardSearchInput() {
            const searchInput = document.getElementById('cardSearchInput');
            const suggestionsDiv = document.getElementById('cardSearchSuggestions');
            const searchTerm = (searchInput.value || '').toLowerCase().trim();
            
            // Leere Eingabe = keine Vorschl√§ge
            if (searchTerm.length === 0) {
                suggestionsDiv.style.display = 'none';
                applyCardFilters(); // Zeige alle Karten
                return;
            }
            
            // Sammle alle eindeutigen Kartennamen aus cardsData
            const uniqueCardNames = new Set();
            if (cardsData && cardsData.length > 0) {
                cardsData.forEach(card => {
                    const cardName = card.name || card.card_name || '';
                    if (cardName) uniqueCardNames.add(cardName);
                });
            }
            
            // Filtere Vorschl√§ge: Kartennamen die den Suchbegriff enthalten
            const suggestions = Array.from(uniqueCardNames)
                .filter(name => name.toLowerCase().includes(searchTerm))
                .sort()
                .slice(0, 15); // Max 15 Vorschl√§ge
            
            // Zeige/verstecke Dropdown
            if (suggestions.length === 0) {
                suggestionsDiv.style.display = 'none';
            } else {
                suggestionsDiv.style.display = 'block';
                suggestionsDiv.innerHTML = suggestions.map(name => {
                    // Finde das Kartenbild f√ºr die Vorschau
                    const cardData = cardsData.find(c => (c.name || c.card_name) === name);
                    const imageUrl = cardData ? (cardData.image_url || cardData.imageUrl || '') : '';
                    
                    return `<div class="search-suggestion" style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; gap: 10px; align-items: center; transition: background 0.2s;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background='transparent'" onclick="selectCardSuggestion('${name.replace(/'/g, "\\'")}')">
                        ${imageUrl ? `<img src="${imageUrl}" style="width: 40px; height: 56px; border-radius: 4px; object-fit: cover;">` : ''}
                        <span style="flex: 1; font-size: 14px;">${name}</span>
                    </div>`;
                }).join('');
            }
            
            // Wende auch aktuell die Filter an w√§hrend man tippt
            applyCardFilters();
        }
        
        function selectCardSuggestion(cardName) {
            const searchInput = document.getElementById('cardSearchInput');
            searchInput.value = cardName;
            document.getElementById('cardSearchSuggestions').style.display = 'none';
            applyCardFilters();
        }

        function applyCardFilters() {
            const setFilter = document.getElementById('setFilterSelect');
            const selectedSet = setFilter ? setFilter.value : '';
            const searchInput = document.getElementById('cardSearchInput');
            const searchTerm = (searchInput ? searchInput.value : '').toLowerCase().trim();
            const selectedTypes = getSelectedCardTypes();
            
            console.log('applyCardFilters called:');
            console.log('  searchTerm:', searchTerm);
            console.log('  selectedSet:', selectedSet);
            console.log('  cardsData length:', cardsData.length);

            // Main filter with cardsData - ALSO apply search term
            const cardMap = new Map();

            cardsData.forEach(card => {
                const setCode = (card.set_code || '').trim();
                const cardNumber = (card.set_number || '').trim();
                const cardName = (card.card_name || '').trim();
                const cardNameLower = cardName.toLowerCase();
                
                if (!cardName) return;

                // Filter by set
                if (selectedSet && setCode !== selectedSet) return;

                // APPLY SEARCH TERM FILTER - normalize for special characters
                if (searchTerm) {
                    const normalizedName = cardNameLower
                        .replace(/['']/g, "'")
                        .replace(/\s+/g, ' ')
                        .trim();
                    const normalizedSearch = searchTerm
                        .replace(/['']/g, "'")
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (!normalizedName.includes(normalizedSearch)) {
                        return;
                    }
                }

                // Use the actual type from CSV for filtering
                const csvType = card.type || '';
                const cardType = getCardTypeFromCsvType(csvType);
                
                // Filter by selected types
                if (selectedTypes.size > 0 && !selectedTypes.has(cardType)) return;

                const key = `${cardNameLower}|${setCode}|${cardNumber}`;
                const totalCount = parseInt(card.total_count || '0', 10) || 0;
                const maxCount = parseInt(card.max_count || '0', 10) || 0;

                if (!cardMap.has(key)) {
                    cardMap.set(key, {
                        card_name: cardName,
                        set_code: setCode,
                        set_number: cardNumber,
                        card_type: cardType,
                        type: csvType,
                        total_count: totalCount,
                        max_count: maxCount,
                        image_url: card.image_url || '',
                        percentage_in_archetype: card.percentage_in_archetype || '0'
                    });
                } else {
                    const existing = cardMap.get(key);
                    existing.total_count += totalCount;
                    existing.max_count = Math.max(existing.max_count, maxCount);
                }
            });

            filteredCards = Array.from(cardMap.values());
            console.log('applyCardFilters - Main filter shows:', filteredCards.length, 'cards');
            
            // Sort by card type first
            filteredCards = sortCardsByType(filteredCards);
            
            renderFilteredCards();

            // If search term exists, ALSO show search results section with all versions below
            if (searchTerm) {
                showSearchResults(searchTerm, selectedSet, selectedTypes);
            } else {
                // Hide artwork section if no search term
                const artworkSection = document.getElementById('cardArtworkSection');
                if (artworkSection) {
                    artworkSection.style.display = 'none';
                }
            }
        }

        function showSearchResults(searchTerm, selectedSet, selectedTypes) {
            // Use allCardsDatabase for searching all versions
            const sourceData = allCardsDatabase.length > 0 ? allCardsDatabase : cardsData;
            const cardMap = new Map();

            sourceData.forEach(card => {
                const setCode = (card.set || card.set_code || '').trim();
                const cardNumber = (card.number || card.set_number || '').trim();
                const cardName = (card.name || card.card_name || '').trim();
                const cardNameLower = cardName.toLowerCase();
                
                if (!cardName) return;

                // Filter by set
                if (selectedSet && setCode !== selectedSet) return;
                
                // Filter by search term - handle special characters like apostrophes
                if (searchTerm) {
                    // Normalize both strings for comparison
                    const normalizedName = cardNameLower
                        .replace(/['']/g, "'")  // Normalize apostrophes
                        .replace(/\s+/g, ' ')  // Normalize spaces
                        .trim();
                    const normalizedSearch = searchTerm
                        .replace(/['']/g, "'")
                        .replace(/\s+/g, ' ')
                        .trim();
                    
                    if (!normalizedName.includes(normalizedSearch)) {
                        return;
                    }
                }

                // Use rarity from allCardsDatabase if available
                const rarity = card.rarity || '';
                const csvType = card.type || '';
                const cardType = getCardTypeFromCsvType(csvType);
                
                // Filter by selected types
                if (selectedTypes.size > 0 && !selectedTypes.has(cardType)) return;

                // Use set+number as unique key to keep flat table structure
                const key = `${cardNameLower}|${setCode}|${cardNumber}`;
                const totalCount = parseInt(card.total_count || '0', 10) || 0;
                const maxCount = parseInt(card.max_count || '0', 10) || 0;

                if (!cardMap.has(key)) {
                    cardMap.set(key, {
                        card_name: cardName,
                        card_name_lower: cardNameLower,
                        set_code: setCode,
                        set_number: cardNumber,
                        card_type: cardType,
                        type: csvType,
                        total_count: totalCount,
                        max_count: maxCount,
                        image_url: card.image_url || '',
                        rarity: rarity
                    });
                } else {
                    const existing = cardMap.get(key);
                    existing.total_count += totalCount;
                    existing.max_count = Math.max(existing.max_count, maxCount);
                }
            });

            const searchResults = Array.from(cardMap.values());
            console.log('‚úÖ showSearchResults - Found', searchResults.length, 'cards matching "' + searchTerm + '"');
            
            // Render search results to artwork section
            renderSearchResults(searchResults);
        }
        
        function renderSearchResults(results) {
            // If there's only one unique card name, show artwork section
            const uniqueNames = new Set(results.map(c => c.card_name.toLowerCase()));
            if (uniqueNames.size === 1) {
                // Show artwork section with all versions
                showCardArtworks(results[0].card_name, results);
            } else {
                document.getElementById('cardArtworkSection').style.display = 'none';
            }
        }
        
        function getCardTypeFromCsvType(csvType) {
            /**
             * Convert CSV type field to our card type categories
             * CSV types are like: "GBasic", "RStage1", "Supporter", "Item", etc.
             */
            if (!csvType) return 'Pokemon';
            
            // Direct matches for non-Pokemon types
            if (csvType === 'Supporter') return 'Supporter';
            if (csvType === 'Stadium') return 'Stadium';
            if (csvType === 'Item') return 'Item';
            if (csvType === 'Tool') return 'Tool';
            
            // Energy types
            if (csvType.includes('Special Energy')) return 'Special Energy';
            if (csvType === 'Energy') return 'Energy';
            
            // If it contains element letter + evolution stage, it's a Pokemon
            if (csvType.match(/^[GRWLPFDMNC](Basic|Stage\s*1|Stage\s*2|V|VMAX|EX|V-UNION)/)) {
                return 'Pokemon';
            }
            
            // Default to Pokemon for types like "GBasic", "RStage1", etc.
            if (csvType.match(/^[GRWLPFDMNC]/)) {
                return 'Pokemon';
            }
            
            return 'Pokemon';
        }



        function clearCardFilters() {
            const setSelect = document.getElementById('setFilterSelect');
            if (setSelect) setSelect.value = '';
            
            const searchInput = document.getElementById('cardSearchInput');
            if (searchInput) searchInput.value = '';

            const container = document.getElementById('cardTypeFiltersContainer');
            if (container) {
                const checkboxes = container.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = true;
                });
            }

            updateTypeFilterButton();
            applyCardFilters();
        }

        function renderFilteredCards() {
            const tbody = document.getElementById('filteredCardsBody');
            const countEl = document.getElementById('filteredCardCount');
            const countSummaryEl = document.getElementById('filteredCardCountSummary');

            if (!tbody || !countEl) return;

            const filteredCardTotal = filteredCards.reduce((sum, card) => sum + (parseInt(card.max_count) || 1), 0);
            countEl.textContent = `${filteredCards.length} Karten`;
            if (countSummaryEl) {
                countSummaryEl.textContent = `/ ${filteredCardTotal} Total`;
            }
            tbody.innerHTML = '';

            if (filteredCards.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="6" class="loading">Keine Karten gefunden.</td>`;
                tbody.appendChild(row);
                document.getElementById('cardArtworkSection').style.display = 'none';
                return;
            }

            // Sort cards using the standard sorting function
            const sortedCards = sortCardsByType([...filteredCards]);

            // Check if all filtered cards have the same name (for artwork display)
            const uniqueNames = new Set(filteredCards.map(c => c.card_name.toLowerCase()));
            if (uniqueNames.size === 1) {
                // All cards are the same - show artwork section
                showCardArtworks(filteredCards[0].card_name, filteredCards);
            } else {
                document.getElementById('cardArtworkSection').style.display = 'none';
            }

            sortedCards.forEach(card => {
                const row = document.createElement('tr');

                const imgCell = document.createElement('td');
                if (card.image_url) {
                    const img = document.createElement('img');
                    img.className = 'card-thumbnail';
                    img.src = card.image_url;
                    img.alt = card.card_name;
                    img.onerror = () => loadCardImageWithProxy(img, card.image_url, card.card_name, 1);
                    imgCell.appendChild(img);
                } else {
                    imgCell.innerHTML = `<div class="card-thumbnail-placeholder">üÉè</div>`;
                }

                const nameCell = document.createElement('td');
                nameCell.textContent = card.card_name;

                const setCell = document.createElement('td');
                setCell.textContent = card.set_code;

                const numberCell = document.createElement('td');
                numberCell.textContent = card.set_number;

                const typeCell = document.createElement('td');
                typeCell.textContent = card.card_type;

                const totalCell = document.createElement('td');
                totalCell.textContent = card.max_count;

                row.appendChild(imgCell);
                row.appendChild(nameCell);
                row.appendChild(setCell);
                row.appendChild(numberCell);
                row.appendChild(typeCell);
                row.appendChild(totalCell);

                tbody.appendChild(row);
            });
        }
        
        // Store all card versions for artwork filtering
        let currentCardArtworks = [];
        let currentRarityFilter = 'all';
        
        function showCardArtworks(cardName, versions) {
            const artworkSection = document.getElementById('cardArtworkSection');
            
            // Find all versions from allCardsDatabase (all versions), fallback to cardsData
            const sourceData = allCardsDatabase.length > 0 ? allCardsDatabase : cardsData;
            const allVersions = sourceData.filter(c => {
                const cardDbName = (c.name || c.card_name || '').trim();
                return cardDbName.toLowerCase() === cardName.toLowerCase();
            });
            
            currentCardArtworks = allVersions;
            console.log('üé® showCardArtworks -', cardName, '- Found', allVersions.length, 'versions');
            
            if (allVersions.length === 0) {
                artworkSection.style.display = 'none';
                return;
            }
            
            artworkSection.style.display = 'block';
            
            // Reset rarity filter and display all artworks
            currentRarityFilter = 'all';
            updateRarityButtons();
            displayCardArtworks();
        }
        
        function displayCardArtworks() {
            const artworkGrid = document.getElementById('artworkGrid');
            artworkGrid.innerHTML = '';
            
            // Filter by rarity if needed
            let toDisplay = currentCardArtworks;
            if (currentRarityFilter !== 'all') {
                toDisplay = currentCardArtworks.filter(card => 
                    getRarityCategory(card.rarity) === currentRarityFilter
                );
            }
            
            // Remove duplicates by set+number and filter out Japanese cards
            const uniqueByVersion = new Map();
            // English set codes to allow (filter out Japanese sets)
            const englishSets = new Set([
                'ASC', 'PFL', 'MEG', 'MEE', 'MEP',
                'BLK', 'WHT', 'DRI', 'JTG', 'PRE', 'SSP', 'SCR', 'SFA', 'TWM', 'TEF',
                'PAF', 'PAR', 'MEW', 'OBF', 'PAL', 'SVI', 'SVE', 'SVP',
                'CRZ', 'SIT', 'LOR', 'PGO', 'ASR', 'BRS', 'FST', 'CEL', 'EVS', 'CRE', 'BST',
                'SHF', 'VIV', 'CPA', 'DAA', 'RCL', 'SSH', 'SP'
            ]);
            
            toDisplay.forEach(card => {
                const setCode = (card.set || card.set_code || '').trim().toUpperCase();
                const setNumber = (card.number || card.set_number || '').trim();
                
                // Skip Japanese cards (check if set code is in English sets list)
                if (!englishSets.has(setCode)) {
                    console.log('Skipping Japanese card:', card.name || card.card_name, 'Set:', setCode);
                    return;
                }
                
                const key = setCode + '_' + setNumber;
                if (!uniqueByVersion.has(key)) {
                    uniqueByVersion.set(key, card);
                }
            });
            
            if (uniqueByVersion.size === 0) {
                artworkGrid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 20px; color: #999;">Keine Versionen mit dieser Rarity gefunden.</div>';
                return;
            }
            
            const buildCdnUrl = (code, number, padTo3 = false) => {
                const safeCode = (code || '').trim().toUpperCase();
                let safeNumber = (number || '').trim();
                if (padTo3 && /^\d+$/.test(safeNumber)) {
                    safeNumber = safeNumber.padStart(3, '0');
                }
                return `https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpci/${safeCode}/${safeCode}_${safeNumber}_R_EN_LG.png`;
            };

            console.log('displayCardArtworks - rendering', uniqueByVersion.size, 'cards');
            uniqueByVersion.forEach((card, index) => {
                const setCode = (card.set || card.set_code || '').trim();
                const setNumber = (card.number || card.set_number || '').trim();
                
                console.log('Card', index, '- Code:', setCode, 'Num:', setNumber, 'URL:', card.image_url);
                
                const cardDiv = document.createElement('div');
                cardDiv.style.cssText = 'display: flex; flex-direction: column; gap: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 6px; background: #f8f9fa;';
                
                // Construct image URL if not present
                let imageUrl = card.image_url;
                if (!imageUrl && setCode && setNumber) {
                    // Build Limitless CDN URL pattern: https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpci/{SET}/{SET}_{NUM}_R_EN_LG.png
                    imageUrl = buildCdnUrl(setCode, setNumber, false);
                    console.log('üîß Constructed image URL:', imageUrl);
                }
                
                const img = document.createElement('img');
                img.src = imageUrl || '';
                img.alt = card.name || card.card_name;
                img.style.cssText = 'width: 100%; border-radius: 4px; cursor: pointer;';
                img.onerror = () => {
                    if (!img.dataset.triedPad && !card.image_url && /^\d+$/.test(setNumber) && setNumber.length < 3) {
                        img.dataset.triedPad = '1';
                        const paddedUrl = buildCdnUrl(setCode, setNumber, true);
                        console.log('Retrying with padded number:', paddedUrl);
                        img.src = paddedUrl;
                        return;
                    }
                    console.warn('‚ùå Image failed to load - set:', setCode, 'num:', setNumber, 'URL:', imageUrl);
                };
                img.onclick = () => showCardImage(imageUrl, card.name || card.card_name);
                
                const info = document.createElement('div');
                info.style.cssText = 'font-size: 0.85em;';
                const rarityLabel = getRarityLabel(card.rarity);
                
                info.style.textAlign = 'center';
                
                // Create info container
                const infoContainer = document.createElement('div');
                infoContainer.style.marginBottom = '6px';
                infoContainer.innerHTML = `<strong>${setCode}</strong><br>#${setNumber}`;
                info.appendChild(infoContainer);
                
                // Determine rarity version (1=Low, 2=Mid, 3=High)
                const rarityCategory = getRarityCategory(card.rarity);
                let version = '1';  // Default to Low
                if (rarityCategory === 'mid') version = '2';
                else if (rarityCategory === 'high') version = '3';
                
                // Get CardMarket price and URL using SET/NUMBER/VERSION key
                const priceKey = setCode.toUpperCase() + '/' + setNumber + '/' + version;
                const priceData = cardmarketPrices.get(priceKey);
                
                // Debug log (show first 3 cards only)
                if (index < 3) {
                    console.log('Price lookup -', priceKey, '- Found:', !!priceData, '- Rarity:', card.rarity, '- Category:', rarityCategory);
                    if (priceData) console.log('  Price data:', priceData);
                }
                
                // Create CardMarket link if available
                if (priceData && priceData.url) {
                    const link = document.createElement('a');
                    link.href = priceData.url;  // Set href directly (safe from XSS)
                    link.target = '_blank';
                    link.style.cssText = 'text-decoration: none; cursor: pointer; display: block; margin-top: 4px;';
                    
                    // For Low Rarity (V1): Always show link only (no price)
                    // For Mid/High (V2/V3): Show price if available, else link
                    if (version === '1') {
                        // Low Rarity: Link only
                        link.innerHTML = 'üîç CardMarket';
                        link.style.color = '#3498db';
                        link.style.fontSize = '0.9em';
                    } else {
                        // Mid/High Rarity: Show price if scraped, else link
                        if (priceData.price) {
                            link.innerHTML = `üí∞ ‚Ç¨${priceData.price}`;
                            link.style.color = '#27ae60';
                            link.style.fontWeight = 'bold';
                            link.style.fontSize = '1.1em';
                        } else {
                            link.innerHTML = 'üîç CardMarket';
                            link.style.color = '#3498db';
                            link.style.fontSize = '0.9em';
                        }
                    }
                    
                    // Debug: log the actual link
                    if (index < 3) {
                        console.log('Created link for', priceKey, '- href:', link.href, '- version:', version, '- has price:', !!priceData.price);
                    }
                    
                    info.appendChild(link);
                }
                
                cardDiv.appendChild(img);
                cardDiv.appendChild(info);
                artworkGrid.appendChild(cardDiv);
            });
        }
        
        function filterCardArtworks(rarityFilter) {
            currentRarityFilter = rarityFilter;
            updateRarityButtons();
            displayCardArtworks();
        }
        
        function updateRarityButtons() {
            const buttons = document.querySelectorAll('#cardArtworkSection .btn-sm');
            buttons.forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                btn.style.opacity = '0.6';
            });
            
            // Highlight active button
            const activeBtn = Array.from(buttons).find(btn => {
                const onclick = btn.getAttribute('onclick');
                return onclick.includes(`'${currentRarityFilter}'`);
            });
            if (activeBtn) {
                activeBtn.classList.remove('btn-secondary');
                activeBtn.classList.add('btn-primary');
                activeBtn.style.opacity = '1';
            }
        }
        
        function getRarityCategory(rarity) {
            if (!rarity) return 'all';
            const r = rarity.toLowerCase();
            // Low Rarity: Common, Uncommon, Rare, Holo Rare
            if (r.includes('common') || r.includes('uncommon') || (r.includes('rare') && !r.includes('ultra') && !r.includes('rainbow') && !r.includes('special'))) return 'low';
            // Mid Rarity: Ultra Rare, Rainbow Rare
            if (r.includes('ultra') || r.includes('rainbow')) return 'mid';
            // High Rarity: EX, V, VMAX, VSTAR, Special Art Rare
            if (r.includes('ex') || r.includes('ex-') || r.includes(' v ') || r.includes(' v,') || r.includes('vmax') || r.includes('vstar') || r.includes('special')) return 'high';
            return 'all';
        }
        
        function getRarityLabel(rarity) {
            if (!rarity) return 'Unknown';
            const r = rarity.toLowerCase();
            // Show rarity emojis without category labels
            if (r.includes('uncommon')) return '‚óÜ Uncommon';
            if (r.includes('common')) return '‚óè Common';
            if (r.includes('holo')) return '‚ú¶ Holo Rare';
            if (r.includes('rare')) return '‚òÖ Rare';
            if (r.includes('rainbow')) return 'üåà Rainbow Rare';
            if (r.includes('ultra')) return 'üíé Ultra Rare';
            if (r.includes('special')) return 'üé® Special Art';
            if (r.includes('ex') || r.includes('ex-') || r.includes(' v ') || r.includes(' v,') || r.includes('vmax') || r.includes('vstar')) return '‚òÖ‚òÖ‚òÖ EX/V';
            return rarity;
        }

        function copyFilteredCards() {
            if (!filteredCards || filteredCards.length === 0) {
                alert('Keine Karten zum Kopieren vorhanden.');
                return;
            }

            // Sort cards using the standard sorting function
            const sortedCards = sortCardsByType([...filteredCards]);
            
            const lines = sortedCards.map(card => {
                const parts = [card.card_name, card.set_code, card.set_number].filter(Boolean);
                return parts.join(' ');
            });

            const textToCopy = lines.join('\n');

            navigator.clipboard.writeText(textToCopy).then(() => {
                alert('‚úÖ Gefilterte Karten wurden kopiert!');
            }).catch(() => {
                prompt('Kopiere die Liste:', textToCopy);
            });
        }
        
        function filterDeckList() {
            const searchTerm = document.getElementById('deckSearch').value.toLowerCase().trim();
            const deckSelect = document.getElementById('deckSelect');
            
            // If search is empty, show all decks
            if (!searchTerm) {
                populateDeckDropdown();
                return;
            }
            
            // Get all available deck names from cardsData
            const allDecks = [...new Set(cardsData.map(c => c.archetype))].filter(Boolean).sort();
            
            // Filter decks based on search term
            const filteredDecks = allDecks.filter(deck => deck.toLowerCase().includes(searchTerm));
            
            // Rebuild select with filtered options
            deckSelect.innerHTML = '<option value="">-- Bitte einen gefilterten Deck w√§hlen --</option>';
            
            if (filteredDecks.length === 0) {
                const option = document.createElement('option');
                option.value = '';
                option.textContent = '‚ùå Keine Decks gefunden';
                option.disabled = true;
                deckSelect.appendChild(option);
            } else {
                filteredDecks.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck;
                    option.textContent = deck;
                    deckSelect.appendChild(option);
                });
            }
            
            // Also filter variant options
            filterVariantOptions(searchTerm);
        }
        
        function filterVariantOptions(searchTerm) {
            const variantOptions = document.getElementById('variantOptions');
            if (!variantOptions) return;
            
            const checkboxes = variantOptions.querySelectorAll('.variant-checkbox');
            checkboxes.forEach(checkbox => {
                const label = checkbox.querySelector('span');
                const variantText = label.textContent.toLowerCase();
                if (variantText.includes(searchTerm)) {
                    checkbox.style.display = '';
                } else {
                    checkbox.style.display = 'none';
                }
            });
        }
        
        function onVariantSearchInput() {
            const searchInput = document.getElementById('variantSearchInput');
            const searchTerm = searchInput.value.toLowerCase();
            filterVariantOptions(searchTerm);
        }
        
        function onDeckChange() {
            const selectedDeck = document.getElementById('deckSelect').value;
            console.log('[onDeckChange] Called - selectedDeck:', selectedDeck);
            if (!selectedDeck) {
                console.log('[onDeckChange] No deck selected, returning');
                return;
            }
            
            // Ensure alternative deck selector exists
            createAlternativeDeckSelector();
            
            // Check if this deck has Limitless data
            const hasLimitlessData = checkIfDeckHasLimitlessData(selectedDeck);
            console.log('[onDeckChange] Has Limitless data:', hasLimitlessData, 'for:', selectedDeck);
            
            // Show/hide alternative deck selector
            showAlternativeDeckSelector(!hasLimitlessData, selectedDeck);
            
            console.log('[onDeckChange] Calling updateStats, updateVariantSelector, updateCardsDisplay');
            updateStats(selectedDeck);
            updateVariantSelector(selectedDeck);
            updateCardsDisplay();
        }
        
        function checkIfDeckHasLimitlessData(deckName) {
            // Normalize the deck name for comparison
            const normalized = normalizeArchetypeName(deckName);
            
            // Check if deck exists in limitlessMatchupData
            for (const key of Object.keys(limitlessMatchupData)) {
                if (normalizeArchetypeName(key) === normalized) {
                    return true;
                }
            }
            
            return false;
        }
        
        function findSimilarLimitlessDecks(cityLeagueDeckName) {
            /**
             * Find similar Limitless decks for a city league deck
             * E.g., "Garchomp Roserade" -> ["Cynthia's Garchomp", "...]
             */
            const normalized = normalizeArchetypeName(cityLeagueDeckName).toLowerCase();
            const keywords = normalized.split(' ').filter(k => k.length > 2);
            
            const similar = [];
            for (const limitlessDeck of matchupsData) {
                const limitlessName = normalizeArchetypeName(limitlessDeck.deck_name).toLowerCase();
                
                // Count matching keywords
                let matchCount = 0;
                keywords.forEach(keyword => {
                    if (limitlessName.includes(keyword)) {
                        matchCount++;
                    }
                });
                
                // If at least half of keywords match, consider it similar
                if (matchCount >= Math.max(1, Math.ceil(keywords.length / 2))) {
                    similar.push({
                        name: limitlessDeck.deck_name,
                        matches: matchCount,
                        ranking: limitlessDeck.ranking || 999
                    });
                }
            }
            
            // Sort by matches (descending) and then by ranking (ascending)
            similar.sort((a, b) => {
                if (b.matches !== a.matches) return b.matches - a.matches;
                return a.ranking - b.ranking;
            });
            
            return similar.map(d => d.name);
        }
        
        function showAlternativeDeckSelector(show, cityLeagueDeck) {
            const selector = document.getElementById('alternativeDeckSelector');
            if (!selector) {
                // Create the selector if it doesn't exist
                createAlternativeDeckSelector();
                return;
            }
            
            if (!show) {
                selector.style.display = 'none';
                currentAlternativeDeckName = '';
                return;
            }
            
            // Show selector and populate with similar decks
            selector.style.display = 'block';
            const select = document.getElementById('alternativeDeckSelect');
            if (!select) return;
            
            select.innerHTML = '<option value="">-- W√§hle ein alternatives Limitless-Deck --</option>';
            
            const similarDecks = findSimilarLimitlessDecks(cityLeagueDeck);
            similarDecks.forEach(deckName => {
                const option = document.createElement('option');
                option.value = deckName;
                option.textContent = deckName;
                select.appendChild(option);
            });
        }
        
        function createAlternativeDeckSelector() {
            const variantSelector = document.getElementById('variantSelector');
            if (!variantSelector) return;
            
            // Pr√ºfe, ob Selector bereits existiert
            if (document.getElementById('alternativeDeckSelector')) {
                return;
            }
            
            const selector = document.createElement('div');
            selector.id = 'alternativeDeckSelector';
            selector.style.display = 'none';
            selector.style.marginTop = '20px';
            selector.style.padding = '15px';
            selector.style.background = '#fff3cd';
            selector.style.borderRadius = '8px';
            selector.style.borderLeft = '4px solid #ffc107';
            
            selector.innerHTML = `
                <h3 style="margin-top: 0; color: #856404;">‚ö†Ô∏è Limitless-Daten nicht verf√ºgbar</h3>
                <p style="margin: 10px 0; color: #856404; font-size: 0.95em;">
                    Dieses City League Deck hat keine Limitless-Matchup-Daten. 
                    W√§hle ein √§hnliches Limitless-Deck, um Matchup-Informationen zu laden:
                </p>
                <select id="alternativeDeckSelect" onchange="onAlternativeDeckChange()" 
                        style="width: 100%; padding: 10px; border: 2px solid #ffc107; border-radius: 4px; font-size: 14px;">
                    <option value="">-- W√§hle ein alternatives Limitless-Deck --</option>
                </select>
                <p style="margin-top: 10px; font-size: 0.85em; color: #666;">
                    ‚ÑπÔ∏è Die Platzierung bleibt vom City League Deck, nur Matchup-Daten werden vom alternativen Deck geladen.
                </p>
            `;
            
            variantSelector.parentNode.insertBefore(selector, variantSelector.nextSibling);
        }
        
        function onAlternativeDeckChange() {
            const alternativeSelect = document.getElementById('alternativeDeckSelect');
            if (!alternativeSelect) return;
            
            currentAlternativeDeckName = alternativeSelect.value;
            console.log('[onAlternativeDeckChange] Selected alternative deck:', currentAlternativeDeckName);
            
            // Refresh matchups display AND stats with alternative deck data
            if (currentAlternativeDeckName) {
                // Update stats with alternative deck
                updateStatsForAlternativeDeck(currentAlternativeDeckName);
                // Update matchups display
                updateMatchupsDisplay(currentAlternativeDeckName);
            }
        }
        
        let selectedVariants = [];
        let variantsCollapsed = true;

        function toggleVariantSelector() {
            const variantOptions = document.getElementById('variantOptions');
            const toggle = document.getElementById('variantToggle');
            if (!variantOptions || !toggle) return;

            variantsCollapsed = !variantsCollapsed;
            variantOptions.style.display = variantsCollapsed ? 'none' : 'flex';
            toggle.classList.toggle('collapsed', variantsCollapsed);
        }
        
        function updateVariantSelector(mainDeck) {
            const variantSelector = document.getElementById('variantSelector');
            const variantOptions = document.getElementById('variantOptions');
            
            // Clear previous selections
            selectedVariants = [];
            
            // Get all unique archetypes from cardsData
            const cardsDataArchetypes = [...new Set(cardsData.map(c => c.archetype))];
            
            // Combine all available decks: cardsData + Top 20 Limitless + Top 10 City League
            const allAvailableDecks = new Set([
                ...cardsDataArchetypes,
                ...top20LimitlessArchetypes,
                ...top10CityLeagueArchetypes
            ]);
            
            // Convert to array and sort
            const allArchetypes = Array.from(allAvailableDecks).sort();
            
            // Filter out the main deck
            const variants = allArchetypes.filter(arch => 
                normalizeArchetypeName(arch) !== normalizeArchetypeName(mainDeck)
            );
            
            console.log('Variant Selector - Main deck:', mainDeck, '| Other archetypes available:', variants.length);
            
            if (variants.length === 0) {
                console.log('No variants found, hiding selector');
                variantSelector.style.display = 'none';
                return;
            }
            
            // Show selector and populate options with ALL available archetypes
            console.log('Showing variant selector with', variants.length, 'options');
            variantSelector.style.display = 'block';
            
            // Reset search field
            const searchInput = document.getElementById('variantSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            
            variantOptions.innerHTML = variants.map(variant => {
                const safeVariant = variant.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                return `
                    <label class="variant-checkbox">
                        <input type="checkbox" value="${safeVariant}" onchange="toggleVariant('${safeVariant}')">
                        <span>${variant}</span>
                    </label>
                `;
            }).join('');

            variantsCollapsed = true;
            variantOptions.style.display = 'none';
            const toggle = document.getElementById('variantToggle');
            if (toggle) {
                toggle.classList.add('collapsed');
            }
        }
        
        function toggleVariant(variantName) {
            const checkbox = document.querySelector(`input[value="${variantName}"]`);
            const label = checkbox.parentElement;
            
            if (checkbox.checked) {
                selectedVariants.push(variantName);
                label.classList.add('selected');
            } else {
                selectedVariants = selectedVariants.filter(v => v !== variantName);
                label.classList.remove('selected');
            }
            
            updateCardsDisplay();
        }
        
        // Cards Table Toggle
        let cardsCollapsed = true;

        function toggleCardsTable() {
            const cardsTableContent = document.getElementById('cardsTableContent');
            const toggle = document.getElementById('cardsToggle');
            if (!cardsTableContent || !toggle) return;

            cardsCollapsed = !cardsCollapsed;
            cardsTableContent.style.display = cardsCollapsed ? 'none' : 'block';
            toggle.classList.toggle('collapsed', cardsCollapsed);
        }
        
        // Card Search Filter
        function filterCards() {
            const searchInput = document.getElementById('cardSearchInput');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            
            console.log('filterCards called with searchTerm:', searchTerm);
            
            // Filter Desktop Table (Alle Karten)
            const tbody = document.getElementById('cardsBody');
            if (tbody) {
                let visibleCount = 0;
                let visibleSum = 0;
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    // Skip loading/error rows
                    if (row.cells.length === 1) {
                        row.style.display = '';
                        return;
                    }
                    
                    const cardName = row.cells[2] ? row.cells[2].textContent.toLowerCase() : '';
                    const setName = row.cells[3] ? row.cells[3].textContent.toLowerCase() : '';
                    
                    // Show if no search term or if it matches
                    const matches = searchTerm === '' || cardName.includes(searchTerm) || setName.includes(searchTerm);
                    
                    if (matches) {
                        row.style.display = '';
                        visibleCount++;
                        // Get max_count from cell[1] (card-count)
                        const countCell = row.cells[1];
                        if (countCell) {
                            const count = parseInt(countCell.textContent) || 1;
                            visibleSum += count;
                        }
                    } else {
                        row.style.display = 'none';
                    }
                });
                // Update summary for main deck
                document.getElementById('cardCount').textContent = `${visibleCount} Karten`;
                document.getElementById('cardCountSummary').textContent = `/ ${visibleSum} Total`;
            }
            
            // Filter Filtered Cards Table (Gefilterte Karten)
            const filteredCardsBody = document.getElementById('filteredCardsBody');
            if (filteredCardsBody) {
                let visibleCount = 0;
                let visibleSum = 0;
                const rows = filteredCardsBody.querySelectorAll('tr');
                rows.forEach(row => {
                    // Skip loading/error rows
                    if (row.cells.length === 1) {
                        row.style.display = '';
                        return;
                    }
                    
                    const cardName = row.cells[1] ? row.cells[1].textContent.toLowerCase() : '';
                    const setName = row.cells[2] ? row.cells[2].textContent.toLowerCase() : '';
                    
                    // Show if no search term or if it matches
                    const matches = searchTerm === '' || cardName.includes(searchTerm) || setName.includes(searchTerm);
                    
                    if (matches) {
                        row.style.display = '';
                        visibleCount++;
                        // Get max_count from cells[5]
                        const countCell = row.cells[5];
                        if (countCell) {
                            const count = parseInt(countCell.textContent) || 1;
                            visibleSum += count;
                        }
                    } else {
                        row.style.display = 'none';
                    }
                });
                // Update summary for filtered cards
                document.getElementById('filteredCardCount').textContent = `${visibleCount} Karten`;
                document.getElementById('filteredCardCountSummary').textContent = `/ ${visibleSum} Total`;
            }
            
            // Filter Mobile Card Grid
            const gridContainer = document.getElementById('cardsGridMobile');
            if (gridContainer) {
                const cardItems = gridContainer.querySelectorAll('.card-item');
                cardItems.forEach(cardItem => {
                    const cardName = cardItem.querySelector('.card-item-name')?.textContent.toLowerCase() || '';
                    const cardSet = cardItem.querySelector('.card-item-set')?.textContent.toLowerCase() || '';
                    
                    const matches = searchTerm === '' || cardName.includes(searchTerm) || cardSet.includes(searchTerm);
                    
                    if (matches) {
                        cardItem.style.display = '';
                    } else {
                        cardItem.style.display = 'none';
                    }
                });
            }
        }
        
        function updateStats(deckName) {
            const statsSection = document.getElementById('statsSection');
            
            // Set the current main deck for opponent matchup analyzer
            currentMainDeckName = deckName;
            
            // Get both data sources
            const cityLeagueMatch = cityLeagueData.find(m => 
                normalizeArchetypeName(m.archetype) === normalizeArchetypeName(deckName)
            );
            
            // Get Limitless data from the main decks CSV (which has rank and win_rate)
            const limitlessMatch = matchupsData.find(m => 
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(deckName)
            );
            
            // Find Limitless deck stats from parsed HTML (has Total WR and Vs Top20 Matchup)
            let limitlessDeckInfo = null;
            for (const [deckKey, stats] of Object.entries(limitlessDeckStats)) {
                if (normalizeArchetypeName(deckKey) === normalizeArchetypeName(deckName)) {
                    limitlessDeckInfo = stats;
                    break;
                }
            }
            
            // Show section if we have ANY data
            if (cityLeagueMatch || limitlessMatch || limitlessDeckInfo) {
                statsSection.style.display = 'block';
                
                // RANKING: Limitless HTML stats > Limitless CSV > none
                if (limitlessDeckInfo && limitlessDeckInfo.rank) {
                    document.getElementById('statRanking').textContent = `#${limitlessDeckInfo.rank}`;
                } else if (limitlessMatch && limitlessMatch.rank) {
                    document.getElementById('statRanking').textContent = `#${limitlessMatch.rank}`;
                } else {
                    document.getElementById('statRanking').textContent = '-';
                }
                
                // WIN RATE: Limitless HTML stats > Limitless CSV > City League
                if (limitlessDeckInfo && limitlessDeckInfo.wr) {
                    document.getElementById('statWinRate').textContent = limitlessDeckInfo.wr;
                } else if (limitlessMatch && limitlessMatch.win_rate) {
                    document.getElementById('statWinRate').textContent = limitlessMatch.win_rate;
                } else if (cityLeagueMatch && cityLeagueMatch.new_avg_placement) {
                    document.getElementById('statWinRate').textContent = cityLeagueMatch.new_avg_placement;
                } else {
                    document.getElementById('statWinRate').textContent = '-';
                }
                
                // √ò PLATZIERUNG: City League avg placement ONLY
                if (cityLeagueMatch && cityLeagueMatch.new_avg_placement) {
                    document.getElementById('statMatches').textContent = cityLeagueMatch.new_avg_placement;
                } else {
                    document.getElementById('statMatches').textContent = '-';
                }
                
                // VS TOP 20: Limitless HTML stats > getMatchupBalance > City League status
                if (limitlessDeckInfo && limitlessDeckInfo.matchup) {
                    document.getElementById('statBalance').textContent = limitlessDeckInfo.matchup;
                } else {
                    // Use alternative deck name for getMatchupBalance if available
                    const deckForBalance = currentAlternativeDeckName || deckName;
                    const matchupBalance = getMatchupBalance(deckForBalance);
                    if (matchupBalance) {
                        document.getElementById('statBalance').textContent = `${matchupBalance.over50}:${matchupBalance.under50}`;
                    } else if (cityLeagueMatch && cityLeagueMatch.status) {
                        // Fallback: Show City League status
                        const status = cityLeagueMatch.status;
                        let statusEmoji = '‚óè';
                        if (status === 'NEU') statusEmoji = 'üÜï';
                        else if (status === 'BESTEHEND') statusEmoji = '‚úì';
                        else if (status === 'VERSCHWUNDEN') statusEmoji = '‚ùå';
                        document.getElementById('statBalance').textContent = `${statusEmoji} ${status}`;
                    } else if (limitlessMatch) {
                        document.getElementById('statBalance').textContent = '‚úì KOMPETITIV';
                    } else {
                        document.getElementById('statBalance').textContent = '-';
                    }
                }
                
                // MATCHUPS: IMMER aus Limitless Matchup-Daten, wenn vorhanden
                console.log('[updateStats] Checking matchups - limitlessMatchupData keys:', Object.keys(limitlessMatchupData).length, 'matchupDetailsData length:', matchupDetailsData.length);
                if ((limitlessMatchupData && Object.keys(limitlessMatchupData).length > 0) ||
                    (matchupDetailsData && matchupDetailsData.length > 0)) {
                    console.log('[updateStats] Matchup condition TRUE, calling updateMatchupsDisplay for:', deckName);
                    if (!limitlessMatchupData || Object.keys(limitlessMatchupData).length === 0) {
                        console.log('[updateStats] Rebuilding limitlessMatchupData from matchupDetailsData');
                        limitlessMatchupData = buildLimitlessMatchupData(matchupDetailsData);
                    }
                    
                    // Use alternative deck name for matchups if available, otherwise use main deck name
                    const deckForMatchups = currentAlternativeDeckName || deckName;
                    console.log('[updateStats] Loading matchups for:', deckForMatchups, '(Main:', deckName, ', Alt:', currentAlternativeDeckName, ')');
                    updateMatchupsDisplay(deckForMatchups);
                    
                    // SHOW/HIDE Matchups section when we have the data
                    const matchupsSection = document.getElementById('matchupsSection');
                    if (matchupsSection) {
                        matchupsSection.style.display = 'block';
                    }
                } else if (cityLeagueMatch) {
                    console.log('[updateStats] Matchup condition FALSE - using City League fallback');
                    // Fallback: City League Trend-Info
                    const status = cityLeagueMatch.status || 'UNBEKANNT';
                    const trend = cityLeagueMatch.trend || '-';
                    const change = cityLeagueMatch.appearances_change || '0';
                    
                    let statusEmoji = '‚óè';
                    if (status === 'NEU') statusEmoji = 'üÜï';
                    else if (status === 'BESTEHEND') statusEmoji = '‚úì';
                    else if (status === 'VERSCHWUNDEN') statusEmoji = '‚ùå';
                    
                    let trendEmoji = '‚Üí';
                    if (trend === 'STEIGEND') trendEmoji = 'üìà';
                    else if (trend === 'FALLEND') trendEmoji = 'üìâ';
                    else if (trend === 'STABIL') trendEmoji = '‚û°Ô∏è';
                    
                    document.getElementById('topMatchups').innerHTML = `
                        <div class="matchup-item">
                            <span><strong>Status:</strong> ${statusEmoji} ${status}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Trend:</strong> ${trendEmoji} ${trend}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Ver√§nderung:</strong></span>
                            <span style="color: ${change > 0 ? '#28a745' : change < 0 ? '#dc3545' : '#666'}; font-weight: bold;">
                                ${change > 0 ? '+' : ''}${change} Auftritte
                            </span>
                        </div>
                    `;
                    
                    const placementChange = parseFloat(cityLeagueMatch.placement_change || '0').toFixed(1);
                    const avgPlacement = cityLeagueMatch.new_avg_placement || '-';
                    document.getElementById('worstMatchups').innerHTML = `
                        <div class="matchup-item">
                            <span><strong>Alte √ò Platzierung:</strong></span>
                            <span>${cityLeagueMatch.old_avg_placement || '-'}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Neue √ò Platzierung:</strong></span>
                            <span>${avgPlacement}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>√Ñnderung:</strong></span>
                            <span style="color: ${placementChange < 0 ? '#28a745' : placementChange > 0 ? '#dc3545' : '#666'}; font-weight: bold;">
                                ${placementChange > 0 ? '+' : ''}${placementChange}
                            </span>
                        </div>
                        <p style="margin-top: 15px; color: #666; font-size: 0.9em;">
                            <strong>Info:</strong> City League Daten zeigen Trends √ºber Zeitr√§ume, keine direkten Matchups.
                        </p>
                    `;
                }
                
            } else {
                statsSection.style.display = 'none';
            }
            
            // Show/hide Matchups section based on Limitless matchup data availability
            const matchupsSection = document.getElementById('matchupsSection');
            if ((limitlessMatchupData && Object.keys(limitlessMatchupData).length > 0 && currentMainDeckName) ||
                (matchupDetailsData && matchupDetailsData.length > 0 && currentMainDeckName)) {
                matchupsSection.style.display = 'block';
            } else {
                matchupsSection.style.display = 'none';
            }
        }
        
        function normalizeArchetypeName(name) {
            if (!name) return '';
            return name.toLowerCase().trim()
                .replace(/\s+/g, ' ')
                .replace(/[√†√°√¢√£√§√•]/g, 'a')
                .replace(/[√®√©√™√´]/g, 'e')
                .replace(/[√¨√≠√Æ√Ø]/g, 'i')
                .replace(/[√≤√≥√¥√µ√∂]/g, 'o')
                .replace(/[√π√∫√ª√º]/g, 'u');
        }

        function getMatchupBalance(deckName) {
            if (!matchupDetailsData || matchupDetailsData.length === 0) return null;
            if (!matchupsData || matchupsData.length === 0) return null;

            // Get Top 20 deck names from Limitless Online rankings
            const top20Names = matchupsData.slice(0, 20).map(d => normalizeArchetypeName(d.deck_name || d.deck_name));
            console.log('[getMatchupBalance] Top 20 names:', top20Names);

            const deckMatchups = matchupDetailsData.filter(m =>
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(deckName)
            );

            if (deckMatchups.length === 0) return null;

            let over50 = 0;
            let under50 = 0;

            deckMatchups.forEach(m => {
                // Only count if opponent is in Top 20
                const opponentName = m.opponent || m.opponent_deck;
                if (!top20Names.includes(normalizeArchetypeName(opponentName))) {
                    return;
                }
                
                const winRate = parseFloat(String(m.win_rate || '').replace('%', '').replace(',', '.'));
                if (Number.isNaN(winRate)) return;
                if (winRate > 50) over50 += 1;
                else if (winRate < 50) under50 += 1;
            });

            return { over50, under50 };
        }
        
        function updateStatsForAlternativeDeck(alternativeDeckName) {
            console.log('[updateStatsForAlternativeDeck] Updating stats for:', alternativeDeckName);
            
            // Get Limitless data for alternative deck from CSV
            const limitlessMatch = matchupsData.find(m => 
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(alternativeDeckName)
            );
            
            // Find Limitless deck stats from parsed HTML
            let limitlessDeckInfo = null;
            for (const [deckKey, stats] of Object.entries(limitlessDeckStats)) {
                if (normalizeArchetypeName(deckKey) === normalizeArchetypeName(alternativeDeckName)) {
                    limitlessDeckInfo = stats;
                    break;
                }
            }
            
            console.log('[updateStatsForAlternativeDeck] Found limitlessDeckInfo:', !!limitlessDeckInfo, 'Found limitlessMatch:', !!limitlessMatch);
            
            // Update RANKING: Limitless HTML stats > Limitless CSV
            if (limitlessDeckInfo && limitlessDeckInfo.rank) {
                document.getElementById('statRanking').textContent = `#${limitlessDeckInfo.rank}`;
            } else if (limitlessMatch && limitlessMatch.rank) {
                document.getElementById('statRanking').textContent = `#${limitlessMatch.rank}`;
            } else {
                document.getElementById('statRanking').textContent = '-';
            }
            
            // Update WIN RATE: Limitless HTML stats > Limitless CSV
            if (limitlessDeckInfo && limitlessDeckInfo.wr) {
                document.getElementById('statWinRate').textContent = limitlessDeckInfo.wr;
            } else if (limitlessMatch && limitlessMatch.win_rate) {
                document.getElementById('statWinRate').textContent = limitlessMatch.win_rate;
            } else {
                document.getElementById('statWinRate').textContent = '-';
            }
            
            // Update VS TOP 20: Limitless HTML stats > getMatchupBalance
            if (limitlessDeckInfo && limitlessDeckInfo.matchup) {
                document.getElementById('statBalance').textContent = limitlessDeckInfo.matchup;
            } else {
                const matchupBalance = getMatchupBalance(alternativeDeckName);
                if (matchupBalance) {
                    document.getElementById('statBalance').textContent = `${matchupBalance.over50}:${matchupBalance.under50}`;
                } else {
                    document.getElementById('statBalance').textContent = '-';
                }
            }
            
            // NOTE: √ò PLATZIERUNG bleibt vom Haupt-City-League-Deck!
            console.log('[updateStatsForAlternativeDeck] Placement stays from main City League deck');
        }
        
        function updateMatchupsDisplay(deckName) {
            console.log('[updateMatchupsDisplay] Called with deckName:', deckName);
            console.log('[updateMatchupsDisplay] limitlessMatchupData keys:', Object.keys(limitlessMatchupData).slice(0, 5));
            console.log('[updateMatchupsDisplay] matchupDetailsData length:', matchupDetailsData.length);
            
            // Find the correct deck name in limitlessMatchupData (case-insensitive)
            let matchingDeckName = null;
            for (const key of Object.keys(limitlessMatchupData)) {
                if (normalizeArchetypeName(key) === normalizeArchetypeName(deckName)) {
                    matchingDeckName = key;
                    break;
                }
            }
            
            console.log('[updateMatchupsDisplay] Looking for deck:', deckName, 'Found:', matchingDeckName, 'Available decks:', Object.keys(limitlessMatchupData).slice(0, 5));
            
            if (!matchingDeckName || !limitlessMatchupData[matchingDeckName]) {
                console.warn('[updateMatchupsDisplay] No matchup data for:', deckName);
                document.getElementById('topMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px; text-align: center; color: #999;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                document.getElementById('worstMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px; text-align: center; color: #999;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                return;
            }
            
            // Convert matchup data to array format
            const opponents = limitlessMatchupData[matchingDeckName];
            let matchupList = Object.values(opponents).map(m => ({
                opponent_deck: m.opponent_deck || m.opponent || '',
                win_rate: m.win_rate || '0%',
                win_rate_numeric: m.win_rate_numeric || 0,
                record: m.record || '',
                total_games: m.total_games || 0
            }));
            
            console.log('[updateMatchupsDisplay] Found', matchupList.length, 'matchups for', matchingDeckName);
            
            if (matchupList.length === 0) {
                document.getElementById('topMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                document.getElementById('worstMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                return;
            }
            
            // Sort by win rate (numeric)
            matchupList.sort((a, b) => {
                const aRate = a.win_rate_numeric || 0;
                const bRate = b.win_rate_numeric || 0;
                return bRate - aRate;
            });
            
            // Get top matchups (>50% WR) and worst matchups (<50% WR)
            const topMatchups = matchupList.filter(m => m.win_rate_numeric > 50).slice(0, 5);
            const worstMatchups = matchupList.filter(m => m.win_rate_numeric < 50).reverse().slice(0, 5);
            
            // Render Top Matchups
            const topHtml = topMatchups.map(m => `
                <tr>
                    <td style="padding: 8px;"><strong>${m.opponent_deck}</strong></td>
                    <td style="padding: 8px; text-align: right;"><strong>${m.win_rate}</strong></td>
                    <td style="padding: 8px; text-align: right;">${m.record}</td>
                </tr>
            `).join('');
            document.getElementById('topMatchups').innerHTML = topHtml || '<tr><td colspan="3" style="padding: 10px;">Keine gewonnenen Matchups</td></tr>';
            
            // Render Worst Matchups
            const worstHtml = worstMatchups.map(m => `
                <tr>
                    <td style="padding: 8px;"><strong>${m.opponent_deck}</strong></td>
                    <td style="padding: 8px; text-align: right;"><strong>${m.win_rate}</strong></td>
                    <td style="padding: 8px; text-align: right;">${m.record}</td>
                </tr>
            `).join('');
            document.getElementById('worstMatchups').innerHTML = worstHtml || '<tr><td colspan="3" style="padding: 10px;">Keine verlorenen Matchups</td></tr>';
            
            // Populate opponent dropdown with all available opponents
            const opponentSelect = document.getElementById('opponentSelect');
            const allOpponents = new Set(matchupList.map(m => m.opponent_deck).sort());
            opponentSelect.innerHTML = '<option value="">-- Select a deck --</option>' + 
                Array.from(allOpponents).map(opp => `<option value="${opp}">${opp}</option>`).join('');
            
            // Update matchup deck title
            const matchupsDeckTitle = document.getElementById('matchupsDeckTitle');
            if (matchupsDeckTitle) {
                matchupsDeckTitle.textContent = deckName;
            }
        }
        
        function showMatchupAnalyzer(opponentDeck) {
            const detailsDiv = document.getElementById('matchupAnalysisDetails');
            
            if (!opponentDeck || !currentMainDeckName) {
                detailsDiv.style.display = 'none';
                return;
            }
            
            // Get matchup info from limitlessMatchupData
            let mainDeckKey = null;
            for (const key of Object.keys(limitlessMatchupData)) {
                if (normalizeArchetypeName(key) === normalizeArchetypeName(currentMainDeckName)) {
                    mainDeckKey = key;
                    break;
                }
            }
            const mainDeckData = mainDeckKey ? limitlessMatchupData[mainDeckKey] : null;
            if (!mainDeckData || !mainDeckData[opponentDeck]) {
                detailsDiv.innerHTML = `<p style="color: #e74c3c;">Keine Matchup-Daten f√ºr ${opponentDeck}</p>`;
                detailsDiv.style.display = 'block';
                return;
            }
            
            const matchup = mainDeckData[opponentDeck];
            const wr = matchup.win_rate || 'N/A';
            const wrNum = matchup.win_rate_numeric || 0;
            const record = matchup.record || 'N/A';
            const games = matchup.total_games || 0;
            const wrColor = wrNum > 50 ? '#27ae60' : '#e74c3c';
            
            detailsDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: center;">
                    <div>
                        <div><strong>Matchup:</strong> ${currentMainDeckName} vs ${opponentDeck}</div>
                        <div style="margin-top: 10px;"><strong>Record:</strong> ${record}</div>
                        <div><strong>Games:</strong> ${games}</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">WIN RATE</div>
                        <div style="font-size: 2.5em; font-weight: bold; color: ${wrColor};">${wr}</div>
                    </div>
                    <div style="text-align: center; padding: 15px; background: white; border-radius: 4px;">
                        <div style="font-size: 0.85em; color: #999; margin-bottom: 10px;">MATCHUP</div>
                        <div style="font-size: 3em; font-weight: bold; color: ${wrColor};">${wrNum.toFixed(1)}%</div>
                    </div>
                </div>
            `;
            detailsDiv.style.display = 'block';
        }
        
        function updateCardsDisplay() {
            // Meta-Main-Filter logic
            const selectedMeta = getSelectedMetaMainOptions();
            const selectedDeck = document.getElementById('deckSelect').value;
            const filter = document.getElementById('filterSelect').value;
            
            if (!selectedDeck) {
                document.getElementById('cardsBody').innerHTML = '<tr><td colspan="7" class="loading">Bitte w√§hle ein Deck aus...</td></tr>';
                document.getElementById('deckVisual').style.display = 'none';
                return;
            }
            
            // Filter cards for selected deck AND selected variants
            const decksToInclude = [selectedDeck, ...selectedVariants];
            let deckCards = cardsData.filter(c => decksToInclude.includes(c.archetype));
            
            // Apply meta filter to cards
            if (selectedMeta.size > 0) {
                deckCards = deckCards.filter(card => cardMatchesSelectedMeta(card, selectedMeta));
            }
            
            console.log('Initial filtered cards:', deckCards.length, 'from archetype:', selectedDeck);
            if (deckCards.length > 0) {
                console.log('First card image_url:', deckCards[0].image_url);
            }
            
            // Aggregate cards by name (combine same cards from different variants)
            const cardMap = new Map();
            deckCards.forEach(card => {
                const key = `${card.card_name}_${card.set_code}_${card.set_number}`;
                if (!cardMap.has(key)) {
                    cardMap.set(key, { ...card, sources: [card.archetype] });
                } else {
                    const existing = cardMap.get(key);
                    if (!existing.sources.includes(card.archetype)) {
                        existing.sources.push(card.archetype);
                    }
                }
            });
            
            deckCards = Array.from(cardMap.values());
            
            console.log('After aggregation:', deckCards.length, 'cards');
            if (deckCards.length > 0) {
                console.log('First aggregated card:', deckCards[0].card_name, 'image_url:', deckCards[0].image_url);
            }
            
            // Meta filter applied before aggregation.
            // Apply percentage filter (only for main deck)
            if (filter === '90') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 90 ||
                    c.archetype !== selectedDeck
                );
            } else if (filter === '70') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 70 ||
                    c.archetype !== selectedDeck
                );
            } else if (filter === '50') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 50 ||
                    c.archetype !== selectedDeck
                );
            }
            
            // Update count with cumulative sum
            const cardCountTotal = deckCards.reduce((sum, card) => sum + (parseInt(card.max_count) || 1), 0);
            currentDeckCards = deckCards; // Store for filterCards() function
            document.getElementById('cardCount').textContent = `${deckCards.length} Karten`;
            document.getElementById('cardCountSummary').textContent = `/ ${cardCountTotal} Total`;
            
            // Sort cards by type (Pokemon, Supporter, Item, Tool, Stadium, Special Energy, Energy)
console.log('BEFORE SORT - All cards count:', deckCards.length);

            deckCards = sortCardsByType(deckCards);

            console.log('AFTER SORT - ALL CARDS with category:');
            console.table(deckCards.map((c, idx) => {
                const cardType = c.type || '';
                let category = 'Unknown';
                if (cardType && cardType.charAt(0).match(/[GRWLPFDMNC]/)) {
                    category = 'Pokemon';
                } else if (cardType === 'Supporter') {
                    category = 'Supporter';
                } else if (cardType === 'Item') {
                    category = 'Item';
                } else if (cardType === 'Tool') {
                    category = 'Tool';
                } else if (cardType === 'Stadium') {
                    category = 'Stadium';
                } else if (cardType === 'Energy' || cardType === 'Special Energy') {
                    category = cardType;
                }
                return {
                    '#': idx + 1,
                    name: c.card_name,
                    type: c.type,
                    category: category
                };
            }));
            
            // Save for image generation
            currentDeckCards = deckCards;
            
            // Show/hide generate image button
            const generateBtn = document.getElementById('generateDeckCardsBtn');
            const copyAllBtn = document.getElementById('copyAllCardsBtn');
            if (generateBtn) {
                generateBtn.style.display = deckCards.length > 0 ? 'block' : 'none';
            }
            if (copyAllBtn) {
                copyAllBtn.style.display = deckCards.length > 0 ? 'block' : 'none';
            }
            
            // Update deck visual grid
            updateDeckVisual(deckCards);
            
            // Display cards in table
            const tbody = document.getElementById('cardsBody');
            if (deckCards.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="loading">Keine Karten gefunden</td></tr>';
                return;
            }
            
            console.log('Final deck cards for display:', deckCards.length);
            if (deckCards.length > 0) {
                console.log('Sample card:', {
                    name: deckCards[0].card_name,
                    imageUrl: deckCards[0].image_url,
                    hasImage: !!deckCards[0].image_url
                });
            }
            
            tbody.innerHTML = deckCards.map(card => {
                const percentage = parseFloat(card.percentage_in_archetype.replace(',', '.'));
                const imageUrl = card.image_url || '';
                
                // Create thumbnail HTML
                let thumbnailHtml;
                if (imageUrl && imageUrl.trim() !== '') {
                    thumbnailHtml = `<img src="${imageUrl}" alt="${card.card_name}" class="card-thumbnail" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;" referrerpolicy="no-referrer" onerror="this.style.display='none'">`;
                } else {
                    thumbnailHtml = `<div class="card-thumbnail-placeholder">üÉè</div>`;
                }
                
                // Show source decks if from variants
                let sourceInfo = '';
                if (card.sources && card.sources.length > 1) {
                    sourceInfo = `<br><small style="color: #667eea;">aus: ${card.sources.join(', ')}</small>`;
                } else if (card.sources && card.sources[0] !== document.getElementById('deckSelect').value) {
                    sourceInfo = `<br><small style="color: #667eea;">aus: ${card.sources[0]}</small>`;
                }
                
                // Check if card is Ace Spec
                const aceSpecBadge = card.is_ace_spec === 'Yes' ? '<span style="background: linear-gradient(135deg, #FFD700, #FFA500); color: #000; padding: 2px 6px; border-radius: 3px; font-size: 0.75em; font-weight: bold; margin-left: 6px;">‚≠ê ACE SPEC</span>' : '';
                
                return `
                    <tr>
                        <td>${thumbnailHtml}</td>
                        <td class="card-count">${card.max_count}</td>
                        <td><strong>${card.card_name}</strong>${aceSpecBadge}${sourceInfo}</td>
                        <td>${card.set_code || '-'}</td>
                        <td>${card.set_number || '-'}</td>
                        <td><span style="color: ${percentage > 70 ? '#28a745' : percentage > 50 ? '#ffc107' : '#666'}; font-weight: bold;">${card.percentage_in_archetype}%</span></td>
                        <td><button class="btn btn-sm btn-add" data-identifier="${card.card_identifier}" data-max-count="${card.max_count}" data-card-name="${card.card_name}" data-image-url="${imageUrl}" data-set-code="${card.set_code || ''}" data-set-number="${card.set_number || ''}">‚ûï Hinzuf√ºgen</button></td>
                    </tr>
                `;
            }).join('');
            
            // Also render mobile card grid
            renderCardGridMobile(deckCards);
        }
        
        function updateDeckVisual(deckCards) {
            const deckGrid = document.getElementById('deckGrid');
            const deckVisual = document.getElementById('deckVisual');
            
            if (deckCards.length === 0) {
                deckVisual.style.display = 'none';
                return;
            }
            
            deckVisual.style.display = 'block';
            
            // Sort cards before displaying
            const sortedCards = sortCardsByType([...deckCards]);
            
            // Show cards with images prominently
            deckGrid.innerHTML = sortedCards.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.card_name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">üÉè</div>
                                <div>${card.card_name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function renderCardGridMobile(deckCards) {
            const gridContainer = document.getElementById('cardsGridMobile');
            if (!gridContainer) return;
            
            if (deckCards.length === 0) {
                gridContainer.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 40px; color: #666;">Keine Karten gefunden</div>';
                return;
            }
            
            const normalizeSetNumber = (num) => {
                const raw = (num || '').trim();
                if (/^\d+$/.test(raw)) {
                    return String(parseInt(raw, 10));
                }
                return raw;
            };

            const lookupCardmarketData = (setCode, setNumber, version) => {
                if (!setCode || !setNumber) return null;
                const normalizedNumber = normalizeSetNumber(setNumber);
                const key = setCode + '/' + normalizedNumber + '/' + version;
                let data = cardmarketPrices.get(key) || null;
                if (data) return data;
                const prefix = setCode + '/' + normalizedNumber + '/';
                for (const [k, v] of cardmarketPrices.entries()) {
                    if (k.startsWith(prefix)) {
                        return v;
                    }
                }
                return null;
            };

            gridContainer.innerHTML = deckCards.map(card => {
                const percentage = parseFloat(card.percentage_in_archetype.replace(',', '.'));
                const imageUrl = card.image_url || '';
                const maxCount = card.max_count || '-';
                const aceSpecBadge = card.is_ace_spec === 'Yes' ? '<span style="background: linear-gradient(135deg, #FFD700, #FFA500); color: #000; padding: 2px 6px; border-radius: 3px; font-size: 0.7em; font-weight: bold; display: inline-block; margin-top: 4px;">‚≠ê ACE SPEC</span>' : '';
                
                const imgHtml = imageUrl && imageUrl.trim() !== '' 
                    ? `<img src="${imageUrl}" alt="${card.card_name}" referrerpolicy="no-referrer" onerror="this.style.opacity='0.3'">`
                    : `<div style="width: 100%; aspect-ratio: 2.5/3.5; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;">üÉè</div>`;

                const setCode = (card.set_code || '').trim().toUpperCase();
                const setNumber = (card.set_number || '').trim();
                const normalizedSetNumber = normalizeSetNumber(setNumber);
                const rarityCategory = getRarityCategory(card.rarity);
                let version = '1';
                if (rarityCategory === 'mid') version = '2';
                else if (rarityCategory === 'high') version = '3';

                let cardmarketLinkHtml = '';
                const priceData = lookupCardmarketData(setCode, normalizedSetNumber, version);
                if (priceData && priceData.url) {
                    if (version === '1') {
                        cardmarketLinkHtml = `<a href="${priceData.url}" target="_blank" style="display:block; margin-top: 6px; text-decoration: none; color: #3498db; font-size: 0.85em;">üîç CardMarket</a>`;
                    } else if (priceData.price) {
                        cardmarketLinkHtml = `<a href="${priceData.url}" target="_blank" style="display:block; margin-top: 6px; text-decoration: none; color: #27ae60; font-weight: 600; font-size: 0.95em;">üí∞ ‚Ç¨${priceData.price}</a>`;
                    } else {
                        cardmarketLinkHtml = `<a href="${priceData.url}" target="_blank" style="display:block; margin-top: 6px; text-decoration: none; color: #3498db; font-size: 0.85em;">üîç CardMarket</a>`;
                    }
                }
                
                return `
                    <div class="card-item">
                        ${imgHtml}
                        <div class="card-item-count">${maxCount}</div>
                        <div class="card-item-info">
                            <div class="card-item-name">${card.card_name}${aceSpecBadge}</div>
                            <div class="card-item-set">${card.set_code} ${card.set_number} (${card.percentage_in_archetype})</div>
                            ${cardmarketLinkHtml}
                        </div>
                        <div class="card-item-actions">
                            <button class="btn-add" data-identifier="${card.card_identifier}" data-max-count="${maxCount}" data-card-name="${card.card_name}" data-image-url="${imageUrl}" data-set-code="${card.set_code || ''}" data-set-number="${card.set_number || ''}">+ Add</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function showCardImage(imageUrl, cardName) {
            // Create modal to show full card image
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            modal.innerHTML = `
                <div style="max-width: 90%; max-height: 90%; text-align: center;">
                    <img src="${imageUrl}" alt="${cardName}" style="max-width: 100%; max-height: 80vh; border-radius: 15px; box-shadow: 0 10px 50px rgba(0,0,0,0.5);">
                    <div style="color: white; margin-top: 20px; font-size: 1.5em; font-weight: bold;">${cardName}</div>
                    <div style="color: #ccc; margin-top: 10px;">Klicke irgendwo, um zu schlie√üen</div>
                </div>
            `;
            
            modal.onclick = () => document.body.removeChild(modal);
            document.body.appendChild(modal);
        }
        
        function addToDeck(cardIdentifier, maxCount, cardName, imageUrl, setCode, setNumber) {
            // Find card data from cardsData
            const cardData = cardsData.find(c => c.card_identifier === cardIdentifier);
            const isAceSpec = cardData && cardData.is_ace_spec === 'Yes';
            
            // Check if this is an Ace Spec card
            if (isAceSpec) {
                // Check if we already have ANY Ace Spec card in the deck
                const existingAceSpec = myDeck.find(c => c.is_ace_spec === true);
                if (existingAceSpec && existingAceSpec.name !== cardName) {
                    alert(`‚ö†Ô∏è Du kannst nur eine Ace Spec Karte im Deck haben!\n\nBereits im Deck: ${existingAceSpec.name}\nVersuchst hinzuzuf√ºgen: ${cardName}\n\nBitte entferne zuerst die bestehende Ace Spec Karte.`);
                    return;
                }
                
                // If trying to add the same Ace Spec that's already in the deck
                const existingCard = myDeck.find(c => c.identifier === cardIdentifier);
                if (existingCard && existingCard.count >= 1) {
                    alert(`‚ö†Ô∏è Ace Spec Karten d√ºrfen nur 1x im Deck sein!\n\n${cardName} ist bereits im Deck.`);
                    return;
                }
            }
            
            const existingCard = myDeck.find(c => c.identifier === cardIdentifier);
            
            if (existingCard) {
                // For Ace Spec cards, max is 1
                const actualMaxCount = isAceSpec ? 1 : Math.min(4, maxCount);
                if (existingCard.count < actualMaxCount) {
                    existingCard.count++;
                }
            } else {
                const cardType = cardData ? cardData.type : '';
                
                myDeck.push({
                    identifier: cardIdentifier,
                    name: cardName,
                    count: 1,
                    maxCount: isAceSpec ? 1 : Math.min(4, maxCount),
                    imageUrl: imageUrl,
                    type: cardType,
                    setCode: setCode || (cardData ? cardData.set_code : ''),
                    setNumber: setNumber || (cardData ? cardData.set_number : ''),
                    setName: cardData ? cardData.set_name : '',
                    percentage_in_archetype: cardData ? cardData.percentage_in_archetype : '0',
                    is_ace_spec: isAceSpec
                });
            }
            
            updateDeckDisplay();
        }
        
        function removeFromDeck(cardName) {
            const card = myDeck.find(c => c.name === cardName);
            if (card) {
                card.count--;
                if (card.count <= 0) {
                    myDeck = myDeck.filter(c => c.name !== cardName);
                }
            }
            updateDeckDisplay();
        }
        
        function updateDeckDisplay() {
            const deckList = document.getElementById('deckList');
            const totalCards = myDeck.reduce((sum, card) => sum + card.count, 0);
            const uniqueCards = myDeck.length;
            
            document.getElementById('deckCardCount').textContent = totalCards;
            document.getElementById('deckCardCountUnique').textContent = `(${uniqueCards} Unique)`;
            
            // Update visual grid
            updateMyDeckVisual();
            
            if (myDeck.length === 0) {
                deckList.innerHTML = '<p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>';
                return;
            }
            
            deckList.innerHTML = myDeck.map(card => {
                const imageUrl = card.imageUrl || '';
                let cardVisual = '';
                if (imageUrl && imageUrl.trim() !== '') {
                    cardVisual = `
                        <div style="width: 60px; height: 80px; margin-right: 10px; cursor: pointer;" data-image-url="${imageUrl}" data-card-name="${card.name}">
                            <img src="${imageUrl}" alt="${card.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);" referrerpolicy="no-referrer" onerror="this.style.display='none'">
                        </div>
                    `;
                } else {
                    cardVisual = `
                        <div style="width: 60px; height: 80px; margin-right: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 5px; display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;">
                            üÉè
                        </div>
                    `;
                }
                
                return `
                    <div class="deck-card" style="display: flex; align-items: center;">
                        ${cardVisual}
                        <div style="flex: 1;">
                            <strong>${card.count}x ${card.name}</strong>
                            ${card.is_ace_spec ? '<span style="background: linear-gradient(135deg, #FFD700, #FFA500); color: #000; padding: 2px 8px; border-radius: 4px; font-size: 0.7em; font-weight: bold; margin-left: 8px;">‚≠ê ACE SPEC</span>' : ''}
                            <br><small style="color: #666;">${card.setCode || ''} ${card.setNumber || ''}</small>
                        </div>
                        <div class="deck-card-controls">
                            <button class="btn-add" data-identifier="${card.identifier}" data-max-count="${card.maxCount}" data-card-name="${card.name}" data-image-url="${imageUrl || card.imageUrl || ''}" data-set-code="${card.setCode || ''}" data-set-number="${card.setNumber || ''}">+</button>
                            <button class="btn-remove" data-card-name="${card.name}">-</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateMyDeckVisual() {
            const myDeckVisual = document.getElementById('myDeckVisual');
            const myDeckGrid = document.getElementById('myDeckGrid');
            
            if (myDeck.length === 0) {
                myDeckVisual.style.display = 'none';
                return;
            }
            
            myDeckVisual.style.display = 'block';
            
            // Sort deck by type before displaying
            const sortedDeck = sortCardsByType([...myDeck]);
            
            // Show each card ONCE with count badge (nicht mehrfach)
            myDeckGrid.innerHTML = sortedDeck.map(card => {
                const imageUrl = card.imageUrl || '';
                const count = card.count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" data-image-url="${imageUrl}" data-card-name="${card.name}" style="cursor: pointer;">
                            <img src="${imageUrl}" alt="${card.name}" referrerpolicy="no-referrer" onerror="this.style.display='none'">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">\ud83c\udccf</div>
                                <div>${card.name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function clearDeck() {
            if (confirm('Willst du das Deck wirklich leeren?')) {
                myDeck = [];
                updateDeckDisplay();
            }
        }
        
        function copyDeckToClipboard() {
            if (myDeck.length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            let deckText = '';
            myDeck.forEach(card => {
                deckText += `${card.count}x ${card.name}\n`;
            });
            
            // Copy to clipboard
            navigator.clipboard.writeText(deckText).then(() => {
                alert(`${myDeck.length} Karten in die Zwischenablage kopiert!\n\n${deckText}`);
            }).catch(() => {
                // Fallback f√ºr √§ltere Browser
                const textarea = document.createElement('textarea');
                textarea.value = deckText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`${myDeck.length} Karten in die Zwischenablage kopiert!\n\n${deckText}`);
            });
        }
        
        function autoComplete() {
            const selectedDeck = document.getElementById('deckSelect').value;
            if (!selectedDeck) {
                alert('Bitte w√§hle zuerst ein Deck aus!');
                return;
            }
            
            myDeck = [];
            
            console.log('[autoComplete] Starting autoComplete for:', selectedDeck);
            console.log('[autoComplete] Total cardsData entries:', cardsData.length);
            
            // Get ALL cards for this archetype
            let deckCards = cardsData.filter(c => c.archetype === selectedDeck);
            console.log('[autoComplete] Cards filtered for archetype:', deckCards.length);
            
            // Step 1: CRITICAL - Deduplicate by card_identifier
            // If multiple entries have identical percentage, keep first occurrence
            const uniqueCards = {};
            for (const card of deckCards) {
                const cardId = card.card_identifier;
                
                if (!uniqueCards[cardId]) {
                    // First occurrence - keep it
                    uniqueCards[cardId] = card;
                } else {
                    // Compare percentages
                    const newPercentage = parseFloat((card.percentage_in_archetype || '0').toString().replace(',', '.'));
                    const existingPercentage = parseFloat((uniqueCards[cardId].percentage_in_archetype || '0').toString().replace(',', '.'));
                    
                    // Only replace if new percentage is strictly HIGHER
                    if (newPercentage > existingPercentage) {
                        uniqueCards[cardId] = card;
                    }
                    // If same percentage, keep existing (do nothing)
                }
            }
            
            deckCards = Object.values(uniqueCards);
            console.log('[autoComplete] After deduplication:', deckCards.length, 'unique card IDs');
            
            // Step 2: Sort by percentage (descending)
            deckCards.sort((a, b) => {
                const percentageA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.'));
                const percentageB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.'));
                return percentageB - percentageA;
            });
            
            // Step 3: Build the deck
            let totalCards = 0;
            const addedCardIdentifiers = new Set(); // CRITICAL: Track by identifier to prevent any duplicates
            
            // Find the best Ace Spec (highest percentage)
            const aceSpecCards = deckCards.filter(c => c.is_ace_spec === 'Yes' || c.is_ace_spec === true);
            
            if (aceSpecCards.length > 0) {
                const bestAceSpec = aceSpecCards[0]; // First after sorting = highest percentage
                const cardId = bestAceSpec.card_identifier;
                
                // Add Ace Spec with exactly 1 copy
                myDeck.push({
                    identifier: cardId,
                    name: bestAceSpec.card_name,
                    count: 1,
                    maxCount: 1,
                    imageUrl: bestAceSpec.image_url || '',
                    type: bestAceSpec.type || '',
                    setCode: bestAceSpec.set_code || '',
                    setNumber: bestAceSpec.set_number || '',
                    setName: bestAceSpec.set_name || '',
                    percentage_in_archetype: bestAceSpec.percentage_in_archetype || '0',
                    is_ace_spec: true
                });
                
                addedCardIdentifiers.add(cardId);
                totalCards += 1;
                console.log('[autoComplete] Added Ace Spec:', bestAceSpec.card_name, '(ID:', cardId + ')');
            } else {
                console.log('[autoComplete] No Ace Spec found for archetype:', selectedDeck);
            }
            
            // Add remaining cards until 60 total cards
            for (const card of deckCards) {
                if (totalCards >= 60) break;
                
                const cardId = card.card_identifier;
                
                // Skip if already added
                if (addedCardIdentifiers.has(cardId)) {
                    continue;
                }
                
                // Skip Ace Spec cards (already handled the best one)
                if (card.is_ace_spec === 'Yes' || card.is_ace_spec === true) {
                    continue;
                }
                
                // Calculate recommended count
                const totalCount = parseFloat(card.total_count) || 1;
                const deckCount = parseFloat(card.deck_count) || 1;
                const avgCount = totalCount / deckCount;
                const recommendedCount = Math.round(avgCount);
                const count = Math.min(Math.max(1, recommendedCount), 4, 60 - totalCards);
                
                if (count > 0) {
                    myDeck.push({
                        identifier: cardId,
                        name: card.card_name,
                        count: count,
                        maxCount: 4,
                        imageUrl: card.image_url || '',
                        type: card.type || '',
                        setCode: card.set_code || '',
                        setNumber: card.set_number || '',
                        setName: card.set_name || '',
                        percentage_in_archetype: card.percentage_in_archetype || '0',
                        is_ace_spec: false
                    });
                    
                    addedCardIdentifiers.add(cardId);
                    totalCards += count;
                }
            }
            
            console.log('[autoComplete] Finished with', totalCards, 'total cards');
            console.log('[autoComplete] myDeck has', myDeck.length, 'unique card entries');
            console.log('[autoComplete] addedCardIdentifiers has', addedCardIdentifiers.size, 'unique IDs');
            
            updateDeckDisplay();
        }
        
        function exportToPokemonLive() {
            if (myDeck.length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            let exportText = 'Pok√©mon: \n';
            let trainerText = 'Trainer: \n';
            let energyText = 'Energy: \n';
            
            myDeck.forEach(card => {
                // Format: Anzahl Kartenname Set Set-Nummer
                const setInfo = (card.setCode && card.setNumber) 
                    ? `${card.setCode} ${card.setNumber}` 
                    : '';
                const line = `${card.count} ${card.name} ${setInfo}`.trim() + '\n';
                
                // Determine card type dynamically using getCardType()
                const cardType = card.type || getCardType(card.name);
                
                // Trainer cards: Supporter, Item, Tool, Stadium
                if (cardType === 'Supporter' || cardType === 'Item' || cardType === 'Tool' || cardType === 'Stadium' || cardType === 'Trainer') {
                    trainerText += line;
                }
                // Energy cards: Energy, Special Energy
                else if (cardType === 'Energy' || cardType === 'Special Energy' || card.name.includes('Energy') || card.name.includes('energie')) {
                    energyText += line;
                }
                // Everything else is Pokemon
                else {
                    exportText += line;
                }
            });
            
            const fullExport = exportText + '\n' + trainerText + '\n' + energyText;
            
            navigator.clipboard.writeText(fullExport).then(() => {
                alert('‚úÖ Deckliste wurde in die Zwischenablage kopiert!\n\nF√ºge sie jetzt in Pokemon Live ein.');
            }).catch(err => {
                prompt('Kopiere diese Deckliste:', fullExport);
            });
        }
        
        function getCardType(cardName) {
            /**
             * Determines card type based on all_cards_database.csv
             * Falls back to keyword matching if not found in database
             * WICHTIG: Basic Energy Namen m√ºssen ZUERST gepr√ºft werden!
             */
            const name = cardName.toLowerCase();
            
            const basicEnergyNames = [
                'grass energy',
                'fire energy',
                'water energy',
                'lightning energy',
                'psychic energy',
                'fighting energy',
                'darkness energy',
                'metal energy',
                'fairy energy',
                'dragon energy'
            ];
            const specialEnergyNames = [
                'telepath'
            ];
            
            // FIRST: Check for basic energies (BEFORE database lookup!)
            if (basicEnergyNames.includes(name)) {
                return 'Energy';
            }
            
            // Special energies
            if (specialEnergyNames.includes(name)) {
                return 'Special Energy';
            }
            
            // Now try to get from database
            if (cardTypeDatabase.has(cardName)) {
                const dbType = cardTypeDatabase.get(cardName);
                
                // Map database types to our categories
                if (dbType === 'Supporter') return 'Supporter';
                if (dbType === 'Stadium') return 'Stadium';
                if (dbType === 'Item') return 'Item';
                if (dbType === 'Tool') return 'Tool';
                
                // Pokemon types (e.g., "GBasic", "WStage 1", "PBasic", etc.)
                if (dbType && (dbType.includes('Basic') || dbType.includes('Stage') || dbType.includes('V') || dbType.includes('VMAX'))) {
                    return 'Pokemon';
                }
                
                // Energy types from database
                if (dbType && dbType.includes('Energy')) {
                    if (dbType.includes('Special')) return 'Special Energy';
                    return 'Energy';
                }
            }
            
            // Fallback: keyword matching for remaining energy cards
            if (name.endsWith('energy') && !name.includes('special')) {
                return 'Energy';
            }
            
            // Energy cards
            if (name.includes('energy') || name.includes('energie')) {
                if (name.includes('special energy') || name.includes('blend') || name.includes('aurora') || 
                    name.includes('prism') || name.includes('rainbow') || name.includes('crystal') ||
                    name.includes('double colorless') || name.includes('triple') || name.includes('twin') ||
                    name.includes('fusion')) {
                    return 'Special Energy';
                }
                return 'Energy';
            }
            
            // Default: Pokemon
            return 'Pokemon';
        }
        
        function sortCardsByType(cards) {
            /**
             * Sort cards by:
             * 1. Pokemon by Element (G, R, W, L, P, F, D, M, N, C)
             * 2. Within each element by Evolution (Basic, Stage1, Stage2)
             * 3. Then Trainer cards (Supporter, Item, Tool, Stadium)
             * 4. Then Energy cards (Special Energy, Basic Energy)
             */
            const elementOrder = {
                'G': 1,  // Grass
                'R': 2,  // Fire
                'W': 3,  // Water
                'L': 4,  // Lightning
                'P': 5,  // Psychic
                'F': 6,  // Fighting
                'D': 7,  // Darkness
                'M': 8,  // Metal
                'N': 9,  // Dragon
                'C': 10  // Colorless
            };
            
            const evolutionOrder = {
                'Basic': 1,
                'Stage1': 2,
                'Stage2': 3
            };
            
            const typeOrder = {
                'Pokemon': 1,
                'Supporter': 2,
                'Item': 3,
                'Tool': 4,
                'Stadium': 5,
                'Special Energy': 6,
                'Energy': 7,
                'Trainer': 3  // Fallback for generic "Trainer" types
            };
            
            // Helper function to determine card category
            function getCategory(card) {
                const cardType = card.type || card.card_type || '';
                const cardName = card.card_name || card.name || '';
                
                // Check if it's a Pokemon (type starts with element letter)
                if (cardType && cardType.charAt(0).match(/[GRWLPFDMNC]/)) {
                    return 'Pokemon';
                }
                
                // Check exact matches for trainer types
                if (cardType === 'Supporter') return 'Supporter';
                if (cardType === 'Item') return 'Item';
                if (cardType === 'Tool') return 'Tool';
                if (cardType === 'Stadium') return 'Stadium';
                if (cardType === 'Trainer') return 'Item';  // Generic trainer = Item
                
                // Check for energy
                if (cardType === 'Energy' || cardType === 'Special Energy') {
                    return cardType;
                }
                if (cardName.toLowerCase().includes('energy')) {
                    if (cardName.toLowerCase().includes('special') || 
                        cardName.toLowerCase().match(/(blend|aurora|prism|rainbow|crystal|double colorless|triple|twin|fusion|jet|enriching)/)) {
                        return 'Special Energy';
                    }
                    return 'Energy';
                }
                
                // Fallback: Use getCardType if available
                return getCardType(cardName);
            }
            
            return cards.sort((a, b) => {
                const categoryA = getCategory(a);
                const categoryB = getCategory(b);
                
                // Get type order for both cards
                const orderA = typeOrder[categoryA] || 99;
                const orderB = typeOrder[categoryB] || 99;
                
                // FIRST: Sort by main category (Pokemon vs Supporter vs Item vs Tool vs Stadium vs Energy)
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // SECOND: Both are Pokemon - sort by element and evolution
                if (categoryA === 'Pokemon' && categoryB === 'Pokemon') {
                    // Get element and evolution from 'type' or 'card_type' field (e.g., "GBasic", "RStage 1", "WStage 2")
                    const cardTypeA = a.type || a.card_type || '';
                    const cardTypeB = b.type || b.card_type || '';
                    
                    const elementA = cardTypeA.charAt(0);
                    const elementB = cardTypeB.charAt(0);
                    // Remove spaces from evolution stages (e.g., "Stage 1" -> "Stage1")
                    const evolutionA = cardTypeA.substring(1).replace(/\s+/g, '');
                    const evolutionB = cardTypeB.substring(1).replace(/\s+/g, '');
                    
                    const elemOrderA = elementOrder[elementA] || 99;
                    const elemOrderB = elementOrder[elementB] || 99;
                    
                    // Sort by element
                    if (elemOrderA !== elemOrderB) {
                        return elemOrderA - elemOrderB;
                    }
                    
                    // Within same element, sort by evolution
                    const evolOrderA = evolutionOrder[evolutionA] || 99;
                    const evolOrderB = evolutionOrder[evolutionB] || 99;
                    
                    if (evolOrderA !== evolOrderB) {
                        return evolOrderA - evolOrderB;
                    }
                    
                    // Within same evolution, sort by percentage (highest first)
                    if (a.percentage_in_archetype && b.percentage_in_archetype) {
                        const percA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                        const percB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                        if (percA !== percB) {
                            return percB - percA;
                        }
                    }
                    
                    // Finally sort by name
                    const nameA = a.card_name || a.name || '';
                    const nameB = b.card_name || b.name || '';
                    return nameA.localeCompare(nameB);
                }
                
                // THIRD: Same non-Pokemon type - sort by percentage within category
                if (a.percentage_in_archetype && b.percentage_in_archetype) {
                    const percA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                    const percB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                    if (percA !== percB) {
                        return percB - percA;
                    }
                }
                
                // Finally sort by name
                const nameA = a.card_name || a.name || '';
                const nameB = b.card_name || b.name || '';
                return nameA.localeCompare(nameB);
            });
        }
        
        function isTrainerCard(cardName) {
            const cardType = getCardType(cardName);
            return cardType !== 'Pokemon' && cardType !== 'Energy';
        }
        
        function showError(message) {
            const cardsBody = document.getElementById('cardsBody');
            cardsBody.innerHTML = `<tr><td colspan="6"><div class="error">${message}</div></td></tr>`;
        }
        
        function generateDeckImage() {
            if (myDeck.length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            const modal = document.getElementById('imageViewModal');
            const grid = document.getElementById('compactCardGrid');
            
            // Sort cards using the standard sorting function
            const sortedCards = sortCardsByType([...myDeck]);
            
            grid.innerHTML = sortedCards.map(card => {
                const imageUrl = card.imageUrl || '';
                const count = card.count;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" data-image-url="${imageUrl}" data-card-name="${card.name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <div class="compact-badge" style="position: static; margin-top: 10px;">${count}</div>
                        </div>
                    `;
                }
            }).join('');
            
            modal.classList.add('show');
        }
        
        function fixImageUrl(card) {
            /**
             * Korrigiert image URLs f√ºr japanische Karten
             * Japanische Karten haben leer set_name und falsche URL-Parameter:
             * - tpci -> tpc
             * - EN -> JP
             * - Kartennummer muss 3-stellig sein (74 -> 074)
             */
            if (!card || !card.image_url && !card.imageUrl) return '';
            
            const imageUrl = card.image_url || card.imageUrl;
            const setName = card.set_name || card.setName || '';
            const setCode = card.set_code || card.setCode || '';
            const setNumber = card.set_number || card.setNumber || '';
            
            // Pr√ºfe ob japanische Karte (set_name ist leer)
            if (!setName || setName.trim() === '') {
                // Das ist wahrscheinlich eine japanische Karte
                let url = imageUrl;
                
                // Ersetze tpci mit tpc (zur Japanese Collection)
                url = url.replace('/tpci/', '/tpc/');
                
                // Ersetze _R_EN_ mit _R_JP_ (English -> Japanese)
                url = url.replace(/_R_EN_/, '_R_JP_');
                
                // Padde set_number mit 0 (M3_41 -> M3_041)
                if (setCode && setNumber) {
                    const paddedNumber = setNumber.toString().padStart(3, '0');
                    // Ersetze die alte Nummer mit der neuen √ºber Regex
                    url = url.replace(RegExp(`/${setCode}_(\\d+)_`), `/${setCode}_${paddedNumber}_`);
                }
                
                console.log('[fixImageUrl] Japanese card:', card.name || card.card_name, 'Original:', imageUrl, 'Fixed:', url);
                return url;
            }
            
            return imageUrl;
        }
        
        function generateFilteredCardsImage() {
            // Generate image view for filtered cards list
            if (!filteredCards || filteredCards.length === 0) {
                alert('Keine Karten zum Anzeigen! Bitte Filter anwenden.');
                return;
            }
            
            const modal = document.getElementById('filteredCardsModal');
            const grid = document.getElementById('filteredCardGrid');
            
            // Sort cards by type before displaying
            const sortedCards = sortCardsByType([...filteredCards]);
            
            grid.innerHTML = sortedCards.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <div class="compact-badge" style="position: static; margin-top: 10px;">${count}</div>
                        </div>
                    `;
                }
            }).join('');
            
            modal.classList.add('show');
        }
        
        function generateDeckCardsImage() {
            // Generate image view for current deck's card list
            if (!currentDeckCards || currentDeckCards.length === 0) {
                alert('Bitte w√§hle zuerst ein Deck aus!');
                return;
            }
            
            const modal = document.getElementById('imageViewModal');
            const grid = document.getElementById('compactCardGrid');
            
            // Sort cards using the standard sorting function
            const sortedCards = sortCardsByType([...currentDeckCards]);
            
            grid.innerHTML = sortedCards.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <div class="compact-badge" style="position: static; margin-top: 10px;">${count}</div>
                        </div>
                    `;
                }
            }).join('');
            
            modal.classList.add('show');
        }
        
        function copyAllCardsData() {
            // Copy all cards with set and number to clipboard
            if (!currentDeckCards || currentDeckCards.length === 0) {
                alert('Bitte w√§hle zuerst ein Deck aus!');
                return;
            }
            
            // Format: "Anzahl Kartenname (Set Nummer)"
            const cardsList = currentDeckCards.map(card => {
                const count = card.max_count || 1;
                const cardName = card.card_name || '';
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                // Format: "1x Pikachu (SVP 001)"
                if (setCode && setNumber) {
                    return `${count}x ${cardName} (${setCode} ${setNumber})`;
                } else if (setNumber) {
                    return `${count}x ${cardName} (${setNumber})`;
                } else {
                    return `${count}x ${cardName}`;
                }
            }).join('\n');
            
            // Copy to clipboard
            navigator.clipboard.writeText(cardsList).then(() => {
                alert(`‚úÖ ${currentDeckCards.length} Karten kopiert!`);
            }).catch(err => {
                console.error('Error copying to clipboard:', err);
                // Fallback: Use textarea approach
                const textarea = document.createElement('textarea');
                textarea.value = cardsList;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`‚úÖ ${currentDeckCards.length} Karten kopiert!`);
            });
        }
        
        function closeImageView() {
            const modal = document.getElementById('imageViewModal');
            modal.classList.remove('show');
        }
        
        function closeFiltedCardsModal() {
            const modal = document.getElementById('filteredCardsModal');
            modal.classList.remove('show');
        }
    </script>
    
    <!-- Image View Modal -->
    <div id="imageViewModal" class="image-view-modal" onclick="if(event.target === this) closeImageView()">
        <div class="image-view-content">
            <div class="image-view-header">
                <h3>üé® Alle Karten √úbersicht</h3>
                <button class="image-view-close" onclick="closeImageView()">‚úï</button>
            </div>
            <div id="compactCardGrid" class="compact-card-grid"></div>
        </div>
    </div>
    <!-- Version: 2026-02-05 09:25 -->
        </div>
        </div>
        
        <!-- Tab 2: Karten-Filter -->
        <div id="karten-filter" class="tab-content">
            <div class="container">
                <div class="header">
                    <h1>üß∞ Karten-Filter</h1>
                    <p>Filtere alle gescrapten Karten nach Set und Kartentyp. Perfekt, um z. B. alle ben√∂tigten Karten aus einem Set zu sehen.</p>
                </div>
                
                <div class="card-filter-section" id="cardFilterSection">
                    <div class="filter-row">
                        <div class="control-group">
                            <label for="setFilterSelect">üì¶ Set</label>
                            <select id="setFilterSelect">
                                <option value="">Alle Sets</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="cardSearchInput">üîç Kartensuche</label>
                            <div style="position: relative;">
                                <input type="text" id="cardSearchInput" placeholder="Kartenname eingeben..." oninput="handleCardSearchInput()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                <div id="cardSearchSuggestions" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-top: none; border-radius: 0 0 8px 8px; max-height: 300px; overflow-y: auto; z-index: 1000; display: none; box-shadow: 0 4px 6px rgba(0,0,0,0.1);"></div>
                            </div>
                        </div>
                        <div class="control-group">
                            <label for="cardTypeFiltersContainer">üß© Kartentyp (Mehrfachauswahl)</label>
                            <div id="cardTypeFiltersContainer" style="position: relative;"></div>
                        </div>
                    </div>

                    <div class="filter-actions">
                        <button class="btn btn-primary" onclick="applyCardFilters()">üîé Anzeigen</button>
                        <button class="btn btn-secondary" onclick="clearCardFilters()">üßπ Clear</button>
                        <button class="btn btn-success" onclick="copyFilteredCards()">üìã Copy</button>
                        <button class="btn btn-warning" onclick="generateFilteredCardsImage()">ÔøΩ Grid</button>
                    </div>

                    <div class="filter-summary">
                        <span style="font-size: 1.1em; color: #333;"><span id="filteredCardCount">0 Karten</span><span id="filteredCardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
                    </div>

                    <div class="cards-table">
                        <table>
                            <thead>
                                <tr>
                                    <th class="col-image">Bild</th>
                                    <th>Kartenname</th>
                                    <th>Set</th>
                                    <th>Nummer</th>
                                    <th>Typ</th>
                                    <th>Max Anzahl</th>
                                </tr>
                            </thead>
                            <tbody id="filteredCardsBody">
                                <tr>
                                    <td colspan="6" class="loading">Bitte Filter ausw√§hlen...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Search Results: All Artwork Versions Section -->
                    <div id="cardArtworkSection" style="display: none; margin-top: 40px;">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">üé® Alle Versionen dieser Karte</h3>
                        
                    <!-- Rarity Filter -->
                        <div style="margin-bottom: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                            <button class="btn btn-sm btn-primary" onclick="filterCardArtworks('all')" id="rarityAllBtn" style="flex: 1 1 0%; min-width: 100px;">Alle</button>
                            <button class="btn btn-sm btn-secondary" onclick="filterCardArtworks('low')" id="rarityLowBtn" style="flex: 1 1 0%; min-width: 100px;">Low Rarity</button>
                            <button class="btn btn-sm btn-secondary" onclick="filterCardArtworks('mid')" id="rarityMidBtn" style="flex: 1 1 0%; min-width: 100px;">Mid Rarity</button>
                            <button class="btn btn-sm btn-secondary" onclick="filterCardArtworks('high')" id="rarityHighBtn" style="flex: 1 1 0%; min-width: 100px;">High Rarity</button>
                        </div>
                        
                        <!-- Artwork Grid -->
                        <div id="artworkGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px; margin-top: 15px;">
                            <!-- Will be populated by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <!-- Filtered Cards Modal -->
                <div id="filteredCardsModal" class="image-view-modal" onclick="if(event.target === this) closeFiltedCardsModal()">
                    <div class="image-view-content">
                        <div class="image-view-header">
                            <h3>üé® Gefilterte Karten √úbersicht</h3>
                            <button class="image-view-close" onclick="closeFiltedCardsModal()">‚úï</button>
                        </div>
                        <div id="filteredCardGrid" class="compact-card-grid"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 3: City League Development -->
        <div id="city-league" class="tab-content">
            <div class="container">
                <div class="header">
                    <h1>üáØüáµ City League Development</h1>
                </div>
                <div id="cityLeagueContent" style="padding: 30px; background: #ffffff;">
                    <div style="text-align: center; padding: 40px; color: #999;">L√§dt...</div>
                </div>
            </div>
        </div>
        
        <!-- Tab 4: Limitless Online Comparison -->
        <div id="limitless-online" class="tab-content">
            <div class="container">
                <div class="header">
                    <h1>üéÆ Limitless Online Comparison</h1>
                </div>
                <div id="limitlessContent" style="padding: 30px; background: #ffffff;">
                    <div style="text-align: center; padding: 40px; color: #999;">L√§dt...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tabs
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Deactivate all buttons
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
                
                // Load Limitless comparison if needed
                if (tabName === 'limitless-online') {
                    loadLimitlessComparison();
                }
            }
            
            // Activate selected button
            event.target.classList.add('active');
        }
        
        function loadLimitlessComparison() {
            const limitlessContent = document.getElementById('limitlessContent');
            
            fetch(BASE_PATH + 'data/limitless_online_decks_comparison.html')
                .then(response => response.text())
                .then(html => {
                    // Parse the loaded HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Extract the container content
                    const container = doc.querySelector('.container');
                    if (container) {
                        // Get everything after the h1 title
                        const contentDivs = Array.from(container.children).slice(1);
                        
                        // Create a wrapper with the limitless-comparison class for styling
                        const wrapper = document.createElement('div');
                        wrapper.className = 'limitless-comparison';
                        
                        // Add content to wrapper
                        contentDivs.forEach(el => {
                            const clone = el.cloneNode(true);
                            wrapper.appendChild(clone);
                        });
                        
                        // Clear and set content
                        limitlessContent.innerHTML = '';
                        limitlessContent.appendChild(wrapper);
                    } else {
                        limitlessContent.innerHTML = '<div style="color: #e74c3c; padding: 20px;">Fehler beim Laden der Vergleichsdaten</div>';
                    }
                })
                .catch(err => {
                    console.error('Error loading comparison:', err);
                    limitlessContent.innerHTML = `
                        <div style="color: #e74c3c; padding: 20px;">
                            <strong>Fehler:</strong> Die Vergleichs-HTML konnte nicht geladen werden.
                            <br><small>${err.message}</small>
                        </div>
                    `;
                });
        }
    </script>
</body>
</html>
