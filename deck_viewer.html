<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:,">
    <title>Pokemon Deck Viewer & Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 0;
        }
        
        /* Tab Navigation */
        .tab-navigation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 10px 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .tab-btn {
            padding: 12px 24px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .tab-btn.active {
            background: white;
            color: #667eea;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .content-wrapper {
            margin-top: 60px;
            padding: 20px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 3px solid #667eea;
        }
        
        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .control-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .variant-selector {
            background: #e8f4f8;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .variant-selector h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .variant-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            cursor: pointer;
        }

        .variant-toggle {
            display: inline-block;
            position: relative;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
            border: 3px solid #1d3557;
            cursor: pointer;
            transition: transform 0.3s ease;
            overflow: hidden;
        }

        /* Mittlerer schwarzer Ring */
        .variant-toggle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 6px;
            background: #1d3557;
            z-index: 2;
        }

        /* Wei√üer Knopf in der Mitte */
        .variant-toggle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 14px;
            height: 14px;
            background: white;
            border: 3px solid #1d3557;
            border-radius: 50%;
            z-index: 3;
            transition: all 0.3s ease;
        }

        /* Geschlossener Pok√©ball */
        .variant-toggle.collapsed {
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
        }

        /* Offener Pok√©ball - H√§lften auseinander */
        .variant-toggle:not(.collapsed) {
            background: linear-gradient(to bottom, 
                #e63946 0%, #e63946 35%, 
                transparent 35%, transparent 65%, 
                white 65%, white 100%);
        }

        .variant-toggle:not(.collapsed)::after {
            box-shadow: 0 0 0 4px rgba(29, 53, 87, 0.2);
        }

        .variant-toggle:hover {
            transform: scale(1.1);
            filter: brightness(1.1);
        }
        
        .variant-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .variant-search-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .variant-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .variant-checkbox {
            display: flex;
            align-items: center;
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .variant-checkbox:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .variant-checkbox input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        .variant-checkbox.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .deck-select-wrapper {
            position: relative;
        }
        
        .deck-select-wrapper input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
        }
        
        .deck-select-wrapper input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .stats-section {
            padding: 30px;
            background: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        
        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }
        
        .matchups {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .matchup-box {
            padding: 20px;
            border-radius: 10px;
            background: #f8f9fa;
        }
        
        .matchup-box h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .matchup-box.good {
            border-left: 5px solid #28a745;
        }
        
        .matchup-box.bad {
            border-left: 5px solid #dc3545;
        }
        
        .matchup-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .cards-section {
            padding: 30px;
            background: #f8f9fa;
        }
        
        .cards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .cards-table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0 15px 0;
            cursor: pointer;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .cards-table-header:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .cards-header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .cards-toggle {
            display: inline-block;
            position: relative;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
            border: 3px solid #1d3557;
            cursor: pointer;
            transition: transform 0.3s ease;
            overflow: hidden;
            flex-shrink: 0;
        }

        .cards-toggle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100%;
            height: 5px;
            background: #1d3557;
            z-index: 2;
        }

        .cards-toggle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: white;
            border: 3px solid #1d3557;
            border-radius: 50%;
            z-index: 3;
            transition: all 0.3s ease;
        }

        .cards-toggle.collapsed {
            background: linear-gradient(to bottom, #e63946 0%, #e63946 50%, white 50%, white 100%);
        }

        .cards-toggle:not(.collapsed) {
            background: linear-gradient(to bottom, 
                #e63946 0%, #e63946 35%, 
                transparent 35%, transparent 65%, 
                white 65%, white 100%);
        }

        .cards-toggle:not(.collapsed)::after {
            box-shadow: 0 0 0 3px rgba(29, 53, 87, 0.2);
        }

        .cards-toggle:hover {
            transform: scale(1.1);
            filter: brightness(1.1);
        }
        
        .card-search-input {
            width: 100%;
            max-width: 400px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .card-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .deck-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .deck-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            max-height: 800px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .card-visual {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            background: #f0f0f0;
        }
        
        .card-visual:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        
        .card-visual img {
            width: 90px;
            height: 126px;
            display: block;
            object-fit: cover;
        }
        
        .card-visual .card-count-badge {
            position: absolute;
            top: 3px;
            right: 3px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
            z-index: 2;
        }
        
        .card-visual .card-name-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: white;
            padding: 10px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        /* Compact image view f√ºr Mobilansicht */
        .compact-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 4px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
            max-height: 600px;
            overflow-y: auto;
        }
        
        .compact-card {
            position: relative;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.15s, box-shadow 0.15s;
            background: #f0f0f0;
        }
        
        .compact-card:active {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .compact-card img {
            width: 50px;
            height: 70px;
            display: block;
            object-fit: cover;
        }
        
        .compact-card .compact-badge {
            position: absolute;
            top: 1px;
            right: 1px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 9px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
            z-index: 2;
        }
        
        .image-view-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            overflow-y: auto;
            padding: 10px;
        }
        
        .image-view-modal.show {
            display: flex;
            flex-direction: column;
        }
        
        .image-view-content {
            background: white;
            border-radius: 15px;
            padding: 20px;
            max-width: 500px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            margin: auto;
        }
        
        .image-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }
        
        .image-view-header h3 {
            margin: 0;
            color: #333;
        }
        
        .image-view-close {
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .image-view-close:hover {
            background: #c82333;
        }
        
        .card-visual.no-image {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 210px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: center;
        }
        
        .card-visual.no-image .fallback-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .card-visual.no-image .fallback-icon {
            font-size: 3em;
        }
        
        .cards-table {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        th.col-image {
            width: 100px;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .card-thumbnail {
            width: 80px;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .card-thumbnail:hover {
            transform: scale(1.1);
        }
        
        .card-thumbnail-placeholder {
            width: 80px;
            height: 110px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2em;
        }
        
        tbody tr:hover {
            background: #f8f9fa;
        }
        
        .card-count {
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
        }
        
        .deck-builder {
            padding: 30px;
            background: white;
            border-top: 3px solid #667eea;
        }
        
        .deck-builder h2 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .builder-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .btn-warning {
            background: #ffc107;
            color: #333;
        }
        
        .btn-warning:hover {
            background: #e0a800;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 193, 7, 0.4);
        }
        
        .deck-list {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }

        .card-filter-section {
            padding: 30px;
            background: #ffffff;
            border-top: 3px solid #667eea;
        }

        .card-filter-section h2 {
            margin-bottom: 10px;
            color: #333;
        }

        .card-filter-section p {
            color: #666;
            margin-bottom: 20px;
        }

        .filtered-cards-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: none;
        }

        .filtered-cards-visual.show {
            display: block;
        }

        .filtered-cards-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }

        .filtered-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            max-height: 800px;
            overflow-y: auto;
            padding: 10px;
        }

        .filter-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-type-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .dropdown-container {
            position: relative;
            width: 100%;
        }

        .dropdown-button {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: #f8f9fa;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s;
        }

        .dropdown-button:hover {
            border-color: #667eea;
            background: #eef2ff;
        }

        .dropdown-button.open {
            border-color: #667eea;
            background: #eef2ff;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-top: none;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .dropdown-menu.open {
            max-height: 250px;
            overflow-y: auto;
        }

        .dropdown-menu label {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 15px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .dropdown-menu label:hover {
            background: #f8f9fa;
        }

        .dropdown-menu input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        #cardTypeFilters {
            display: none;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .filter-summary {
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }
        
        .deck-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }
        
        .deck-card-controls {
            display: flex;
            gap: 5px;
        }
        
        .deck-card-controls button {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .btn-add {
            background: #28a745;
            color: white;
        }
        
        .btn-remove {
            background: #dc3545;
            color: white;
        }
        
        .deck-summary {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            text-align: center;
        }
        
        .deck-summary h3 {
            font-size: 1.5em;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }
        
        .error {
            background: #dc3545;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .percentage-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .percentage-high {
            background: #28a745;
            color: white;
        }
        
        .percentage-medium {
            background: #ffc107;
            color: #333;
        }
        
        .percentage-low {
            background: #6c757d;
            color: white;
        }
        
        /* Limitless Online Comparison Styling */
        #limitlessContent {
            padding: 30px;
        }
        
        .limitless-comparison .meta-info {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            text-align: center;
        }
        
        .limitless-comparison .meta-info span {
            display: inline-block;
            margin: 0 15px;
            font-weight: bold;
        }
        
        .limitless-comparison .section {
            margin-bottom: 40px;
        }
        
        .limitless-comparison .section h2 {
            color: #34495e;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
            font-size: 1.3em;
        }
        
        .limitless-comparison .section h3 {
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .limitless-comparison .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .limitless-comparison .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .limitless-comparison .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .limitless-comparison .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .limitless-comparison .stat-card p {
            margin: 10px 0 0 0;
            font-size: 0.95em;
        }
        
        .limitless-comparison table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .limitless-comparison table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        .limitless-comparison table td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .limitless-comparison table tr:hover {
            background-color: #f8f9fa;
        }
        
        .limitless-comparison .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }
        
        .limitless-comparison .badge-new {
            background-color: #2ecc71;
            color: white;
        }
        
        .limitless-comparison .badge-disappeared {
            background-color: #e74c3c;
            color: white;
        }
        
        .limitless-comparison .badge-stable {
            background-color: #95a5a6;
            color: white;
        }
        
        .limitless-comparison .badge-up {
            background-color: #3498db;
            color: white;
        }
        
        .limitless-comparison .badge-down {
            background-color: #e67e22;
            color: white;
        }
        
        .limitless-comparison .positive {
            color: #27ae60;
            font-weight: bold;
        }
        
        .limitless-comparison .negative {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .limitless-comparison .neutral {
            color: #95a5a6;
        }
        
        .limitless-comparison .rank-change {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
        }
        
        .limitless-comparison .rank-up {
            background-color: #d4edda;
            color: #155724;
        }
        
        .limitless-comparison .rank-down {
            background-color: #f8d7da;
            color: #721c24;
        }
    </style>
</head>
<body>
    <!-- Tab Navigation -->
    <div class="tab-navigation">
        <button class="tab-btn active" onclick="switchTab('deck-viewer')">üÉè Deck Viewer & Builder</button>
        <button class="tab-btn" onclick="switchTab('karten-filter')">üß∞ Karten-Filter</button>
        <button class="tab-btn" onclick="switchTab('city-league')">üáØüáµ City League Development</button>
        <button class="tab-btn" onclick="switchTab('limitless-online')">üéÆ Limitless Online Comparison</button>
    </div>

    <div class="content-wrapper">
        <!-- Tab 1: Deck Viewer -->
        <div id="deck-viewer" class="tab-content active">
            <div class="container">
                <div class="header">
            <h1>ü¶Ö Pokemon Deck Viewer & Builder</h1>
            <p>Analyze and Build Decks</p>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label for="deckSearch">üîç Deck suchen:</label>
                    <input type="text" id="deckSearch" placeholder="Deck-Name eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                </div>
                <div class="control-group">
                    <label for="deckSelect">üéØ Deck Archetype w√§hlen:</label>
                    <select id="deckSelect" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                        <option value="">-- Bitte Deck ausw√§hlen --</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="filterSelect">ü¶Ç Karten Filter:</label>
                    <select id="filterSelect">
                        <option value="all">Alle Karten</option>
                        <option value="90">Karten in >90% der Decks (Core)</option>
                        <option value="70">Karten in >70% der Decks</option>
                        <option value="50">Karten in >50% der Decks</option>
                    </select>
                </div>
                <div class="control-group" style="order: -1; width: 100%;">
                    <label for="metaMainFilterDropdown">üåü Meta:</label>
                    <div class="custom-multiselect" id="metaMainFilterDropdown" tabindex="0" style="width: 100%; position: relative;">
                        <div class="multiselect-selected" id="metaMainFilterSelected" style="width: 100%; padding: 12px; border: 2px solid #667eea; border-radius: 8px; font-size: 16px; background: #f8f9fa; cursor: pointer; user-select: none;">Alle</div>
                        <div class="multiselect-options" id="metaMainFilterOptions" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: #fff; border: 2px solid #667eea; border-top: none; border-radius: 0 0 8px 8px; z-index: 10; max-height: 220px; overflow-y: auto;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="stats-section" id="statsSection" style="display: none;">
            <div class="variant-selector" id="variantSelector" style="display: none;">
                <div class="variant-header" onclick="toggleVariantSelector()">
                    <h3>üîÑ Weitere Deck-Varianten dazupacken:</h3>
                    <span class="variant-toggle collapsed" id="variantToggle"></span>
                </div>
                <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">
                    W√§hle zus√§tzliche Varianten aus, um mehr Karten-Optionen f√ºr dein Custom-Deck zu sehen
                </p>
                <input type="text" id="variantSearchInput" placeholder="üîç Varianten durchsuchen..." class="variant-search-input" oninput="onVariantSearchInput()">
                <div class="variant-options" id="variantOptions"></div>
            </div>
            
            <h2>üìä Deck Statistiken</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="label">Ranking</div>
                    <div class="value" id="statRanking">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Total Win Rate</div>
                    <div class="value" id="statWinRate">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">√ò Platzierung</div>
                    <div class="value" id="statMatches">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Vs Top 20</div>
                    <div class="value" id="statBalance">-</div>
                </div>
            </div>
            
            <div class="matchups" id="matchupsSection" style="display: none; margin-top: 30px;">
                <div style="margin-bottom: 20px; background: #f8f9fa; padding: 20px; border-radius: 8px;">
                    <h2 style="color: #2c3e50; margin-top: 0;">üéØ Matchup-Analyse</h2>
                    <h3 style="color: #667eea; margin-top: 10px; margin-bottom: 20px;" id="matchupsDeckTitle">Deck Name</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <!-- Best Matchups -->
                        <div>
                            <h4 style="color: #27ae60; margin-bottom: 10px;">‚úÖ Best Matchups</h4>
                            <table style="box-shadow: none; width: 100%;">
                                <tr style="background: #d4edda;">
                                    <th style="background: #27ae60; color: white; padding: 8px; text-align: left;">Opponent</th>
                                    <th style="background: #27ae60; color: white; padding: 8px; text-align: right;">Win Rate</th>
                                    <th style="background: #27ae60; color: white; padding: 8px; text-align: right;">Record</th>
                                </tr>
                                <tbody id="topMatchups"></tbody>
                            </table>
                        </div>
                        
                        <!-- Worst Matchups -->
                        <div>
                            <h4 style="color: #e74c3c; margin-bottom: 10px;">‚ùå Worst Matchups</h4>
                            <table style="box-shadow: none; width: 100%;">
                                <tr style="background: #f8d7da;">
                                    <th style="background: #e74c3c; color: white; padding: 8px; text-align: left;">Opponent</th>
                                    <th style="background: #e74c3c; color: white; padding: 8px; text-align: right;">Win Rate</th>
                                    <th style="background: #e74c3c; color: white; padding: 8px; text-align: right;">Record</th>
                                </tr>
                                <tbody id="worstMatchups"></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Opponent Analyzer -->
                    <div style="background: white; padding: 15px; border-radius: 5px; border: 2px solid #3498db; margin-top: 20px;">
                        <h4 style="margin-top: 0; color: #3498db;">üîç Select & Analyze Opponent Matchup</h4>
                        <label for="opponentSelect" style="display: block; margin-bottom: 8px; font-weight: bold;">Choose Opponent:</label>
                        <select id="opponentSelect" onchange="showMatchupAnalyzer(this.value)" style="width: 100%; padding: 10px; border: 1px solid #bbb; border-radius: 4px; font-size: 1em;">
                            <option value="">-- Select a deck --</option>
                        </select>
                        <div id="matchupAnalysisDetails" style="margin-top: 15px; display: none; background: #ecf0f1; padding: 15px; border-radius: 4px;"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="cards-section">
            <div class="cards-header">
                <h2>üÉè Karten Liste</h2>
                <span id="cardCount">0 Karten</span>
            </div>
            
            <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
                <button class="btn btn-warning" onclick="generateDeckCardsImage()" id="generateDeckCardsBtn" style="display: none;">üñºÔ∏è √úbersicht generieren</button>
                <button class="btn btn-primary" onclick="copyAllCardsData()" id="copyAllCardsBtn" style="display: none;">üìã Alles kopieren</button>
            </div>
        
            <!-- Deck Visualisierung -->
            <div class="deck-visual" id="deckVisual" style="display: none;">
                <h3>üé® Deck √úbersicht</h3>
                <div class="deck-grid" id="deckGrid">
                    <!-- Karten werden hier dynamisch eingef√ºgt -->
                </div>
            </div>
            
            <!-- Toggle f√ºr Karten-Tabelle -->
            <div class="cards-table-header" onclick="toggleCardsTable()">
                <div class="cards-header-left">
                    <span class="cards-toggle collapsed" id="cardsToggle"></span>
                    <h3>üìã Einzelne Karten</h3>
                </div>
            </div>
            
            <div id="cardsTableContent" style="display: none;">
                <input type="text" id="cardSearchInput" placeholder="üîç Karte suchen..." class="card-search-input" oninput="filterCards()" style="margin-bottom: 15px; width: 100%; max-width: 500px;">
                
                <div class="cards-table">
                    <table>
                        <thead>
                            <tr>
                                <th class="col-image">Bild</th>
                                <th>Anzahl</th>
                                <th>Kartenname</th>
                                <th>Set</th>
                                <th>Nummer</th>
                                <th>% in Archetype</th>
                                <th>Aktion</th>
                            </tr>
                        </thead>
                        <tbody id="cardsBody">
                            <tr>
                                <td colspan="7" class="loading">Bitte w√§hle ein Deck aus...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="deck-builder">
            <h2>üõ†Ô∏è Deck Builder (60 Karten)</h2>
            <div class="builder-controls">
                <button class="btn btn-primary" onclick="exportToPokemonLive()">üìã F√ºr Pokemon Live kopieren</button>
                <button class="btn btn-warning" onclick="generateDeckImage()">üñºÔ∏è Karten √úbersicht generieren</button>
                <button class="btn btn-secondary" onclick="clearDeck()">üóëÔ∏è Deck leeren</button>
                <button class="btn btn-success" onclick="autoComplete()">‚ö° Auto-Complete (60 Karten)</button>
            </div>
            
            <div class="deck-summary">
                <h3>Aktuell: <span id="deckCardCount">0</span> / 60 Karten</h3>
            </div>
            
            <div id="myDeckVisual" style="display: none;">
                <h3>üé¥ Dein Deck √úbersicht</h3>
                <div class="deck-grid" id="myDeckGrid"></div>
            </div>
            
            <div class="deck-list" id="deckList">
                <p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>
            </div>
        </div>
    </div>
    
    <script>
        // GitHub Pages base path detection
        const BASE_PATH = window.location.hostname.includes('github.io') ? '/HausiTCG/' : '/';
        
        // Global data storage - MUST be at the top before any functions
        let cardsData = [];
        let matchupsData = [];
        let matchupDetailsData = [];
        let cityLeagueData = [];
        let top20LimitlessArchetypes = [];
        let top10CityLeagueArchetypes = [];
        let limitlessDeckStats = {};
        let myDeck = [];
        let cardTypeDatabase = new Map();
        let filteredCards = [];
        let currentDeckCards = [];
        let currentMainDeckName = '';
        let limitlessMatchupData = {};

                        // Generate matchupDetailsData from cardsData (global)
                        function generateMatchupDetailsData() {
                            matchupDetailsData = [];
                            limitlessMatchupData = {};
                            console.log('Generated matchup details data from cardsData');
                        }

                        function buildLimitlessMatchupData(details = []) {
                            const result = {};
                            console.log('[buildLimitlessMatchupData] Processing', details.length, 'matchup details');
                            details.forEach(row => {
                                const deckName = row.deck_name || row.deck || '';
                                const opponent = row.opponent || row.opponent_deck || '';
                                if (!deckName || !opponent) return;

                                const winRateRaw = String(row.win_rate || '').replace('%', '').trim();
                                const winRateNum = parseFloat(winRateRaw.replace(',', '.'));
                                const winRateNumeric = Number.isNaN(winRateNum) ? 0 : winRateNum;
                                const winRateDisplay = winRateRaw ? `${winRateRaw}%` : '0%';

                                if (!result[deckName]) result[deckName] = {};
                                result[deckName][opponent] = {
                                    opponent_deck: opponent,
                                    win_rate: winRateDisplay,
                                    win_rate_numeric: winRateNumeric,
                                    record: row.record || '',
                                    total_games: parseInt(row.total_games || '0', 10) || 0
                                };
                            });
                            console.log('[buildLimitlessMatchupData] Built matchup data for', Object.keys(result).length, 'decks');
                            return result;
                        }
                // Load Limitless data from CSV (with cache-busting)
                async function loadMatchupsData() {
                    console.log('[loadMatchupsData] START');
                    try {
                        const timestamp = new Date().getTime();
                        const response = await fetch(`${BASE_PATH}data/limitless_online_decks.csv?t=${timestamp}`);
                        if (response.ok) {
                            const text = await response.text();
                            matchupsData = parseCSV(text);
                            console.log('Loaded Limitless decks - Entries:', matchupsData.length);
                            
                            // Load matchups data
                            let matchupsDetailsData = [];
                            try {
                                const matchupsUrl = `${BASE_PATH}data/limitless_online_decks_matchups.csv?t=${timestamp}`;
                                console.log('[loadMatchupsData] Fetching from:', matchupsUrl);
                                const matchupsResponse = await fetch(matchupsUrl);
                                console.log('[loadMatchupsData] Matchups response status:', matchupsResponse.status, matchupsResponse.ok);
                                if (matchupsResponse.ok) {
                                    const matchupsText = await matchupsResponse.text();
                                    console.log('[loadMatchupsData] Fetched CSV, parsing...');
                                    matchupsDetailsData = parseCSV(matchupsText);
                                    matchupDetailsData = matchupsDetailsData;
                                    console.log('[loadMatchupsData] Parsed', matchupsDetailsData.length, 'matchup rows');
                                    console.log('[loadMatchupsData] First row:', matchupsDetailsData[0]);
                                    limitlessMatchupData = buildLimitlessMatchupData(matchupsDetailsData);
                                    console.log('[loadMatchupsData] Built global limitlessMatchupData, decks:', Object.keys(limitlessMatchupData).length);
                                    console.log('[loadMatchupsData] First deck matchups:', Object.keys(limitlessMatchupData)[0], '->', Object.keys(limitlessMatchupData[Object.keys(limitlessMatchupData)[0]] || {}).length, 'opponents');
                                } else {
                                    console.warn('[loadMatchupsData] Matchups CSV not found (status:', matchupsResponse.status, ')');
                                }
                            } catch (e) {
                                console.warn('[loadMatchupsData] Catch error:', e);
                            }
                            
                            renderLimitlessTable(matchupsDetailsData);
                        } else {
                            console.warn('Limitless decks data not found - generating from cardsData');
                            generateMatchupsDataFallback();
                        }
                    } catch (error) {
                        console.error('Error loading matchups data:', error);
                        generateMatchupsDataFallback();
                    }
                }

        // Helper function to escape HTML entities
        function escapeHtml(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Loads cardsData from CSV (now global)
        async function loadCardsData() {
            try {
                const response = await fetch(BASE_PATH + 'data/unified_card_data.csv');
                if (response.ok) {
                    const text = await response.text();
                    cardsData = parseCSV(text);
                    console.log('Loaded cards data - Entries:', cardsData.length);
                } else {
                    console.warn('Cards data not found');
                }
            } catch (error) {
                console.error('Error loading cards data:', error);
            }
        }

        // Load data on page load
        document.addEventListener('DOMContentLoaded', async () => {
            await loadCardsData();
            await loadCityLeagueData();
            await loadMatchupsData();
            buildMetaOptionsFromCards();
            syncMetaSetCodeMapFromCards();
            populateDeckDropdown();  // Call after all data is loaded
            initializeCardFilterUI();
            renderMetaMainFilter();
            setupEventListeners();
        });

        // Refresh all data (reload from CSVs with cache-busting)
        function refreshAllData() {
            console.log('üîÑ Lade Daten neu mit cache-busting...');
            try {
                loadCityLeagueData();
                loadMatchupsData();
                console.log('‚úÖ Daten erfolgreich aktualisiert');
                alert('‚úÖ Comparison-Daten wurden aktualisiert!');
            } catch (error) {
                console.error('‚ùå Fehler beim Aktualisieren der Daten:', error);
                alert('‚ùå Fehler beim Aktualisieren der Daten');
            }
        }
                // --- Meta Filter (fixe Reihenfolge + optionale neue Metas) ---
                const metaMainOptions = [
                    { label: 'Alle', value: 'all' },
                    { label: 'City Leagues', value: 'city_leagues' },
                    { label: 'SVI - PFL', value: 'SVI-PFL' },
                    { label: 'SVI - MEG', value: 'SVI-MEG' },
                    { label: 'SVI - BLK/WHT', value: 'SVI-BLK' },
                    { label: 'SVI - DRI', value: 'SVI-DRI' },
                    { label: 'SVI - JTG', value: 'SVI-JTG' },
                    { label: 'BRS - PRE', value: 'BRS-PRE' },
                    { label: 'BRS - SSP', value: 'BRS-SSP' },
                    { label: 'BRS - SCR', value: 'BRS-SCR' },
                    { label: 'BRS - SFA', value: 'BRS-SFA' },
                    { label: 'BRS - TWM', value: 'BRS-TWM' },
                    { label: 'BRS - TEF', value: 'BRS-TEF' },
                    { label: 'BST - PAR', value: 'BST-PAR' },
                ];

                const metaFieldKeys = ['meta', 'meta_code', 'meta_group', 'meta_name'];
                const metaSetCodeMap = {
                    'SVI-PFL': new Set(),
                    'SVI-MEG': new Set(),
                    'SVI-BLK': new Set(),
                    'SVI-DRI': new Set(),
                    'SVI-JTG': new Set(),
                    'BRS-PRE': new Set(),
                    'BRS-SSP': new Set(),
                    'BRS-SCR': new Set(),
                    'BRS-SFA': new Set(),
                    'BRS-TWM': new Set(),
                    'BRS-TEF': new Set(),
                    'BST-PAR': new Set(),
                };

                let metaMainSelected = new Set(['all']); // Default: alle

                function getCardMetaValue(card) {
                    for (const key of metaFieldKeys) {
                        const value = card[key];
                        if (value && String(value).trim()) {
                            return String(value).trim();
                        }
                    }
                    return '';
                }

                function buildMetaOptionsFromCards() {
                    // Optional: neue Meta-Keys direkt nach City Leagues einf√ºgen, falls Daten eine Meta-Spalte liefern
                    const existing = new Set(metaMainOptions.map(opt => opt.value));
                    const discovered = new Set();
                    cardsData.forEach(card => {
                        const metaValue = getCardMetaValue(card);
                        if (metaValue && !existing.has(metaValue)) {
                            discovered.add(metaValue);
                        }
                    });
                    if (discovered.size > 0) {
                        const insertIndex = metaMainOptions.findIndex(opt => opt.value === 'city_leagues') + 1;
                        const ordered = Array.from(discovered).sort();
                        metaMainOptions.splice(insertIndex, 0, ...ordered.map(m => ({ label: m, value: m })));
                    }
                    console.log('Meta options:', metaMainOptions.map(o => o.value));
                }

                function syncMetaSetCodeMapFromCards() {
                    const hasMetaField = cardsData.some(card => getCardMetaValue(card));
                    if (hasMetaField) {
                        return;
                    }
                    if (metaSetCodeMap['SVI-PFL'].size === 0) {
                        cardsData.forEach(card => {
                            if (card.set_code && String(card.set_code).trim()) {
                                metaSetCodeMap['SVI-PFL'].add(String(card.set_code).trim());
                            }
                        });
                    }
                }

                function renderMetaMainFilter() {
                    const selectedDiv = document.getElementById('metaMainFilterSelected');
                    const optionsDiv = document.getElementById('metaMainFilterOptions');
                    if (!selectedDiv || !optionsDiv) return;

                    // Default: only 'all' selected
                    metaMainSelected = new Set(['all']);
                    updateMetaMainSelectedText();

                    optionsDiv.innerHTML = '';
                    // --- 'Alle' Checkbox ---
                    const allLabel = document.createElement('label');
                    allLabel.style.display = 'block';
                    allLabel.style.padding = '8px 12px';
                    allLabel.style.cursor = 'pointer';
                    const allCheckbox = document.createElement('input');
                    allCheckbox.type = 'checkbox';
                    allCheckbox.value = 'all';
                    allCheckbox.checked = true;
                    allCheckbox.style.marginRight = '8px';
                    allCheckbox.addEventListener('change', () => {
                        if (allCheckbox.checked) {
                            metaMainSelected = new Set(metaMainOptions.map(opt => opt.value));
                            // Check all other checkboxes
                            optionsDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = true; });
                        } else {
                            metaMainSelected.clear();
                            // Uncheck all other checkboxes
                            optionsDiv.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = false; });
                        }
                        updateMetaMainSelectedText();
                        populateDeckDropdown(); // Re-filter deck dropdown
                        updateCardsDisplay();
                    });
                    allLabel.appendChild(allCheckbox);
                    allLabel.appendChild(document.createTextNode('Alle'));
                    optionsDiv.appendChild(allLabel);
                    // --- Other Meta Checkboxes ---
                    metaMainOptions.filter(opt => opt.value !== 'all').forEach((opt, idx) => {
                        const label = document.createElement('label');
                        label.style.display = 'block';
                        label.style.padding = '8px 12px';
                        label.style.cursor = 'pointer';
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.value = opt.value;
                        checkbox.checked = false; // Start unchecked
                        checkbox.style.marginRight = '8px';
                        checkbox.addEventListener('change', () => {
                            if (checkbox.checked) {
                                metaMainSelected.delete('all'); // Deselect 'all' when selecting specific meta
                                metaMainSelected.add(opt.value);
                                allCheckbox.checked = false;
                            } else {
                                metaMainSelected.delete(opt.value);
                                // If no meta selected, select 'all'
                                if (metaMainSelected.size === 0) {
                                    metaMainSelected.add('all');
                                    allCheckbox.checked = true;
                                }
                            }
                            // Update 'Alle' checkbox state
                            const allChecked = metaMainOptions.filter(opt => opt.value !== 'all').every(opt => metaMainSelected.has(opt.value));
                            allCheckbox.checked = allChecked;
                            if (allChecked) metaMainSelected.add('all'); else metaMainSelected.delete('all');
                            updateMetaMainSelectedText();
                            populateDeckDropdown(); // Re-filter deck dropdown
                            updateCardsDisplay();
                        });
                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(opt.label));
                        optionsDiv.appendChild(label);
                    });

                    // Dropdown open/close logic
                    const dropdown = document.getElementById('metaMainFilterDropdown');
                    function openMetaDropdown(e) {
                        e.stopPropagation();
                        optionsDiv.style.display = optionsDiv.style.display === 'block' ? 'none' : 'block';
                        optionsDiv.style.zIndex = 10000;
                        optionsDiv.style.pointerEvents = 'auto';
                    }
                    dropdown.addEventListener('click', openMetaDropdown);
                    selectedDiv.addEventListener('click', openMetaDropdown);
                    selectedDiv.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' || e.key === ' ') {
                            e.preventDefault();
                            openMetaDropdown(e);
                        }
                    });
                    // Close on outside click
                    document.addEventListener('click', (e) => {
                        if (!dropdown.contains(e.target) && !optionsDiv.contains(e.target)) {
                            optionsDiv.style.display = 'none';
                        }
                    });
                    // Accessibility: allow tab focus
                    selectedDiv.setAttribute('tabindex', '0');
                    selectedDiv.setAttribute('role', 'button');
                    selectedDiv.setAttribute('aria-haspopup', 'listbox');
                    selectedDiv.setAttribute('aria-expanded', 'false');
                    optionsDiv.setAttribute('role', 'listbox');
                }

                function updateMetaMainSelectedText() {
                    const selectedDiv = document.getElementById('metaMainFilterSelected');
                    if (!selectedDiv) return;
                    if (metaMainSelected.size === 0 || metaMainSelected.has('all') || metaMainSelected.size === metaMainOptions.length) {
                        selectedDiv.textContent = 'Alle';
                    } else {
                        selectedDiv.textContent = Array.from(metaMainOptions)
                            .filter(opt => metaMainSelected.has(opt.value) && opt.value !== 'all')
                            .map(opt => opt.label)
                            .join(', ');
                    }
                }

                function getSelectedMetaMainOptions() {
                    // If "all" is selected, treat as empty selection (show all)
                    if (metaMainSelected.has('all') || metaMainSelected.size === 0) {
                        return new Set();
                    }
                    return new Set(metaMainSelected);
                }

                function cardMatchesMetaValue(card, metaValue) {
                    if (!metaValue) return false;
                    const cardMeta = getCardMetaValue(card);
                    if (cardMeta) {
                        return cardMeta === metaValue;
                    }
                    const setMap = metaSetCodeMap[metaValue];
                    if (setMap && card.set_code) {
                        return setMap.has(String(card.set_code).trim());
                    }
                    return false;
                }

                function cardMatchesSelectedMeta(card, selectedMeta) {
                    if (!selectedMeta || selectedMeta.size === 0) return true;
                    let matches = false;
                    if (selectedMeta.has('city_leagues')) {
                        const normalize = (str) => str.toLowerCase().trim();
                        if (cityLeagueData.some(j => normalize(j.archetype) === normalize(card.archetype))) {
                            matches = true;
                        }
                    }
                    for (const metaValue of selectedMeta) {
                        if (metaValue === 'all' || metaValue === 'city_leagues') continue;
                        if (cardMatchesMetaValue(card, metaValue)) {
                            matches = true;
                        }
                    }
                    return matches;
                }

                function archetypeMatchesSelectedMeta(archetype, selectedMeta) {
                    if (!selectedMeta || selectedMeta.size === 0) return true;
                    let matches = false;
                    if (selectedMeta.has('city_leagues')) {
                        const normalize = (str) => str.toLowerCase().trim();
                        if (cityLeagueData.some(j => normalize(j.archetype) === normalize(archetype))) {
                            matches = true;
                        }
                    }
                    for (const metaValue of selectedMeta) {
                        if (metaValue === 'all' || metaValue === 'city_leagues') continue;
                        if (cardsData.some(card => card.archetype === archetype && cardMatchesMetaValue(card, metaValue))) {
                            matches = true;
                        }
                    }
                    return matches;
                }
        
// Load City League data from CSV (with cache-busting)
                async function loadCityLeagueData() {
                    try {
                        const timestamp = new Date().getTime();
                        const response = await fetch(`${BASE_PATH}data/city_league_archetypes_comparison.csv?t=${timestamp}`);
                        if (response.ok) {
                            const text = await response.text();
                            cityLeagueData = parseCSV(text);
                            console.log('Loaded City League development - Entries:', cityLeagueData.length);
                            
                            // Load tournament count and date range from main archetype CSV
                            let tournamentCount = 0;
                            let dateRange = '';
                            try {
                                const tournamentsResponse = await fetch(`${BASE_PATH}data/city_league_archetypes.csv?t=${timestamp}`);
                                if (tournamentsResponse.ok) {
                                    const tournamentsText = await tournamentsResponse.text();
                                    const tournamentsData = parseCSV(tournamentsText);
                                    const uniqueTournaments = new Set(tournamentsData.map(d => d.tournament_id));
                                    tournamentCount = uniqueTournaments.size;
                                    
                                    // Extract date range with proper date parsing
                                    if (tournamentsData.length > 0) {
                                        const dates = tournamentsData.map(d => d.date).filter(d => d);
                                        if (dates.length > 0) {
                                            // Parse dates in format "DD Mon YY" and convert to comparable format
                                            const parsedDates = dates.map(d => {
                                                const parts = d.split(' ');
                                                if (parts.length >= 3) {
                                                    const day = parts[0];
                                                    const month = parts[1];
                                                    const year = parts[2];
                                                    // Create comparable date string in YYYY-MM-DD format
                                                    const monthMap = {'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06', 
                                                                      'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'};
                                                    const monthNum = monthMap[month] || '01';
                                                    const fullYear = '20' + year;
                                                    return {original: d, comparable: fullYear + monthNum + day.padStart(2, '0')};
                                                }
                                                return {original: d, comparable: '99999999'};
                                            });
                                            
                                            const minDateObj = parsedDates.reduce((a, b) => a.comparable < b.comparable ? a : b);
                                            const maxDateObj = parsedDates.reduce((a, b) => a.comparable > b.comparable ? a : b);
                                            
                                            dateRange = `${minDateObj.original} - ${maxDateObj.original}`;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.warn('Could not load tournament data:', e);
                            }
                            
                            renderCityLeagueTable(tournamentCount, dateRange);
                        } else {
                            console.warn('City League development data not found - generating from cardsData');
                            generateCityLeagueDataFallback();
                        }
                    } catch (error) {
                        console.error('Error loading City League data:', error);
                        generateCityLeagueDataFallback();
                    }
                }

        // Render City League table with full structure matching original HTML
        function renderCityLeagueTable(tournamentCount = 0, dateRange = '') {
            const content = document.getElementById('cityLeagueContent');
            if (!content || !cityLeagueData || cityLeagueData.length === 0) return;

            // Separate data by status and trend
            const newArchetypes = cityLeagueData.filter(d => d.status === 'NEU');
            const disappeared = cityLeagueData.filter(d => d.status === 'VERSCHWUNDEN');
            const increased = cityLeagueData.filter(d => d.status !== 'NEU' && parseInt(d.count_change) > 0).sort((a, b) => parseInt(b.count_change) - parseInt(a.count_change));
            const decreased = cityLeagueData.filter(d => parseInt(d.count_change) < 0).sort((a, b) => parseInt(a.count_change) - parseInt(b.count_change));
            
            // Get max count for threshold filtering
            const maxCountForThreshold = Math.max(...cityLeagueData.map(d => parseInt(d.new_count)));
            const countThreshold = maxCountForThreshold * 0.1;
            
            // Performance improvers/decliners (better/worse avg placement) - with 10% threshold
            const improvers = cityLeagueData.filter(d => parseFloat(d.avg_placement_change) < 0 && parseInt(d.new_count) >= countThreshold).sort((a, b) => parseFloat(a.avg_placement_change) - parseFloat(b.avg_placement_change));
            const decliners = cityLeagueData.filter(d => parseFloat(d.avg_placement_change) > 0 && parseInt(d.new_count) >= countThreshold).sort((a, b) => parseFloat(b.avg_placement_change) - parseFloat(a.avg_placement_change));
            
            // Most active (by count)
            const sorted = [...cityLeagueData].sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count));
            const topActive = sorted.slice(0, 1)[0];
            const totalArchetypes = cityLeagueData.length;

            const now = new Date();
            const generatedDate = now.toLocaleString('de-DE', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });

            // Get top 3 by count and top 3 by avg placement
            const topByCount = [...cityLeagueData].sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count)).slice(0, 3);
            const maxCount = parseInt(topByCount[0].new_count);
            const minCountThreshold = maxCount * 0.1;
            const topByPlacement = [...cityLeagueData]
                .filter(d => parseInt(d.new_count) >= minCountThreshold)
                .sort((a, b) => parseFloat(a.new_avg_placement) - parseFloat(b.new_avg_placement))
                .slice(0, 3);
            
            // Get top 10 changes
            const top10New = [...cityLeagueData].sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count)).slice(0, 10).map(d => d.archetype);
            const top10Old = [...cityLeagueData].sort((a, b) => parseInt(b.old_count) - parseInt(a.old_count)).slice(0, 10).map(d => d.archetype);
            const entries = top10New.filter(arch => !top10Old.includes(arch));
            const exits = top10Old.filter(arch => !top10New.includes(arch));

            let html = `
                
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 30px; text-align: center;">
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">üìÖ Generated: ${generatedDate}</span>
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">üìä Total Archetypes Tracked: ${totalArchetypes}</span>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">üìä Archetype Overview</h3>
                        <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${totalArchetypes}</div>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 15px; text-align: left;">
                            <strong>Top 3 by Count:</strong><br>
                            ${topByCount.map(d => `${d.archetype}: ${d.new_count}x`).join('<br>')}
                            <br><br>
                            <strong>Top 3 by Avg Placement:</strong><br>
                            ${topByPlacement.map(d => `${d.archetype}: ${d.new_avg_placement}`).join('<br>')}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">üîÑ Top 10 Changes</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; text-align: left;">
                            ${entries.length > 0 ? `<strong style="color: #7fff7f;">‚¨Ü Entries:</strong><br>${entries.map(arch => `${arch}`).join('<br>')}<br><br>` : ''}
                            ${exits.length > 0 ? `<strong style="color: #ff6b6b;">‚¨á Exits:</strong><br>${exits.map(arch => `${arch}`).join('<br>')}<br>` : ''}
                            ${entries.length === 0 && exits.length === 0 ? 'No changes in top 10' : ''}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">ÔøΩ Datenquelle</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px;">
                            <strong>Zeitraum:</strong><br>${dateRange || 'N/A'}<br><br>
                            <strong>Turniere:</strong><br>${tournamentCount || 0}
                        </div>
                    </div>
                </div>`;

            // Popularity Decreases
            if (decreased.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìâ Popularity Decreases</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Change</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Avg Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decreased.slice(0, 10).forEach(d => {
                    const change = parseInt(d.count_change);
                    const placement_change = parseFloat(d.avg_placement_change);
                    const placement_color = placement_change < 0 ? '#27ae60' : '#e74c3c';
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center; color: #e74c3c; font-weight: bold;">${change}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: ${placement_color}; font-weight: bold;">(${placement_change > 0 ? '+' : ''}${placement_change.toFixed(2)})</span></td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }

            // Performance Improvers
            if (improvers.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">‚≠ê Performance Improvers (Better Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Improvement</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Best Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                improvers.slice(0, 10).forEach(d => {
                    const improvement = Math.abs(parseFloat(d.avg_placement_change));
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_avg_placement}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                            <td style="padding: 12px; text-align: center; color: #27ae60; font-weight: bold;">-${improvement.toFixed(2)}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_best}</td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }

            // Performance Decliners
            if (decliners.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìâ Performance Decliners (Worse Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Decline</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Best Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decliners.slice(0, 10).forEach(d => {
                    const decline = parseFloat(d.avg_placement_change);
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_avg_placement}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                            <td style="padding: 12px; text-align: center; color: #e74c3c; font-weight: bold;">+${decline.toFixed(2)}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_best}</td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }

            // Full Comparison Table (Top 30)
            html += `
                <div style="margin-bottom: 40px;">
                    <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìã Full Comparison Table (Top 30)</h2>
                    <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Trend</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Count Old</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Count New</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Count Œî</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Avg Placement</th>
                            </tr>
                        </thead>
                        <tbody>`;
            
            sorted.slice(0, 30).forEach(d => {
                const trendColor = d.trend === 'VERBESSERT' ? '#27ae60' : d.trend === 'VERSCHLECHTERT' ? '#e67e22' : '#95a5a6';
                const trendArrow = d.trend === 'VERBESSERT' ? '‚Üë' : d.trend === 'VERSCHLECHTERT' ? '‚Üì' : '‚Üí';
                const changeColor = parseInt(d.count_change) > 0 ? '#27ae60' : '#e74c3c';
                
                html += `
                    <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                        <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                        <td style="padding: 12px; text-align: center; font-size: 1.2em; color: ${trendColor}; font-weight: bold;">${trendArrow}</td>
                        <td style="padding: 12px; text-align: center;">${d.old_count}</td>
                        <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                        <td style="padding: 12px; text-align: center; color: ${changeColor}; font-weight: bold;">(${parseInt(d.count_change) > 0 ? '+' : ''}${parseInt(d.count_change)})</td>
                        <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                    </tr>`;
            });

            html += `</tbody></table></div>`;
            content.innerHTML = html;
        }
        
        // Render Limitless Online table with full structure
        function renderLimitlessTable(matchupsDetailsData = []) {
            const content = document.getElementById('limitlessContent');
            if (!content || !matchupsData || matchupsData.length === 0) return;

            // Sort by rank
            const sorted = [...matchupsData].sort((a, b) => {
                const rankA = parseInt(a.rank) || 999;
                const rankB = parseInt(b.rank) || 999;
                return rankA - rankB;
            });

            const totalEntries = sorted.reduce((sum, d) => sum + (parseInt(d.count) || 0), 0);
            const topDeck = sorted.length > 0 ? sorted[0] : null;

            let html = `
                <div style="margin-bottom: 30px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px;">
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0 0 15px 0; font-size: 1.1em; opacity: 0.9;">üìä Total Decks</h3>
                            <div style="font-size: 2.5em; font-weight: bold;">${totalEntries.toLocaleString()}</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0 0 15px 0; font-size: 1.1em; opacity: 0.9;">üéØ Unique Archetypes</h3>
                            <div style="font-size: 2.5em; font-weight: bold;">${sorted.length}</div>
                        </div>
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 25px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                            <h3 style="margin: 0 0 15px 0; font-size: 1.1em; opacity: 0.9;">üèÜ #1 Deck</h3>
                            <div style="font-size: 1.2em; font-weight: bold; word-break: break-word;">${topDeck ? topDeck.deck_name : 'N/A'}</div>
                        </div>
                    </div>
                </div>

                <div style="margin-bottom: 40px;">
                    <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üéÆ Deck Rankings</h2>
                    <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                <th style="padding: 12px; text-align: center; font-weight: 600; min-width: 60px;">Rank</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Deck Name</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Entries</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Meta Share</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Wins</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Losses</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Ties</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Win Rate</th>
                            </tr>
                        </thead>
                        <tbody>`;
            
            sorted.forEach((d, idx) => {
                const rank = d.rank || (idx + 1);
                const wins = parseInt(d.wins) || 0;
                const losses = parseInt(d.losses) || 0;
                const winsColor = wins > losses ? '#27ae60' : '#e74c3c';
                const lossesColor = losses > wins ? '#e74c3c' : '#27ae60';
                
                html += `
                    <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                        <td style="padding: 12px; text-align: center; font-weight: bold; color: #667eea; font-size: 1.1em;">#${rank}</td>
                        <td style="padding: 12px; font-weight: bold;">${d.deck_name}</td>
                        <td style="padding: 12px; text-align: center;">${parseInt(d.count).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center;">${d.share}</td>
                        <td style="padding: 12px; text-align: center; color: ${winsColor}; font-weight: bold;">${parseInt(d.wins).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center; color: ${lossesColor}; font-weight: bold;">${parseInt(d.losses).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center;">${parseInt(d.ties).toLocaleString()}</td>
                        <td style="padding: 12px; text-align: center; font-weight: bold; color: #667eea;"><strong>${d.win_rate}</strong></td>
                    </tr>`;
            });
            
            html += `</tbody></table></div>`;
            
            // Top 20 Matchups Section
            if (matchupsDetailsData.length > 0) {
                const top20 = sorted.slice(0, 20);
                const top20Names = new Set(top20.map(d => d.deck_name));
                
                html += `<div style="margin-bottom: 40px;">
                    <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üéØ Top 20 Matchup Analysis</h2>`;
                
                top20.forEach((deck, idx) => {
                    const deckName = deck.deck_name;
                    const winRate = parseFloat(deck.win_rate_numeric || 0);
                    const totalWins = parseInt(deck.wins) || 0;
                    const totalLosses = parseInt(deck.losses) || 0;
                    
                    // Find matchups for this deck
                    const deckMatchups = matchupsDetailsData.filter(m => m.deck_name === deckName);
                    
                    // Get good matchups (>54%) against top 20 decks
                    const goodMatchups = deckMatchups.filter(m => {
                        const opponentWR = parseFloat((m.win_rate || '0').replace(',', '.'));
                        return top20Names.has(m.opponent) && 
                               m.opponent !== deckName &&
                               opponentWR > 54;
                    }).sort((a, b) => parseFloat((b.win_rate || '0').replace(',', '.')) - parseFloat((a.win_rate || '0').replace(',', '.'))).slice(0, 5);
                    
                    // Get bad matchups (<45%) against top 20 decks
                    const badMatchups = deckMatchups.filter(m => {
                        const opponentWR = parseFloat((m.win_rate || '0').replace(',', '.'));
                        return top20Names.has(m.opponent) && 
                               m.opponent !== deckName &&
                               opponentWR < 45;
                    }).sort((a, b) => parseFloat((a.win_rate || '0').replace(',', '.')) - parseFloat((b.win_rate || '0').replace(',', '.'))).slice(0, 5);
                    
                    // Count positive vs negative matchups against top 20
                    const allTop20Matchups = deckMatchups.filter(m => top20Names.has(m.opponent) && m.opponent !== deckName);
                    const positiveCount = allTop20Matchups.filter(m => parseFloat((m.win_rate || '0').replace(',', '.')) >= 50).length;
                    const negativeCount = allTop20Matchups.filter(m => parseFloat((m.win_rate || '0').replace(',', '.')) < 50).length;
                    
                    const winRateColor = winRate >= 50 ? '#27ae60' : '#e74c3c';
                    
                    html += `<div style="margin-bottom: 30px; border: 1px solid #ecf0f1; border-radius: 8px; padding: 20px;">
                        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 20px; margin-bottom: 20px; align-items: start;">
                            <div>
                                <h3 style="margin: 0 0 10px 0; color: #34495e;">#${idx + 1} ${deckName}</h3>
                                <p style="margin: 0; color: #667eea; font-size: 1.1em; font-weight: bold;">WR: <span style="color: ${winRateColor};">${winRate.toFixed(2)}%</span></p>
                            </div>
                            <div style="text-align: center;">
                                <p style="margin: 0; color: #34495e; font-weight: bold; font-size: 0.9em;">Vs Top 20</p>
                                <p style="margin: 5px 0 0 0; color: #27ae60; font-size: 1.1em; font-weight: bold;">${positiveCount}:${negativeCount}</p>
                            </div>
                            <div style="text-align: right; color: #95a5a6; font-size: 0.85em;">
                                ${totalWins}-${totalLosses}
                            </div>
                        </div>`;
                    
                    if (goodMatchups.length > 0 || badMatchups.length > 0) {
                        html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">`;
                        
                        if (goodMatchups.length > 0) {
                            html += `<div>
                                <h4 style="color: #27ae60; margin: 0 0 10px 0; font-size: 0.9em;">‚úÖ Good Matchups (>54%)</h4>
                                <ul style="margin: 0; padding-left: 20px; font-size: 0.85em;">`;
                            goodMatchups.forEach(m => {
                                const wr = (m.win_rate || '0').replace(',', '.');
                                html += `<li style="margin-bottom: 5px; color: #34495e;">${m.opponent}<br><span style="color: #27ae60; font-weight: bold;">${wr}%</span></li>`;
                            });
                            html += `</ul>
                            </div>`;
                        }
                        
                        if (badMatchups.length > 0) {
                            html += `<div>
                                <h4 style="color: #e74c3c; margin: 0 0 10px 0; font-size: 0.9em;">‚ùå Bad Matchups (<45%)</h4>
                                <ul style="margin: 0; padding-left: 20px; font-size: 0.85em;">`;
                            badMatchups.forEach(m => {
                                const wr = (m.win_rate || '0').replace(',', '.');
                                html += `<li style="margin-bottom: 5px; color: #34495e;">${m.opponent}<br><span style="color: #e74c3c; font-weight: bold;">${wr}%</span></li>`;
                            });
                            html += `</ul>
                            </div>`;
                        }
                        
                        html += `</div>`;
                    } else {
                        html += `<p style="color: #95a5a6; font-size: 0.9em; margin: 0;">No matchup data available</p>`;
                    }
                    
                    html += `</div>`;
                });
                
                html += `</div>`;
            }
            
            html += `</div>`;
            
            content.innerHTML = html;
        }
        function generateCityLeagueDataFallback() {
            try {
                cityLeagueData = [];
                const archetypeStats = {};

                cardsData.forEach(card => {
                    if (!card.archetype) return;
                    
                    const archetype = card.archetype;
                    if (!archetypeStats[archetype]) {
                        archetypeStats[archetype] = {
                            archetype: archetype,
                            old_count: 0,
                            new_count: 0,
                            count_change: 0,
                            old_avg_placement: 0,
                            new_avg_placement: 0,
                            avg_placement_change: 0,
                            old_best: 999,
                            new_best: 999,
                            status: 'BESTEHEND',
                            trend: 'STABIL'
                        };
                    }
                    
                    const total = parseInt(card.total_decks_in_archetype || '0', 10) || 0;
                    const avgPlace = parseFloat(card.avg_placement || '0') || 0;
                    const best = parseInt(card.best_placement || '999', 10) || 999;
                    
                    archetypeStats[archetype].new_count = Math.max(archetypeStats[archetype].new_count, total);
                    archetypeStats[archetype].new_avg_placement = avgPlace;
                    archetypeStats[archetype].new_best = Math.min(archetypeStats[archetype].new_best, best);
                    
                    if (archetypeStats[archetype].new_best === 999) {
                        archetypeStats[archetype].new_best = 1;
                    }
                });

                cityLeagueData = Object.values(archetypeStats).sort((a, b) => parseInt(b.new_count) - parseInt(a.new_count));
                console.log('Generated City League data from fallback - Entries:', cityLeagueData.length);
                renderCityLeagueTable();
            } catch (error) {
                console.error('Error generating City League data:', error);
            }
        }

        // Fallback: Generate Limitless data from cardsData
        function generateMatchupsDataFallback() {
            try {
                matchupsData = [];
                const deckStats = {};

                cardsData.forEach((card, idx) => {
                    const deckName = card.archetype || `Deck ${idx + 1}`;
                    if (!deckStats[deckName]) {
                        deckStats[deckName] = {
                            rank: 0,
                            deck_name: deckName,
                            count: 0,
                            share: '0%',
                            share_numeric: 0,
                            wins: 0,
                            losses: 0,
                            ties: 0,
                            win_rate: '0%',
                            win_rate_numeric: 0
                        };
                    }
                    const count = parseInt(card.total_count || '0', 10) || 0;
                    deckStats[deckName].count = Math.max(deckStats[deckName].count, count);
                });

                // Calculate total for percentage
                const totalCount = Object.values(deckStats).reduce((sum, d) => sum + d.count, 0);
                
                // Build final array and sort
                matchupsData = Object.values(deckStats).map((d, idx) => ({
                    ...d,
                    rank: idx + 1,
                    share: totalCount > 0 ? ((d.count / totalCount) * 100).toFixed(2) + '%' : '0%',
                    share_numeric: totalCount > 0 ? ((d.count / totalCount) * 100).toFixed(2) : 0,
                    wins: Math.floor(d.count * 0.5),
                    losses: Math.floor(d.count * 0.45),
                    ties: Math.floor(d.count * 0.05),
                    win_rate: '50%',
                    win_rate_numeric: 50
                })).sort((a, b) => b.count - a.count);

                // Recalculate ranks after sort
                matchupsData.forEach((d, idx) => {
                    d.rank = idx + 1;
                });

                console.log('Generated Limitless data from fallback - Entries:', matchupsData.length);
                renderLimitlessTable();
            } catch (error) {
                console.error('Error generating matchups data:', error);
            }
        }
        
        function loadCardImageWithProxy(imgElement, originalUrl, cardName, count) {
            // Try adding _R_ to the URL if not present
            let urlWithR = originalUrl;
            if (originalUrl && !originalUrl.includes('_R_')) {
                // Insert _R_ before the extension
                urlWithR = originalUrl.replace(/\.([^.]+)$/, '_R_.$1');
            }
            
            // If direct load fails, try alternative image services
            const proxies = [
                // Try with _R_ suffix
                urlWithR,
                // Try weserv.nl proxy
                `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`,
                // Try another proxy service  
                `https://via.placeholder.com/200x280?text=${encodeURIComponent(cardName)}`
            ];
            
            let proxyIndex = 0;
            
            function tryNextProxy() {
                if (proxyIndex >= proxies.length) {
                    // All proxies failed, show fallback
                    imgElement.parentElement.classList.add('no-image');
                    imgElement.parentElement.innerHTML = `
                        <div class='fallback-content'>
                            <div class='fallback-icon'>üÉè</div>
                            <div>${cardName}</div>
                            <div class='card-count-badge'>${count}</div>
                        </div>
                    `;
                    return;
                }
                
                const currentUrl = proxies[proxyIndex];
                proxyIndex++;
                
                imgElement.src = currentUrl;
                imgElement.onerror = () => {
                    tryNextProxy();
                };
            }
            
            tryNextProxy();
        }
        
        function parseCSV(text) {
            const lines = text.split('\n');
            if (lines.length === 0) return [];
            
            // Handle BOM if present
            let headerLine = lines[0];
            if (headerLine.charCodeAt(0) === 0xFEFF) {
                headerLine = headerLine.substr(1);
            }
            
            const headers = headerLine.split(';').map(h => {
                return h.trim().replace(/\r$/, '');
            });
            const data = [];
            
            console.log('CSV Headers:', headers); // Debug
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = lines[i].split(';');
                const row = {};
                headers.forEach((header, index) => {
                    const value = values[index] ? values[index].trim().replace(/\r$/, '') : '';
                    row[header] = value;
                });
                data.push(row);
            }
            
            console.log('Parsed', data.length, 'rows'); // Debug
            return data;
        }
        
        function populateDeckDropdown() {
            const deckSelect = document.getElementById('deckSelect');
            const currentSelection = deckSelect.value; // Remember current selection
            deckSelect.innerHTML = '<option value="">-- Bitte Deck w√§hlen --</option>';
            const cityLeagueArchetypes = [...new Set(cityLeagueData.map(c => c.archetype).filter(Boolean))];
            let allArchetypes = [...new Set(cardsData.map(c => c.archetype))];
            const normalize = (str) => str.toLowerCase().trim();
            const selectedMeta = getSelectedMetaMainOptions();

            // If City Leagues is selected, base list on City League archetypes
            if (selectedMeta.has('city_leagues')) {
                allArchetypes = cityLeagueArchetypes;
            }
            
            // FILTER archetypes based on selected meta
            if (selectedMeta.size > 0) {
                allArchetypes = allArchetypes.filter(arch => archetypeMatchesSelectedMeta(arch, selectedMeta));
            }
            
            console.log('Filtered archetypes:', allArchetypes.length, 'Selected meta:', Array.from(selectedMeta));

            // Helper to match archetype names
            const findMatchingArchetype = (deckName) => {
                const normalized = normalize(deckName);
                
                // Exact match (case-insensitive)
                const exact = allArchetypes.find(arch => normalize(arch) === normalized);
                if (exact) {
                    console.log(`‚úì Exact match: "${deckName}" ‚Üí "${exact}"`);
                    return exact;
                }
                
                // Word-based matching: check if all significant words in deckName appear in archetype
                const deckWords = normalized.split(/\s+/).filter(w => w.length > 2);
                const match = allArchetypes.find(arch => {
                    const archWords = normalize(arch).split(/\s+/).filter(w => w.length > 2);
                    return deckWords.every(word => archWords.some(aword => aword.includes(word) || word.includes(aword)));
                });
                if (match) {
                    console.log(`‚úì Word match: "${deckName}" ‚Üí "${match}"`);
                    return match;
                }
                
                // Substring match (either direction)
                const partial = allArchetypes.find(arch => 
                    normalize(arch).includes(normalized) || normalized.includes(normalize(arch))
                );
                if (partial) {
                    console.log(`‚úì Substring match: "${deckName}" ‚Üí "${partial}"`);
                    return partial;
                }
                
                console.log(`‚úó No match found for: "${deckName}" - will use as-is`);
                return deckName; // Return the deck name as-is if no match found
            };

            // Dynamically fetch and parse Top 20 Limitless and Top 10 City League from HTML reports
            Promise.all([
                fetch(BASE_PATH + 'data/limitless_online_decks_comparison.html').then(r => r.text()).catch(() => ''),
                fetch(BASE_PATH + 'data/city_league_archetypes_comparison.html').then(r => r.text()).catch(() => '')
            ]).then(([limitlessHtml, cityHtml]) => {
                console.log('Fetched HTML files successfully');
                
                // Parse Top 20 Limitless from "Full Comparison Table"
                const limitlessDoc = new DOMParser().parseFromString(limitlessHtml, 'text/html');
                let top20Limitless = [];
                const limitlessHeadings = limitlessDoc.querySelectorAll('h2');
                for (const heading of limitlessHeadings) {
                    if (heading.textContent.includes('Full Comparison')) {
                        let table = heading.nextElementSibling;
                        while (table && table.tagName !== 'TABLE') {
                            table = table.nextElementSibling;
                        }
                        if (table) {
                            const rows = Array.from(table.querySelectorAll('tbody tr, tr'));
                            for (const row of rows) {
                                if (top20Limitless.length >= 20) break;
                                const cells = row.querySelectorAll('td');
                                if (cells.length > 0) {
                                    const strong = cells[0].querySelector('strong');
                                    const deckName = strong ? strong.textContent.trim() : cells[0].textContent.trim();
                                    if (deckName) top20Limitless.push(deckName);
                                }
                            }
                        }
                        break;
                    }
                }
                console.log('Top 20 Limitless parsed:', top20Limitless.length, top20Limitless.slice(0, 5));

                // Initialize limitlessDeckStats with rankings based on Top 20 position
                limitlessDeckStats = {};
                top20Limitless.forEach((deckName, index) => {
                    limitlessDeckStats[deckName] = {
                        rank: (index + 1).toString(),
                        wr: null,
                        matchup: null
                    };
                });
                console.log('[TOP 20] Assigned rankings to', Object.keys(limitlessDeckStats).length, 'decks based on Top 20 order');

                // Parse Limitless Deck Stats (WR and Matchup data from h3 headers) - MERGE with existing rankings
                const h3Elements = limitlessDoc.querySelectorAll('h3');
                for (const h3 of h3Elements) {
                    const fullText = h3.textContent;
                    // Extract: "Deckname (Total WR: 51.2%, Vs Top20: 11:8)"
                    const match = fullText.match(/^(.*?)\s*\((Total WR: ([\d.]+%),\s*Vs Top20: (\d+:\d+))\)/);
                    if (match) {
                        const deckName = match[1].trim();
                        const wr = match[3];
                        const matchup = match[4];
                        
                        // Merge with existing entry (preserves ranking if it exists)
                        if (limitlessDeckStats[deckName]) {
                            limitlessDeckStats[deckName].wr = wr;
                            limitlessDeckStats[deckName].matchup = matchup;
                        } else {
                            // Create new entry if deck not in rankings table
                            limitlessDeckStats[deckName] = { wr, matchup, rank: null };
                        }
                    }
                }

                console.log('[H3 STATS] Parsed WR/Matchup data for', Object.entries(limitlessDeckStats).filter(([k,v]) => v.wr).length, 'decks');
                console.log('[STATS] Total decks with rankings:', Object.entries(limitlessDeckStats).filter(([k,v]) => v.rank).length);

                if (matchupDetailsData && matchupDetailsData.length > 0) {
                    limitlessMatchupData = buildLimitlessMatchupData(matchupDetailsData);
                    console.log('[INFO] Matchup data synced from CSV:', Object.keys(limitlessMatchupData).length);
                }

                // Parse Top 10 City League from "Full Comparison Table"
                const cityDoc = new DOMParser().parseFromString(cityHtml, 'text/html');
                let top10City = [];
                const cityHeadings = cityDoc.querySelectorAll('h2');
                for (const heading of cityHeadings) {
                    if (heading.textContent.includes('Full Comparison')) {
                        let table = heading.nextElementSibling;
                        while (table && table.tagName !== 'TABLE') {
                            table = table.nextElementSibling;
                        }
                        if (table) {
                            const rows = Array.from(table.querySelectorAll('tbody tr, tr'));
                            for (const row of rows) {
                                if (top10City.length >= 10) break;
                                const cells = row.querySelectorAll('td');
                                if (cells.length > 0) {
                                    const strong = cells[0].querySelector('strong');
                                    const deckName = strong ? strong.textContent.trim() : cells[0].textContent.trim();
                                    if (deckName) top10City.push(deckName);
                                }
                            }
                        }
                        break;
                    }
                }
                console.log('Top 10 City League parsed:', top10City.length, top10City.slice(0, 5));

                // Debug: Show available archetypes and parsed decknames
                console.log('Available archetypes in cardsData:', allArchetypes.slice(0, 10));
                console.log('All parsed Limitless decks:', top20Limitless);
                console.log('All parsed City League decks:', top10City);

                // Map to archetypes in cardsData
                const top20WithArchetypes = top20Limitless.map(findMatchingArchetype).filter(Boolean);
                const top10WithArchetypes = top10City.map(findMatchingArchetype).filter(Boolean);

                const allowedArchetypes = new Set(allArchetypes.map(a => normalize(a)));
                const top20Display = selectedMeta.size > 0
                    ? top20WithArchetypes.filter(a => allowedArchetypes.has(normalize(a)))
                    : top20WithArchetypes;
                const top10Display = selectedMeta.size > 0
                    ? top10WithArchetypes.filter(a => allowedArchetypes.has(normalize(a)))
                    : top10WithArchetypes;
                
                // Store globally for use in updateCardsDisplay
                top20LimitlessArchetypes = top20WithArchetypes;
                top10CityLeagueArchetypes = top10WithArchetypes;
                
                console.log('Matched Top 20:', top20WithArchetypes.length, 'Matched Top 10:', top10WithArchetypes.length);
                
                const used = new Set([...top20Display, ...top10Display].map(a => normalize(a)));
                const remainingArchetypes = allArchetypes
                    .filter(arch => arch.trim() && !used.has(normalize(arch)))
                    .sort((a, b) => a.localeCompare(b, 'de-DE'));

                // Add Top 20 Limitless
                if (top20Display.length > 0) {
                    const group1 = document.createElement('optgroup');
                    group1.label = 'üèÜ Top 20 Limitless';
                    top20Display.forEach(archetype => {
                        const option = document.createElement('option');
                        option.value = archetype;
                        option.textContent = archetype;
                        group1.appendChild(option);
                    });
                    deckSelect.appendChild(group1);
                }
                // Add Top 10 City League
                if (top10Display.length > 0) {
                    const group2 = document.createElement('optgroup');
                    group2.label = 'üáØüáµ Top 10 Japan City League';
                    top10Display.forEach(archetype => {
                        const option = document.createElement('option');
                        option.value = archetype;
                        option.textContent = archetype;
                        group2.appendChild(option);
                    });
                    deckSelect.appendChild(group2);
                }
                // Add remaining archetypes alphabetically
                const group3 = document.createElement('optgroup');
                group3.label = 'üìã Weitere Decks (alphabetisch)';
                if (remainingArchetypes.length > 0) {
                    remainingArchetypes.forEach(archetype => {
                        const option = document.createElement('option');
                        option.value = archetype;
                        option.textContent = archetype;
                        group3.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'Keine weiteren Decks';
                    option.disabled = true;
                    group3.appendChild(option);
                }
                deckSelect.appendChild(group3);
            }).catch(err => {
                console.error('Error loading meta reports:', err);
                // Fallback: show all alphabetically
                const group3 = document.createElement('optgroup');
                group3.label = 'üìã Alle Decks (alphabetisch)';
                allArchetypes.filter(a => a.trim()).sort((a, b) => a.localeCompare(b, 'de-DE')).forEach(archetype => {
                    const option = document.createElement('option');
                    option.value = archetype;
                    option.textContent = archetype;
                    group3.appendChild(option);
                });
                deckSelect.appendChild(group3);
            });
        }
        
        function setupEventListeners() {
            document.getElementById('deckSelect').addEventListener('change', onDeckChange);
            document.getElementById('filterSelect').addEventListener('change', updateCardsDisplay);
            document.getElementById('deckSearch').addEventListener('input', filterDeckList);
            const setFilter = document.getElementById('setFilterSelect');
            if (setFilter) {
                setFilter.addEventListener('change', applyCardFilters);
            }
            const cardSearch = document.getElementById('cardSearchInput');
            if (cardSearch) {
                // Apply filter on Enter key
                cardSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        applyCardFilters();
                    }
                });
                // Optional: Live search while typing (with debounce)
                let searchTimeout;
                cardSearch.addEventListener('input', () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        applyCardFilters();
                    }, 500); // Wait 500ms after user stops typing
                });
            }
            
            // Event delegation for card image clicks
            document.addEventListener('click', (e) => {
                const cardElement = e.target.closest('.card-visual, .compact-card, .card-thumbnail, [data-image-url]');
                if (cardElement && cardElement.dataset.imageUrl && cardElement.dataset.cardName) {
                    e.preventDefault();
                    showCardImage(cardElement.dataset.imageUrl, cardElement.dataset.cardName);
                    return;
                }
                
                // Handle add to deck button
                if (e.target.classList.contains('btn-add')) {
                    e.preventDefault();
                    const btn = e.target;
                    const identifier = btn.dataset.identifier;
                    const maxCount = parseInt(btn.dataset.maxCount) || 4;
                    const cardName = btn.dataset.cardName;
                    const imageUrl = btn.dataset.imageUrl || '';
                    const setCode = btn.dataset.setCode || '';
                    const setNumber = btn.dataset.setNumber || '';
                    addToDeck(identifier, maxCount, cardName, imageUrl, setCode, setNumber);
                    return;
                }
                
                // Handle remove from deck button
                if (e.target.classList.contains('btn-remove')) {
                    e.preventDefault();
                    const cardName = e.target.dataset.cardName;
                    removeFromDeck(cardName);
                    return;
                }
            });
        }

        function initializeCardFilterUI() {
            populateSetFilterOptions();
            renderCardTypeFilters();
            applyCardFilters();
        }

        function populateSetFilterOptions() {
            const setSelect = document.getElementById('setFilterSelect');
            if (!setSelect) return;

            // Set release dates (newest to oldest)
            const setReleaseDates = {
                'ASC': new Date('2026-01-30').getTime(),
                'PFL': new Date('2025-11-14').getTime(),
                'MEG': new Date('2025-09-26').getTime(),
                'MEE': new Date('2025-09-25').getTime(),
                'MEP': new Date('2025-09-24').getTime(), // Estimated
                'BLK': new Date('2025-07-18').getTime(),
                'WHT': new Date('2025-07-18').getTime(),
                'DRI': new Date('2025-05-30').getTime(),
                'JTG': new Date('2025-03-28').getTime(),
                'PRE': new Date('2025-01-17').getTime(),
                'SSP': new Date('2024-11-08').getTime(),
                'SCR': new Date('2024-09-13').getTime(),
                'SFA': new Date('2024-08-02').getTime(),
                'TWM': new Date('2024-05-24').getTime(),
                'TEF': new Date('2024-03-22').getTime(),
                'PAF': new Date('2024-01-26').getTime(),
                'PAR': new Date('2023-11-03').getTime(),
                'MEW': new Date('2023-09-22').getTime(),
                'OBF': new Date('2023-08-11').getTime(),
                'PAL': new Date('2023-06-09').getTime(),
                'SVI': new Date('2023-03-31').getTime(),
                'SVE': new Date('2023-03-30').getTime(),
                'SVP': new Date('2023-03-30').getTime(), // Promos
                'CRZ': new Date('2023-01-20').getTime(),
                'SIT': new Date('2022-11-11').getTime(),
                'LOR': new Date('2022-09-09').getTime(),
                'PGO': new Date('2022-07-01').getTime(),
                'ASR': new Date('2022-05-27').getTime(),
                'BRS': new Date('2022-02-25').getTime(),
                'FST': new Date('2021-11-12').getTime(),
                'CEL': new Date('2021-10-08').getTime(),
                'EVS': new Date('2021-08-27').getTime(),
                'CRE': new Date('2021-06-18').getTime(),
                'BST': new Date('2021-03-19').getTime(),
                'SHF': new Date('2021-02-19').getTime(),
                'VIV': new Date('2020-11-13').getTime(),
                'CPA': new Date('2020-09-25').getTime(),
                'DAA': new Date('2020-08-14').getTime(),
                'RCL': new Date('2020-05-01').getTime(),
                'SSH': new Date('2020-02-07').getTime(),
                'SP': new Date('2020-02-01').getTime()   // Promos
            };

            const sets = [...new Set(cardsData.map(c => (c.set_code || '').trim()).filter(Boolean))]
                .sort((a, b) => {
                    const dateA = setReleaseDates[a] || 0;
                    const dateB = setReleaseDates[b] || 0;
                    return dateB - dateA; // Newest first
                });

            sets.forEach(setCode => {
                const option = document.createElement('option');
                option.value = setCode;
                option.textContent = setCode;
                setSelect.appendChild(option);
            });
        }

        function renderCardTypeFilters() {
            const container = document.getElementById('cardTypeFiltersContainer');
            if (!container) return;

            container.innerHTML = '';

            const button = document.createElement('button');
            button.className = 'dropdown-button';
            button.type = 'button';
            button.innerHTML = 'Alle' + '<span style="margin-left: auto;">‚ñº</span>';

            const menu = document.createElement('div');
            menu.className = 'dropdown-menu';

            const cardTypes = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];

            cardTypes.forEach(type => {
                const label = document.createElement('label');
                label.style.margin = '0';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = type;
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    updateTypeFilterButton();
                    applyCardFilters();
                });

                const span = document.createElement('span');
                span.textContent = type;

                label.appendChild(checkbox);
                label.appendChild(span);
                menu.appendChild(label);
            });

            button.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = button.classList.toggle('open');
                menu.classList.toggle('open', isOpen);
            });

            container.appendChild(button);
            container.appendChild(menu);

            document.addEventListener('click', () => {
                button.classList.remove('open');
                menu.classList.remove('open');
            });

            updateTypeFilterButton();
        }

        function updateTypeFilterButton() {
            const button = document.querySelector('.dropdown-button');
            if (!button) return;

            const selected = getSelectedCardTypes();
            const cardTypes = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
            const allSelected = cardTypes.every(t => selected.has(t));

            if (allSelected) {
                button.innerHTML = 'Alle' + '<span style="margin-left: auto;">‚ñº</span>';
            } else if (selected.size === 0) {
                button.innerHTML = 'Keine' + '<span style="margin-left: auto;">‚ñº</span>';
            } else {
                button.innerHTML = `${selected.size} ausgew√§hlt` + '<span style="margin-left: auto;">‚ñº</span>';
            }
        }

        function getSelectedCardTypes() {
            const container = document.getElementById('cardTypeFiltersContainer');
            if (!container) return new Set();

            const selected = new Set();
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (cb.checked) selected.add(cb.value);
            });
            return selected;
        }

        function applyCardFilters() {
            const setFilter = document.getElementById('setFilterSelect');
            const selectedSet = setFilter ? setFilter.value : '';
            const searchInput = document.getElementById('cardSearchInput');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            const selectedTypes = getSelectedCardTypes();

            const cardMap = new Map();

            cardsData.forEach(card => {
                const setCode = (card.set_code || '').trim();
                const cardNumber = (card.set_number || '').trim();
                const cardName = (card.card_name || '').trim();
                if (!cardName) return;

                if (selectedSet && setCode !== selectedSet) return;
                
                // Filter by search term
                if (searchTerm && !cardName.toLowerCase().includes(searchTerm)) return;

                const cardType = getCardType(cardName);
                if (selectedTypes.size > 0 && !selectedTypes.has(cardType)) return;

                const key = `${cardName}|${setCode}|${cardNumber}`;
                const totalCount = parseInt(card.total_count || '0', 10) || 0;
                const maxCount = parseInt(card.max_count || '0', 10) || 0;

                if (!cardMap.has(key)) {
                    cardMap.set(key, {
                        card_name: cardName,
                        set_code: setCode,
                        set_number: cardNumber,
                        card_type: cardType,
                        total_count: totalCount,
                        max_count: maxCount,
                        image_url: card.image_url || ''
                    });
                } else {
                    const existing = cardMap.get(key);
                    existing.total_count += totalCount;
                    existing.max_count = Math.max(existing.max_count, maxCount);
                }
            });

            filteredCards = Array.from(cardMap.values());
            // Sort by card type first
            filteredCards = sortCardsByType(filteredCards);
            
            // Show grid only if single set selected and all types are selected (no specific type filter) and no search term
            const allCardTypes = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
            const allTypesSelected = allCardTypes.every(type => selectedTypes.has(type));
            const showGrid = selectedSet && allTypesSelected && !searchTerm;
            updateFilteredCardsVisual(showGrid);
            
            renderFilteredCards();
        }

        function updateFilteredCardsVisual(show) {
            const visualDiv = document.getElementById('filteredCardsVisual');
            const grid = document.getElementById('filteredGrid');

            if (!show || filteredCards.length === 0) {
                visualDiv.classList.remove('show');
                return;
            }

            visualDiv.classList.add('show');

            // Sort cards by type, then set number, then relevance
            const sortedForGrid = [...filteredCards].sort((a, b) => {
                // First sort by card type
                const typeOrder = ['Pokemon', 'Trainer', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
                const typeA = typeOrder.indexOf(a.card_type || 'Unknown');
                const typeB = typeOrder.indexOf(b.card_type || 'Unknown');
                if (typeA !== typeB) return (typeA === -1 ? 999 : typeA) - (typeB === -1 ? 999 : typeB);
                
                // Then by set number
                const numA = parseInt(a.set_number || '0', 10);
                const numB = parseInt(b.set_number || '0', 10);
                if (numA !== numB) return numA - numB;
                
                // Finally by relevance (max_count descending)
                const countA = parseInt(a.max_count || '0', 10);
                const countB = parseInt(b.max_count || '0', 10);
                return countB - countA;
            });

            grid.innerHTML = sortedForGrid.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.card_name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">üÉè</div>
                                <div>${card.card_name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        function clearCardFilters() {
            const setSelect = document.getElementById('setFilterSelect');
            if (setSelect) setSelect.value = '';
            
            const searchInput = document.getElementById('cardSearchInput');
            if (searchInput) searchInput.value = '';

            const container = document.getElementById('cardTypeFiltersContainer');
            if (container) {
                const checkboxes = container.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = true;
                });
            }

            updateTypeFilterButton();

            const visualDiv = document.getElementById('filteredCardsVisual');
            if (visualDiv) visualDiv.classList.remove('show');

            applyCardFilters();
        }

        function renderFilteredCards() {
            const tbody = document.getElementById('filteredCardsBody');
            const countEl = document.getElementById('filteredCardCount');

            if (!tbody || !countEl) return;

            countEl.textContent = `${filteredCards.length} Karten`;
            tbody.innerHTML = '';

            if (filteredCards.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="6" class="loading">Keine Karten gefunden.</td>`;
                tbody.appendChild(row);
                return;
            }

            // Sort cards by type, then set code, then set number
            const sortedCards = [...filteredCards].sort((a, b) => {
                // First sort by card type
                const typeOrder = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
                const typeA = typeOrder.indexOf(a.card_type || 'Unknown');
                const typeB = typeOrder.indexOf(b.card_type || 'Unknown');
                if (typeA !== typeB) return (typeA === -1 ? 999 : typeA) - (typeB === -1 ? 999 : typeB);
                
                // Then by set code (alphabetically)
                const setCodeA = (a.set_code || '').toString();
                const setCodeB = (b.set_code || '').toString();
                if (setCodeA !== setCodeB) return setCodeA.localeCompare(setCodeB);
                
                // Then by set number (numerically)
                const numA = parseInt(a.set_number || '0', 10);
                const numB = parseInt(b.set_number || '0', 10);
                if (numA !== numB) return numA - numB;
                
                // Finally by name
                return (a.card_name || '').localeCompare(b.card_name || '');
            });

            sortedCards.forEach(card => {
                const row = document.createElement('tr');

                const imgCell = document.createElement('td');
                if (card.image_url) {
                    const img = document.createElement('img');
                    img.className = 'card-thumbnail';
                    img.src = card.image_url;
                    img.alt = card.card_name;
                    img.onerror = () => loadCardImageWithProxy(img, card.image_url, card.card_name, 1);
                    imgCell.appendChild(img);
                } else {
                    imgCell.innerHTML = `<div class="card-thumbnail-placeholder">üÉè</div>`;
                }

                const nameCell = document.createElement('td');
                nameCell.textContent = card.card_name;

                const setCell = document.createElement('td');
                setCell.textContent = card.set_code;

                const numberCell = document.createElement('td');
                numberCell.textContent = card.set_number;

                const typeCell = document.createElement('td');
                typeCell.textContent = card.card_type;

                const totalCell = document.createElement('td');
                totalCell.textContent = card.max_count;

                row.appendChild(imgCell);
                row.appendChild(nameCell);
                row.appendChild(setCell);
                row.appendChild(numberCell);
                row.appendChild(typeCell);
                row.appendChild(totalCell);

                tbody.appendChild(row);
            });
        }

        function copyFilteredCards() {
            if (!filteredCards || filteredCards.length === 0) {
                alert('Keine Karten zum Kopieren vorhanden.');
                return;
            }

            const lines = filteredCards.map(card => {
                const parts = [card.card_name, card.set_code, card.set_number].filter(Boolean);
                return parts.join(' ');
            });

            const textToCopy = lines.join('\n');

            navigator.clipboard.writeText(textToCopy).then(() => {
                alert('‚úÖ Gefilterte Karten wurden kopiert!');
            }).catch(() => {
                prompt('Kopiere die Liste:', textToCopy);
            });
        }
        
        function filterDeckList() {
            const searchTerm = document.getElementById('deckSearch').value.toLowerCase();
            const deckSelect = document.getElementById('deckSelect');
            const options = deckSelect.getElementsByTagName('option');
            
            for (let i = 1; i < options.length; i++) { // Skip first "-- Bitte..." option
                const optionText = options[i].textContent.toLowerCase();
                if (optionText.includes(searchTerm)) {
                    options[i].style.display = '';
                } else {
                    options[i].style.display = 'none';
                }
            }
            
            // Also filter variant options based on search term
            filterVariantOptions(searchTerm);
        }
        
        function filterVariantOptions(searchTerm) {
            const variantOptions = document.getElementById('variantOptions');
            if (!variantOptions) return;
            
            const checkboxes = variantOptions.querySelectorAll('.variant-checkbox');
            checkboxes.forEach(checkbox => {
                const label = checkbox.querySelector('span');
                const variantText = label.textContent.toLowerCase();
                if (variantText.includes(searchTerm)) {
                    checkbox.style.display = '';
                } else {
                    checkbox.style.display = 'none';
                }
            });
        }
        
        function onVariantSearchInput() {
            const searchInput = document.getElementById('variantSearchInput');
            const searchTerm = searchInput.value.toLowerCase();
            filterVariantOptions(searchTerm);
        }
        
        function onDeckChange() {
            const selectedDeck = document.getElementById('deckSelect').value;
            console.log('[onDeckChange] Called - selectedDeck:', selectedDeck);
            if (!selectedDeck) {
                console.log('[onDeckChange] No deck selected, returning');
                return;
            }
            
            console.log('[onDeckChange] Calling updateStats, updateVariantSelector, updateCardsDisplay');
            updateStats(selectedDeck);
            updateVariantSelector(selectedDeck);
            updateCardsDisplay();
        }
        
        let selectedVariants = [];
        let variantsCollapsed = true;

        function toggleVariantSelector() {
            const variantOptions = document.getElementById('variantOptions');
            const toggle = document.getElementById('variantToggle');
            if (!variantOptions || !toggle) return;

            variantsCollapsed = !variantsCollapsed;
            variantOptions.style.display = variantsCollapsed ? 'none' : 'flex';
            toggle.classList.toggle('collapsed', variantsCollapsed);
        }
        
        function updateVariantSelector(mainDeck) {
            const variantSelector = document.getElementById('variantSelector');
            const variantOptions = document.getElementById('variantOptions');
            
            // Clear previous selections
            selectedVariants = [];
            
            // Get all unique archetypes from cardsData
            const cardsDataArchetypes = [...new Set(cardsData.map(c => c.archetype))];
            
            // Combine all available decks: cardsData + Top 20 Limitless + Top 10 City League
            const allAvailableDecks = new Set([
                ...cardsDataArchetypes,
                ...top20LimitlessArchetypes,
                ...top10CityLeagueArchetypes
            ]);
            
            // Convert to array and sort
            const allArchetypes = Array.from(allAvailableDecks).sort();
            
            // Filter out the main deck
            const variants = allArchetypes.filter(arch => 
                normalizeArchetypeName(arch) !== normalizeArchetypeName(mainDeck)
            );
            
            console.log('Variant Selector - Main deck:', mainDeck, '| Other archetypes available:', variants.length);
            
            if (variants.length === 0) {
                console.log('No variants found, hiding selector');
                variantSelector.style.display = 'none';
                return;
            }
            
            // Show selector and populate options with ALL available archetypes
            console.log('Showing variant selector with', variants.length, 'options');
            variantSelector.style.display = 'block';
            
            // Reset search field
            const searchInput = document.getElementById('variantSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            
            variantOptions.innerHTML = variants.map(variant => {
                const safeVariant = variant.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                return `
                    <label class="variant-checkbox">
                        <input type="checkbox" value="${safeVariant}" onchange="toggleVariant('${safeVariant}')">
                        <span>${variant}</span>
                    </label>
                `;
            }).join('');

            variantsCollapsed = true;
            variantOptions.style.display = 'none';
            const toggle = document.getElementById('variantToggle');
            if (toggle) {
                toggle.classList.add('collapsed');
            }
        }
        
        function toggleVariant(variantName) {
            const checkbox = document.querySelector(`input[value="${variantName}"]`);
            const label = checkbox.parentElement;
            
            if (checkbox.checked) {
                selectedVariants.push(variantName);
                label.classList.add('selected');
            } else {
                selectedVariants = selectedVariants.filter(v => v !== variantName);
                label.classList.remove('selected');
            }
            
            updateCardsDisplay();
        }
        
        // Cards Table Toggle
        let cardsCollapsed = true;

        function toggleCardsTable() {
            const cardsTableContent = document.getElementById('cardsTableContent');
            const toggle = document.getElementById('cardsToggle');
            if (!cardsTableContent || !toggle) return;

            cardsCollapsed = !cardsCollapsed;
            cardsTableContent.style.display = cardsCollapsed ? 'none' : 'block';
            toggle.classList.toggle('collapsed', cardsCollapsed);
        }
        
        // Card Search Filter
        function filterCards() {
            const searchInput = document.getElementById('cardSearchInput');
            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            const tbody = document.getElementById('cardsBody');
            
            if (!tbody) return;
            
            const rows = tbody.querySelectorAll('tr');
            rows.forEach(row => {
                // Skip loading/error rows
                if (row.cells.length === 1) {
                    row.style.display = '';
                    return;
                }
                
                const cardName = row.cells[2] ? row.cells[2].textContent.toLowerCase() : '';
                const setName = row.cells[3] ? row.cells[3].textContent.toLowerCase() : '';
                
                if (cardName.includes(searchTerm) || setName.includes(searchTerm)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        function updateStats(deckName) {
            const statsSection = document.getElementById('statsSection');
            
            // Set the current main deck for opponent matchup analyzer
            currentMainDeckName = deckName;
            
            // Get both data sources
            const cityLeagueMatch = cityLeagueData.find(m => 
                normalizeArchetypeName(m.archetype) === normalizeArchetypeName(deckName)
            );
            
            // Get Limitless data from the main decks CSV (which has rank and win_rate)
            const limitlessMatch = matchupsData.find(m => 
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(deckName)
            );
            
            // Find Limitless deck stats from parsed HTML (has Total WR and Vs Top20 Matchup)
            let limitlessDeckInfo = null;
            for (const [deckKey, stats] of Object.entries(limitlessDeckStats)) {
                if (normalizeArchetypeName(deckKey) === normalizeArchetypeName(deckName)) {
                    limitlessDeckInfo = stats;
                    break;
                }
            }
            
            // Show section if we have ANY data
            if (cityLeagueMatch || limitlessMatch || limitlessDeckInfo) {
                statsSection.style.display = 'block';
                
                // RANKING: Limitless HTML stats > Limitless CSV > none
                if (limitlessDeckInfo && limitlessDeckInfo.rank) {
                    document.getElementById('statRanking').textContent = `#${limitlessDeckInfo.rank}`;
                } else if (limitlessMatch && limitlessMatch.rank) {
                    document.getElementById('statRanking').textContent = `#${limitlessMatch.rank}`;
                } else {
                    document.getElementById('statRanking').textContent = '-';
                }
                
                // WIN RATE: Limitless HTML stats > Limitless CSV > City League
                if (limitlessDeckInfo && limitlessDeckInfo.wr) {
                    document.getElementById('statWinRate').textContent = limitlessDeckInfo.wr;
                } else if (limitlessMatch && limitlessMatch.win_rate) {
                    document.getElementById('statWinRate').textContent = limitlessMatch.win_rate;
                } else if (cityLeagueMatch && cityLeagueMatch.new_avg_placement) {
                    document.getElementById('statWinRate').textContent = cityLeagueMatch.new_avg_placement;
                } else {
                    document.getElementById('statWinRate').textContent = '-';
                }
                
                // √ò PLATZIERUNG: City League avg placement
                if (cityLeagueMatch && cityLeagueMatch.new_avg_placement) {
                    document.getElementById('statMatches').textContent = cityLeagueMatch.new_avg_placement;
                } else if (limitlessMatch && limitlessMatch.count) {
                    document.getElementById('statMatches').textContent = limitlessMatch.count;
                } else {
                    document.getElementById('statMatches').textContent = '-';
                }
                
                // VS TOP 20: Limitless HTML stats > getMatchupBalance > City League status
                if (limitlessDeckInfo && limitlessDeckInfo.matchup) {
                    document.getElementById('statBalance').textContent = limitlessDeckInfo.matchup;
                } else {
                    const matchupBalance = getMatchupBalance(deckName);
                    if (matchupBalance) {
                        document.getElementById('statBalance').textContent = `${matchupBalance.over50}:${matchupBalance.under50}`;
                    } else if (cityLeagueMatch && cityLeagueMatch.status) {
                        // Fallback: Show City League status
                        const status = cityLeagueMatch.status;
                        let statusEmoji = '‚óè';
                        if (status === 'NEU') statusEmoji = 'üÜï';
                        else if (status === 'BESTEHEND') statusEmoji = '‚úì';
                        else if (status === 'VERSCHWUNDEN') statusEmoji = '‚ùå';
                        document.getElementById('statBalance').textContent = `${statusEmoji} ${status}`;
                    } else if (limitlessMatch) {
                        document.getElementById('statBalance').textContent = '‚úì KOMPETITIV';
                    } else {
                        document.getElementById('statBalance').textContent = '-';
                    }
                }
                
                // MATCHUPS: IMMER aus Limitless Matchup-Daten, wenn vorhanden
                console.log('[updateStats] Checking matchups - limitlessMatchupData keys:', Object.keys(limitlessMatchupData).length, 'matchupDetailsData length:', matchupDetailsData.length);
                if ((limitlessMatchupData && Object.keys(limitlessMatchupData).length > 0) ||
                    (matchupDetailsData && matchupDetailsData.length > 0)) {
                    console.log('[updateStats] Matchup condition TRUE, calling updateMatchupsDisplay for:', deckName);
                    if (!limitlessMatchupData || Object.keys(limitlessMatchupData).length === 0) {
                        console.log('[updateStats] Rebuilding limitlessMatchupData from matchupDetailsData');
                        limitlessMatchupData = buildLimitlessMatchupData(matchupDetailsData);
                    }
                    updateMatchupsDisplay(deckName);
                    
                    // SHOW/HIDE Matchups section when we have the data
                    const matchupsSection = document.getElementById('matchupsSection');
                    if (matchupsSection) {
                        matchupsSection.style.display = 'block';
                    }
                } else if (cityLeagueMatch) {
                    console.log('[updateStats] Matchup condition FALSE - using City League fallback');
                    // Fallback: City League Trend-Info
                    const status = cityLeagueMatch.status || 'UNBEKANNT';
                    const trend = cityLeagueMatch.trend || '-';
                    const change = cityLeagueMatch.appearances_change || '0';
                    
                    let statusEmoji = '‚óè';
                    if (status === 'NEU') statusEmoji = 'üÜï';
                    else if (status === 'BESTEHEND') statusEmoji = '‚úì';
                    else if (status === 'VERSCHWUNDEN') statusEmoji = '‚ùå';
                    
                    let trendEmoji = '‚Üí';
                    if (trend === 'STEIGEND') trendEmoji = 'üìà';
                    else if (trend === 'FALLEND') trendEmoji = 'üìâ';
                    else if (trend === 'STABIL') trendEmoji = '‚û°Ô∏è';
                    
                    document.getElementById('topMatchups').innerHTML = `
                        <div class="matchup-item">
                            <span><strong>Status:</strong> ${statusEmoji} ${status}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Trend:</strong> ${trendEmoji} ${trend}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Ver√§nderung:</strong></span>
                            <span style="color: ${change > 0 ? '#28a745' : change < 0 ? '#dc3545' : '#666'}; font-weight: bold;">
                                ${change > 0 ? '+' : ''}${change} Auftritte
                            </span>
                        </div>
                    `;
                    
                    const placementChange = parseFloat(cityLeagueMatch.placement_change || '0').toFixed(1);
                    const avgPlacement = cityLeagueMatch.new_avg_placement || '-';
                    document.getElementById('worstMatchups').innerHTML = `
                        <div class="matchup-item">
                            <span><strong>Alte √ò Platzierung:</strong></span>
                            <span>${cityLeagueMatch.old_avg_placement || '-'}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Neue √ò Platzierung:</strong></span>
                            <span>${avgPlacement}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>√Ñnderung:</strong></span>
                            <span style="color: ${placementChange < 0 ? '#28a745' : placementChange > 0 ? '#dc3545' : '#666'}; font-weight: bold;">
                                ${placementChange > 0 ? '+' : ''}${placementChange}
                            </span>
                        </div>
                        <p style="margin-top: 15px; color: #666; font-size: 0.9em;">
                            <strong>Info:</strong> City League Daten zeigen Trends √ºber Zeitr√§ume, keine direkten Matchups.
                        </p>
                    `;
                }
                
            } else {
                statsSection.style.display = 'none';
            }
            
            // Show/hide Matchups section based on Limitless matchup data availability
            const matchupsSection = document.getElementById('matchupsSection');
            if ((limitlessMatchupData && Object.keys(limitlessMatchupData).length > 0 && currentMainDeckName) ||
                (matchupDetailsData && matchupDetailsData.length > 0 && currentMainDeckName)) {
                matchupsSection.style.display = 'block';
            } else {
                matchupsSection.style.display = 'none';
            }
        }
        
        function normalizeArchetypeName(name) {
            if (!name) return '';
            return name.toLowerCase().trim()
                .replace(/\s+/g, ' ')
                .replace(/[√†√°√¢√£√§√•]/g, 'a')
                .replace(/[√®√©√™√´]/g, 'e')
                .replace(/[√¨√≠√Æ√Ø]/g, 'i')
                .replace(/[√≤√≥√¥√µ√∂]/g, 'o')
                .replace(/[√π√∫√ª√º]/g, 'u');
        }

        function getMatchupBalance(deckName) {
            if (!matchupDetailsData || matchupDetailsData.length === 0) return null;
            if (!matchupsData || matchupsData.length === 0) return null;

            // Get Top 20 deck names from Limitless Online rankings
            const top20Names = matchupsData.slice(0, 20).map(d => normalizeArchetypeName(d.deck_name || d.deck_name));
            console.log('[getMatchupBalance] Top 20 names:', top20Names);

            const deckMatchups = matchupDetailsData.filter(m =>
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(deckName)
            );

            if (deckMatchups.length === 0) return null;

            let over50 = 0;
            let under50 = 0;

            deckMatchups.forEach(m => {
                // Only count if opponent is in Top 20
                const opponentName = m.opponent || m.opponent_deck;
                if (!top20Names.includes(normalizeArchetypeName(opponentName))) {
                    return;
                }
                
                const winRate = parseFloat(String(m.win_rate || '').replace('%', '').replace(',', '.'));
                if (Number.isNaN(winRate)) return;
                if (winRate > 50) over50 += 1;
                else if (winRate < 50) under50 += 1;
            });

            return { over50, under50 };
        }
        
        function updateMatchupsDisplay(deckName) {
            console.log('[updateMatchupsDisplay] Called with deckName:', deckName);
            console.log('[updateMatchupsDisplay] limitlessMatchupData keys:', Object.keys(limitlessMatchupData).slice(0, 5));
            console.log('[updateMatchupsDisplay] matchupDetailsData length:', matchupDetailsData.length);
            
            // Find the correct deck name in limitlessMatchupData (case-insensitive)
            let matchingDeckName = null;
            for (const key of Object.keys(limitlessMatchupData)) {
                if (normalizeArchetypeName(key) === normalizeArchetypeName(deckName)) {
                    matchingDeckName = key;
                    break;
                }
            }
            
            console.log('[updateMatchupsDisplay] Looking for deck:', deckName, 'Found:', matchingDeckName, 'Available decks:', Object.keys(limitlessMatchupData).slice(0, 5));
            
            if (!matchingDeckName || !limitlessMatchupData[matchingDeckName]) {
                console.warn('[updateMatchupsDisplay] No matchup data for:', deckName);
                document.getElementById('topMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px; text-align: center; color: #999;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                document.getElementById('worstMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px; text-align: center; color: #999;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                return;
            }
            
            // Convert matchup data to array format
            const opponents = limitlessMatchupData[matchingDeckName];
            let matchupList = Object.values(opponents).map(m => ({
                opponent_deck: m.opponent_deck || m.opponent || '',
                win_rate: m.win_rate || '0%',
                win_rate_numeric: m.win_rate_numeric || 0,
                record: m.record || '',
                total_games: m.total_games || 0
            }));
            
            console.log('[updateMatchupsDisplay] Found', matchupList.length, 'matchups for', matchingDeckName);
            
            if (matchupList.length === 0) {
                document.getElementById('topMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                document.getElementById('worstMatchups').innerHTML = '<tr><td colspan="3" style="padding: 10px;">Keine Matchup-Daten verf√ºgbar</td></tr>';
                return;
            }
            
            // Sort by win rate (numeric)
            matchupList.sort((a, b) => {
                const aRate = a.win_rate_numeric || 0;
                const bRate = b.win_rate_numeric || 0;
                return bRate - aRate;
            });
            
            // Get top matchups (>50% WR) and worst matchups (<50% WR)
            const topMatchups = matchupList.filter(m => m.win_rate_numeric > 50).slice(0, 5);
            const worstMatchups = matchupList.filter(m => m.win_rate_numeric < 50).reverse().slice(0, 5);
            
            // Render Top Matchups
            const topHtml = topMatchups.map(m => `
                <tr>
                    <td style="padding: 8px;"><strong>${m.opponent_deck}</strong></td>
                    <td style="padding: 8px; text-align: right;"><strong>${m.win_rate}</strong></td>
                    <td style="padding: 8px; text-align: right;">${m.record}</td>
                </tr>
            `).join('');
            document.getElementById('topMatchups').innerHTML = topHtml || '<tr><td colspan="3" style="padding: 10px;">Keine gewonnenen Matchups</td></tr>';
            
            // Render Worst Matchups
            const worstHtml = worstMatchups.map(m => `
                <tr>
                    <td style="padding: 8px;"><strong>${m.opponent_deck}</strong></td>
                    <td style="padding: 8px; text-align: right;"><strong>${m.win_rate}</strong></td>
                    <td style="padding: 8px; text-align: right;">${m.record}</td>
                </tr>
            `).join('');
            document.getElementById('worstMatchups').innerHTML = worstHtml || '<tr><td colspan="3" style="padding: 10px;">Keine verlorenen Matchups</td></tr>';
            
            // Populate opponent dropdown with all available opponents
            const opponentSelect = document.getElementById('opponentSelect');
            const allOpponents = new Set(matchupList.map(m => m.opponent_deck).sort());
            opponentSelect.innerHTML = '<option value="">-- Select a deck --</option>' + 
                Array.from(allOpponents).map(opp => `<option value="${opp}">${opp}</option>`).join('');
            
            // Update matchup deck title
            const matchupsDeckTitle = document.getElementById('matchupsDeckTitle');
            if (matchupsDeckTitle) {
                matchupsDeckTitle.textContent = deckName;
            }
        }
        
        function showMatchupAnalyzer(opponentDeck) {
            const detailsDiv = document.getElementById('matchupAnalysisDetails');
            
            if (!opponentDeck || !currentMainDeckName) {
                detailsDiv.style.display = 'none';
                return;
            }
            
            // Get matchup info from limitlessMatchupData
            let mainDeckKey = null;
            for (const key of Object.keys(limitlessMatchupData)) {
                if (normalizeArchetypeName(key) === normalizeArchetypeName(currentMainDeckName)) {
                    mainDeckKey = key;
                    break;
                }
            }
            const mainDeckData = mainDeckKey ? limitlessMatchupData[mainDeckKey] : null;
            if (!mainDeckData || !mainDeckData[opponentDeck]) {
                detailsDiv.innerHTML = `<p style="color: #e74c3c;">Keine Matchup-Daten f√ºr ${opponentDeck}</p>`;
                detailsDiv.style.display = 'block';
                return;
            }
            
            const matchup = mainDeckData[opponentDeck];
            const wr = matchup.win_rate || 'N/A';
            const wrNum = matchup.win_rate_numeric || 0;
            const record = matchup.record || 'N/A';
            const games = matchup.total_games || 0;
            const wrColor = wrNum > 50 ? '#27ae60' : '#e74c3c';
            
            detailsDiv.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: center;">
                    <div>
                        <div><strong>Matchup:</strong> ${currentMainDeckName} vs ${opponentDeck}</div>
                        <div style="margin-top: 10px;"><strong>Record:</strong> ${record}</div>
                        <div><strong>Games:</strong> ${games}</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 0.9em; color: #666; margin-bottom: 5px;">WIN RATE</div>
                        <div style="font-size: 2.5em; font-weight: bold; color: ${wrColor};">${wr}</div>
                    </div>
                    <div style="text-align: center; padding: 15px; background: white; border-radius: 4px;">
                        <div style="font-size: 0.85em; color: #999; margin-bottom: 10px;">MATCHUP</div>
                        <div style="font-size: 3em; font-weight: bold; color: ${wrColor};">${wrNum.toFixed(1)}%</div>
                    </div>
                </div>
            `;
            detailsDiv.style.display = 'block';
        }
        
        function updateCardsDisplay() {
            // Meta-Main-Filter logic
            const selectedMeta = getSelectedMetaMainOptions();
            const selectedDeck = document.getElementById('deckSelect').value;
            const filter = document.getElementById('filterSelect').value;
            
            if (!selectedDeck) {
                document.getElementById('cardsBody').innerHTML = '<tr><td colspan="7" class="loading">Bitte w√§hle ein Deck aus...</td></tr>';
                document.getElementById('deckVisual').style.display = 'none';
                return;
            }
            
            // Filter cards for selected deck AND selected variants
            const decksToInclude = [selectedDeck, ...selectedVariants];
            let deckCards = cardsData.filter(c => decksToInclude.includes(c.archetype));
            
            // Apply meta filter to cards
            if (selectedMeta.size > 0) {
                deckCards = deckCards.filter(card => cardMatchesSelectedMeta(card, selectedMeta));
            }
            
            console.log('Initial filtered cards:', deckCards.length, 'from archetype:', selectedDeck);
            if (deckCards.length > 0) {
                console.log('First card image_url:', deckCards[0].image_url);
            }
            
            // Aggregate cards by name (combine same cards from different variants)
            const cardMap = new Map();
            deckCards.forEach(card => {
                const key = `${card.card_name}_${card.set_code}_${card.set_number}`;
                if (!cardMap.has(key)) {
                    cardMap.set(key, { ...card, sources: [card.archetype] });
                } else {
                    const existing = cardMap.get(key);
                    if (!existing.sources.includes(card.archetype)) {
                        existing.sources.push(card.archetype);
                    }
                }
            });
            
            deckCards = Array.from(cardMap.values());
            
            console.log('After aggregation:', deckCards.length, 'cards');
            if (deckCards.length > 0) {
                console.log('First aggregated card:', deckCards[0].card_name, 'image_url:', deckCards[0].image_url);
            }
            
            // Meta filter applied before aggregation.
            // Apply percentage filter (only for main deck)
            if (filter === '90') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 90 ||
                    c.archetype !== selectedDeck
                );
            } else if (filter === '70') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 70 ||
                    c.archetype !== selectedDeck
                );
            } else if (filter === '50') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 50 ||
                    c.archetype !== selectedDeck
                );
            }
            
            // Update count
            document.getElementById('cardCount').textContent = `${deckCards.length} Karten`;
            
            // Sort cards by type (Pokemon, Supporter, Item, Tool, Stadium, Special Energy, Energy)
console.log('BEFORE SORT - All cards count:', deckCards.length);

            deckCards = sortCardsByType(deckCards);

            console.log('AFTER SORT - ALL CARDS with category:');
            console.table(deckCards.map((c, idx) => {
                const cardType = c.type || '';
                let category = 'Unknown';
                if (cardType && cardType.charAt(0).match(/[GRWLPFDMNC]/)) {
                    category = 'Pokemon';
                } else if (cardType === 'Supporter') {
                    category = 'Supporter';
                } else if (cardType === 'Item') {
                    category = 'Item';
                } else if (cardType === 'Tool') {
                    category = 'Tool';
                } else if (cardType === 'Stadium') {
                    category = 'Stadium';
                } else if (cardType === 'Energy' || cardType === 'Special Energy') {
                    category = cardType;
                }
                return {
                    '#': idx + 1,
                    name: c.card_name,
                    type: c.type,
                    category: category
                };
            }));
            
            // Save for image generation
            currentDeckCards = deckCards;
            
            // Show/hide generate image button
            const generateBtn = document.getElementById('generateDeckCardsBtn');
            const copyAllBtn = document.getElementById('copyAllCardsBtn');
            if (generateBtn) {
                generateBtn.style.display = deckCards.length > 0 ? 'block' : 'none';
            }
            if (copyAllBtn) {
                copyAllBtn.style.display = deckCards.length > 0 ? 'block' : 'none';
            }
            
            // Update deck visual grid
            updateDeckVisual(deckCards);
            
            // Display cards in table
            const tbody = document.getElementById('cardsBody');
            if (deckCards.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="loading">Keine Karten gefunden</td></tr>';
                return;
            }
            
            console.log('Final deck cards for display:', deckCards.length);
            if (deckCards.length > 0) {
                console.log('Sample card:', {
                    name: deckCards[0].card_name,
                    imageUrl: deckCards[0].image_url,
                    hasImage: !!deckCards[0].image_url
                });
            }
            
            tbody.innerHTML = deckCards.map(card => {
                const percentage = parseFloat(card.percentage_in_archetype.replace(',', '.'));
                const imageUrl = card.image_url || '';
                
                // Create thumbnail HTML
                let thumbnailHtml;
                if (imageUrl && imageUrl.trim() !== '') {
                    thumbnailHtml = `<img src="${imageUrl}" alt="${card.card_name}" class="card-thumbnail" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;" referrerpolicy="no-referrer" onerror="this.style.display='none'">`;
                } else {
                    thumbnailHtml = `<div class="card-thumbnail-placeholder">üÉè</div>`;
                }
                
                // Show source decks if from variants
                let sourceInfo = '';
                if (card.sources && card.sources.length > 1) {
                    sourceInfo = `<br><small style="color: #667eea;">aus: ${card.sources.join(', ')}</small>`;
                } else if (card.sources && card.sources[0] !== document.getElementById('deckSelect').value) {
                    sourceInfo = `<br><small style="color: #667eea;">aus: ${card.sources[0]}</small>`;
                }
                
                return `
                    <tr>
                        <td>${thumbnailHtml}</td>
                        <td class="card-count">${card.max_count}</td>
                        <td><strong>${card.card_name}</strong>${sourceInfo}</td>
                        <td>${card.set_code || '-'}</td>
                        <td>${card.set_number || '-'}</td>
                        <td><span style="color: ${percentage > 70 ? '#28a745' : percentage > 50 ? '#ffc107' : '#666'}; font-weight: bold;">${card.percentage_in_archetype}%</span></td>
                        <td><button class="btn btn-sm btn-add" data-identifier="${card.card_identifier}" data-max-count="${card.max_count}" data-card-name="${card.card_name}" data-image-url="${imageUrl}" data-set-code="${card.set_code || ''}" data-set-number="${card.set_number || ''}">‚ûï Hinzuf√ºgen</button></td>
                    </tr>
                `;
            }).join('');
        }
        
        function updateDeckVisual(deckCards) {
            const deckGrid = document.getElementById('deckGrid');
            const deckVisual = document.getElementById('deckVisual');
            
            if (deckCards.length === 0) {
                deckVisual.style.display = 'none';
                return;
            }
            
            deckVisual.style.display = 'block';
            
            // Sort cards before displaying
            const sortedCards = sortCardsByType([...deckCards]);
            
            // Show cards with images prominently
            deckGrid.innerHTML = sortedCards.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.card_name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">üÉè</div>
                                <div>${card.card_name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function showCardImage(imageUrl, cardName) {
            // Create modal to show full card image
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            modal.innerHTML = `
                <div style="max-width: 90%; max-height: 90%; text-align: center;">
                    <img src="${imageUrl}" alt="${cardName}" style="max-width: 100%; max-height: 80vh; border-radius: 15px; box-shadow: 0 10px 50px rgba(0,0,0,0.5);">
                    <div style="color: white; margin-top: 20px; font-size: 1.5em; font-weight: bold;">${cardName}</div>
                    <div style="color: #ccc; margin-top: 10px;">Klicke irgendwo, um zu schlie√üen</div>
                </div>
            `;
            
            modal.onclick = () => document.body.removeChild(modal);
            document.body.appendChild(modal);
        }
        
        function addToDeck(cardIdentifier, maxCount, cardName, imageUrl, setCode, setNumber) {
            const existingCard = myDeck.find(c => c.identifier === cardIdentifier);
            
            if (existingCard) {
                if (existingCard.count < Math.min(4, maxCount)) {
                    existingCard.count++;
                }
            } else {
                // Find card type from cardsData
                const cardData = cardsData.find(c => c.card_identifier === cardIdentifier);
                const cardType = cardData ? cardData.type : '';
                
                myDeck.push({
                    identifier: cardIdentifier,
                    name: cardName,
                    count: 1,
                    maxCount: Math.min(4, maxCount),
                    imageUrl: imageUrl,
                    type: cardType,
                    setCode: setCode || (cardData ? cardData.set_code : ''),
                    setNumber: setNumber || (cardData ? cardData.set_number : ''),
                    percentage_in_archetype: cardData ? cardData.percentage_in_archetype : '0'
                });
            }
            
            updateDeckDisplay();
        }
        
        function removeFromDeck(cardName) {
            const card = myDeck.find(c => c.name === cardName);
            if (card) {
                card.count--;
                if (card.count <= 0) {
                    myDeck = myDeck.filter(c => c.name !== cardName);
                }
            }
            updateDeckDisplay();
        }
        
        function updateDeckDisplay() {
            const deckList = document.getElementById('deckList');
            const totalCards = myDeck.reduce((sum, card) => sum + card.count, 0);
            
            document.getElementById('deckCardCount').textContent = totalCards;
            
            // Update visual grid
            updateMyDeckVisual();
            
            if (myDeck.length === 0) {
                deckList.innerHTML = '<p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>';
                return;
            }
            
            deckList.innerHTML = myDeck.map(card => {
                let cardVisual = '';
                if (card.imageUrl && card.imageUrl.trim() !== '') {
                    cardVisual = `
                        <div style="width: 60px; height: 80px; margin-right: 10px; cursor: pointer;" data-image-url="${card.imageUrl}" data-card-name="${card.name}">
                            <img src="${card.imageUrl}" alt="${card.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);" referrerpolicy="no-referrer" onerror="this.style.display='none'">
                        </div>
                    `;
                } else {
                    cardVisual = `
                        <div style="width: 60px; height: 80px; margin-right: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 5px; display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;">
                            üÉè
                        </div>
                    `;
                }
                
                return `
                    <div class="deck-card" style="display: flex; align-items: center;">
                        ${cardVisual}
                        <div style="flex: 1;">
                            <strong>${card.count}x ${card.name}</strong>
                            <br><small style="color: #666;">${card.setCode || ''} ${card.setNumber || ''}</small>
                        </div>
                        <div class="deck-card-controls">
                            <button class="btn-add" data-identifier="${card.identifier}" data-max-count="${card.maxCount}" data-card-name="${card.name}" data-image-url="${card.imageUrl || ''}" data-set-code="${card.setCode || ''}" data-set-number="${card.setNumber || ''}">+</button>
                            <button class="btn-remove" data-card-name="${card.name}">-</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateMyDeckVisual() {
            const myDeckVisual = document.getElementById('myDeckVisual');
            const myDeckGrid = document.getElementById('myDeckGrid');
            
            if (myDeck.length === 0) {
                myDeckVisual.style.display = 'none';
                return;
            }
            
            myDeckVisual.style.display = 'block';
            
            // Sort deck by type before displaying
            const sortedDeck = sortCardsByType([...myDeck]);
            
            // Show each card ONCE with count badge (nicht mehrfach)
            myDeckGrid.innerHTML = sortedDeck.map(card => {
                const imageUrl = card.imageUrl || '';
                const count = card.count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" data-image-url="${imageUrl}" data-card-name="${card.name}" style="cursor: pointer;">
                            <img src="${imageUrl}" alt="${card.name}" referrerpolicy="no-referrer" onerror="this.style.display='none'">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">\ud83c\udccf</div>
                                <div>${card.name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function clearDeck() {
            if (confirm('Willst du das Deck wirklich leeren?')) {
                myDeck = [];
                updateDeckDisplay();
            }
        }
        
        function copyDeckToClipboard() {
            if (myDeck.length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            let deckText = '';
            myDeck.forEach(card => {
                deckText += `${card.count}x ${card.name}\n`;
            });
            
            // Copy to clipboard
            navigator.clipboard.writeText(deckText).then(() => {
                alert(`${myDeck.length} Karten in die Zwischenablage kopiert!\n\n${deckText}`);
            }).catch(() => {
                // Fallback f√ºr √§ltere Browser
                const textarea = document.createElement('textarea');
                textarea.value = deckText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`${myDeck.length} Karten in die Zwischenablage kopiert!\n\n${deckText}`);
            });
        }
        
        function autoComplete() {
            const selectedDeck = document.getElementById('deckSelect').value;
            if (!selectedDeck) {
                alert('Bitte w√§hle zuerst ein Deck aus!');
                return;
            }
            
            myDeck = [];
            let deckCards = cardsData.filter(c => c.archetype === selectedDeck);
            
            // Separate cards into Core (>90%) and Optional (‚â§90%)
            let coreCards = [];
            let optionalCards = [];
            
            deckCards.forEach(card => {
                const percentage = parseFloat((card.percentage_in_archetype || '0').toString().replace(',', '.'));
                if (percentage > 90) {
                    coreCards.push(card);
                } else {
                    optionalCards.push(card);
                }
            });
            
            // Sort both groups by type, then by percentage
            coreCards = sortCardsByType(coreCards);
            optionalCards = sortCardsByType(optionalCards);
            
            let totalCards = 0;
            
            // Step 1: Add all Core cards (>90%)
            for (const card of coreCards) {
                if (totalCards >= 60) break;
                
                // Berechne Durchschnitt: total_count / deck_count
                const avgCount = parseFloat(card.total_count) / parseFloat(card.deck_count);
                const recommendedCount = Math.round(avgCount);
                
                const count = Math.min(
                    Math.max(1, recommendedCount || 1),
                    4,
                    60 - totalCards
                );
                
                if (count > 0) {
                    myDeck.push({
                        identifier: card.card_identifier,
                        name: card.card_name,
                        count: count,
                        maxCount: 4,
                        imageUrl: card.image_url || '',
                        type: card.type || '',
                        setCode: card.set_code || '',
                        setNumber: card.set_number || '',
                        percentage_in_archetype: card.percentage_in_archetype || '0'
                    });
                    totalCards += count;
                }
            }
            
            // Step 2: Fill remaining slots with Optional cards (‚â§90%)
            for (const card of optionalCards) {
                if (totalCards >= 60) break;
                
                const avgCount = parseFloat(card.total_count) / parseFloat(card.deck_count);
                const recommendedCount = Math.round(avgCount);
                
                const count = Math.min(
                    recommendedCount || 1,
                    4,
                    60 - totalCards
                );
                
                if (count > 0) {
                    myDeck.push({
                        identifier: card.card_identifier,
                        name: card.card_name,
                        count: count,
                        maxCount: Math.min(4, recommendedCount || 4),
                        imageUrl: card.image_url || '',
                        type: card.type || '',
                        setCode: card.set_code || '',
                        setNumber: card.set_number || '',
                        percentage_in_archetype: card.percentage_in_archetype || '0'
                    });
                    totalCards += count;
                }
            }
            
            updateDeckDisplay();
        }
        
        function exportToPokemonLive() {
            if (myDeck.length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            let exportText = 'Pok√©mon: \n';
            let trainerText = 'Trainer: \n';
            let energyText = 'Energy: \n';
            
            myDeck.forEach(card => {
                // Format: Anzahl Kartenname Set Set-Nummer
                const setInfo = (card.setCode && card.setNumber) 
                    ? `${card.setCode} ${card.setNumber}` 
                    : '';
                const line = `${card.count} ${card.name} ${setInfo}`.trim() + '\n';
                
                // Determine card type dynamically using getCardType()
                const cardType = card.type || getCardType(card.name);
                
                // Trainer cards: Supporter, Item, Tool, Stadium
                if (cardType === 'Supporter' || cardType === 'Item' || cardType === 'Tool' || cardType === 'Stadium' || cardType === 'Trainer') {
                    trainerText += line;
                }
                // Energy cards: Energy, Special Energy
                else if (cardType === 'Energy' || cardType === 'Special Energy' || card.name.includes('Energy') || card.name.includes('energie')) {
                    energyText += line;
                }
                // Everything else is Pokemon
                else {
                    exportText += line;
                }
            });
            
            const fullExport = exportText + '\n' + trainerText + '\n' + energyText;
            
            navigator.clipboard.writeText(fullExport).then(() => {
                alert('‚úÖ Deckliste wurde in die Zwischenablage kopiert!\n\nF√ºge sie jetzt in Pokemon Live ein.');
            }).catch(err => {
                prompt('Kopiere diese Deckliste:', fullExport);
            });
        }
        
        function getCardType(cardName) {
            /**
             * Determines card type based on all_cards_database.csv
             * Falls back to keyword matching if not found in database
             * WICHTIG: Basic Energy Namen m√ºssen ZUERST gepr√ºft werden!
             */
            const name = cardName.toLowerCase();
            
            const basicEnergyNames = [
                'grass energy',
                'fire energy',
                'water energy',
                'lightning energy',
                'psychic energy',
                'fighting energy',
                'darkness energy',
                'metal energy',
                'fairy energy',
                'dragon energy'
            ];
            const specialEnergyNames = [
                'telepath'
            ];
            
            // FIRST: Check for basic energies (BEFORE database lookup!)
            if (basicEnergyNames.includes(name)) {
                return 'Energy';
            }
            
            // Special energies
            if (specialEnergyNames.includes(name)) {
                return 'Special Energy';
            }
            
            // Now try to get from database
            if (cardTypeDatabase.has(cardName)) {
                const dbType = cardTypeDatabase.get(cardName);
                
                // Map database types to our categories
                if (dbType === 'Supporter') return 'Supporter';
                if (dbType === 'Stadium') return 'Stadium';
                if (dbType === 'Item') return 'Item';
                if (dbType === 'Tool') return 'Tool';
                
                // Pokemon types (e.g., "GBasic", "WStage 1", "PBasic", etc.)
                if (dbType && (dbType.includes('Basic') || dbType.includes('Stage') || dbType.includes('V') || dbType.includes('VMAX'))) {
                    return 'Pokemon';
                }
                
                // Energy types from database
                if (dbType && dbType.includes('Energy')) {
                    if (dbType.includes('Special')) return 'Special Energy';
                    return 'Energy';
                }
            }
            
            // Fallback: keyword matching for remaining energy cards
            if (name.endsWith('energy') && !name.includes('special')) {
                return 'Energy';
            }
            
            // Energy cards
            if (name.includes('energy') || name.includes('energie')) {
                if (name.includes('special energy') || name.includes('blend') || name.includes('aurora') || 
                    name.includes('prism') || name.includes('rainbow') || name.includes('crystal') ||
                    name.includes('double colorless') || name.includes('triple') || name.includes('twin') ||
                    name.includes('fusion')) {
                    return 'Special Energy';
                }
                return 'Energy';
            }
            
            // Default: Pokemon
            return 'Pokemon';
        }
        
        function sortCardsByType(cards) {
            /**
             * Sort cards by:
             * 1. Pokemon by Element (G, R, W, L, P, F, D, M, N, C)
             * 2. Within each element by Evolution (Basic, Stage1, Stage2)
             * 3. Then Trainer cards (Supporter, Item, Tool, Stadium)
             * 4. Then Energy cards (Special Energy, Basic Energy)
             */
            const elementOrder = {
                'G': 1,  // Grass
                'R': 2,  // Fire
                'W': 3,  // Water
                'L': 4,  // Lightning
                'P': 5,  // Psychic
                'F': 6,  // Fighting
                'D': 7,  // Darkness
                'M': 8,  // Metal
                'N': 9,  // Dragon
                'C': 10  // Colorless
            };
            
            const evolutionOrder = {
                'Basic': 1,
                'Stage1': 2,
                'Stage2': 3
            };
            
            const typeOrder = {
                'Pokemon': 1,
                'Supporter': 2,
                'Item': 3,
                'Tool': 4,
                'Stadium': 5,
                'Special Energy': 6,
                'Energy': 7,
                'Trainer': 3  // Fallback for generic "Trainer" types
            };
            
            // Helper function to determine card category
            function getCategory(card) {
                const cardType = card.type || '';
                const cardName = card.card_name || card.name || '';
                
                // Check if it's a Pokemon (type starts with element letter)
                if (cardType && cardType.charAt(0).match(/[GRWLPFDMNC]/)) {
                    return 'Pokemon';
                }
                
                // Check exact matches for trainer types
                if (cardType === 'Supporter') return 'Supporter';
                if (cardType === 'Item') return 'Item';
                if (cardType === 'Tool') return 'Tool';
                if (cardType === 'Stadium') return 'Stadium';
                if (cardType === 'Trainer') return 'Item';  // Generic trainer = Item
                
                // Check for energy
                if (cardType === 'Energy' || cardType === 'Special Energy') {
                    return cardType;
                }
                if (cardName.toLowerCase().includes('energy')) {
                    if (cardName.toLowerCase().includes('special') || 
                        cardName.toLowerCase().match(/(blend|aurora|prism|rainbow|crystal|double colorless|triple|twin|fusion|jet|enriching)/)) {
                        return 'Special Energy';
                    }
                    return 'Energy';
                }
                
                // Fallback: Use getCardType if available
                return getCardType(cardName);
            }
            
            return cards.sort((a, b) => {
                const categoryA = getCategory(a);
                const categoryB = getCategory(b);
                
                // Get type order for both cards
                const orderA = typeOrder[categoryA] || 99;
                const orderB = typeOrder[categoryB] || 99;
                
                // FIRST: Sort by main category (Pokemon vs Supporter vs Item vs Tool vs Stadium vs Energy)
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // SECOND: Both are Pokemon - sort by element and evolution
                if (categoryA === 'Pokemon' && categoryB === 'Pokemon') {
                    // Get element and evolution from 'type' field (e.g., "GBasic", "RStage 1", "WStage 2")
                    const cardTypeA = a.type || '';
                    const cardTypeB = b.type || '';
                    
                    const elementA = cardTypeA.charAt(0);
                    const elementB = cardTypeB.charAt(0);
                    // Remove spaces from evolution stages (e.g., "Stage 1" -> "Stage1")
                    const evolutionA = cardTypeA.substring(1).replace(/\s+/g, '');
                    const evolutionB = cardTypeB.substring(1).replace(/\s+/g, '');
                    
                    const elemOrderA = elementOrder[elementA] || 99;
                    const elemOrderB = elementOrder[elementB] || 99;
                    
                    // Sort by element
                    if (elemOrderA !== elemOrderB) {
                        return elemOrderA - elemOrderB;
                    }
                    
                    // Within same element, sort by evolution
                    const evolOrderA = evolutionOrder[evolutionA] || 99;
                    const evolOrderB = evolutionOrder[evolutionB] || 99;
                    
                    if (evolOrderA !== evolOrderB) {
                        return evolOrderA - evolOrderB;
                    }
                    
                    // Within same evolution, sort by percentage (highest first)
                    if (a.percentage_in_archetype && b.percentage_in_archetype) {
                        const percA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                        const percB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                        if (percA !== percB) {
                            return percB - percA;
                        }
                    }
                    
                    // Finally sort by name
                    const nameA = a.card_name || a.name || '';
                    const nameB = b.card_name || b.name || '';
                    return nameA.localeCompare(nameB);
                }
                
                // THIRD: Same non-Pokemon type - sort by percentage within category
                if (a.percentage_in_archetype && b.percentage_in_archetype) {
                    const percA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                    const percB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                    if (percA !== percB) {
                        return percB - percA;
                    }
                }
                
                // Finally sort by name
                const nameA = a.card_name || a.name || '';
                const nameB = b.card_name || b.name || '';
                return nameA.localeCompare(nameB);
            });
        }
        
        function isTrainerCard(cardName) {
            const cardType = getCardType(cardName);
            return cardType !== 'Pokemon' && cardType !== 'Energy';
        }
        
        function showError(message) {
            const cardsBody = document.getElementById('cardsBody');
            cardsBody.innerHTML = `<tr><td colspan="6"><div class="error">${message}</div></td></tr>`;
        }
        
        function generateDeckImage() {
            if (myDeck.length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            const modal = document.getElementById('imageViewModal');
            const grid = document.getElementById('compactCardGrid');
            
            grid.innerHTML = myDeck.map(card => {
                const imageUrl = card.imageUrl || '';
                const count = card.count;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" data-image-url="${imageUrl}" data-card-name="${card.name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <div class="compact-badge" style="position: static; margin-top: 10px;">${count}</div>
                        </div>
                    `;
                }
            }).join('');
            
            modal.classList.add('show');
        }
        
        function generateFilteredCardsImage() {
            if (filteredCards.length === 0) {
                alert('Keine Karten zum Anzeigen! Bitte Filter anwenden.');
                return;
            }
            
            // Show images in the Karten-Filter tab itself with LARGE card visual
            const grid = document.getElementById('filteredGrid');
            
            grid.innerHTML = filteredCards.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;" onclick="showCardImage('${imageUrl.replace(/'/g, "\\'")}', '${card.card_name.replace(/'/g, "\\'")}')">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.card_name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <div style="flex-direction: column;">
                                <div style="color: white; text-align: center; padding: 10px; font-size: 0.85em;">${card.card_name}</div>
                                <div class="card-count-badge" style="position: static; margin-top: 10px;">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            // Make sure the visual section is visible
            const visualDiv = document.getElementById('filteredCardsVisual');
            if (visualDiv) {
                visualDiv.classList.add('show');
            }
            
            // Scroll to the visual section
            document.getElementById('filteredCardsVisual').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        function generateDeckCardsImage() {
            // Generate image view for current deck's card list
            if (!currentDeckCards || currentDeckCards.length === 0) {
                alert('Bitte w√§hle zuerst ein Deck aus!');
                return;
            }
            
            const modal = document.getElementById('imageViewModal');
            const grid = document.getElementById('compactCardGrid');
            
            grid.innerHTML = currentDeckCards.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" data-image-url="${imageUrl}" data-card-name="${card.card_name}" style="cursor: pointer;">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.style.display='none'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <div class="compact-badge" style="position: static; margin-top: 10px;">${count}</div>
                        </div>
                    `;
                }
            }).join('');
            
            modal.classList.add('show');
        }
        
        function copyAllCardsData() {
            // Copy all cards with set and number to clipboard
            if (!currentDeckCards || currentDeckCards.length === 0) {
                alert('Bitte w√§hle zuerst ein Deck aus!');
                return;
            }
            
            // Format: "Anzahl Kartenname (Set Nummer)"
            const cardsList = currentDeckCards.map(card => {
                const count = card.max_count || 1;
                const cardName = card.card_name || '';
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                // Format: "1x Pikachu (SVP 001)"
                if (setCode && setNumber) {
                    return `${count}x ${cardName} (${setCode} ${setNumber})`;
                } else if (setNumber) {
                    return `${count}x ${cardName} (${setNumber})`;
                } else {
                    return `${count}x ${cardName}`;
                }
            }).join('\n');
            
            // Copy to clipboard
            navigator.clipboard.writeText(cardsList).then(() => {
                alert(`‚úÖ ${currentDeckCards.length} Karten kopiert!`);
            }).catch(err => {
                console.error('Error copying to clipboard:', err);
                // Fallback: Use textarea approach
                const textarea = document.createElement('textarea');
                textarea.value = cardsList;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                alert(`‚úÖ ${currentDeckCards.length} Karten kopiert!`);
            });
        }
        
        function closeImageView() {
            const modal = document.getElementById('imageViewModal');
            modal.classList.remove('show');
        }
    </script>
    
    <!-- Image View Modal -->
    <div id="imageViewModal" class="image-view-modal" onclick="if(event.target === this) closeImageView()">
        <div class="image-view-content">
            <div class="image-view-header">
                <h3>üé® Alle Karten √úbersicht</h3>
                <button class="image-view-close" onclick="closeImageView()">‚úï</button>
            </div>
            <div id="compactCardGrid" class="compact-card-grid"></div>
        </div>
    </div>
    <!-- Version: 2026-02-05 09:25 -->
        </div>
        </div>
        
        <!-- Tab 2: Karten-Filter -->
        <div id="karten-filter" class="tab-content">
            <div class="container">
                <div class="header">
                    <h1>üß∞ Karten-Filter</h1>
                    <p>Filtere alle gescrapten Karten nach Set und Kartentyp. Perfekt, um z. B. alle ben√∂tigten Karten aus einem Set zu sehen.</p>
                </div>
                
                <div class="card-filter-section" id="cardFilterSection">
                    <div class="filter-row">
                        <div class="control-group">
                            <label for="setFilterSelect">üì¶ Set</label>
                            <select id="setFilterSelect">
                                <option value="">Alle Sets</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="cardSearchInput">üîç Kartensuche</label>
                            <input type="text" id="cardSearchInput" placeholder="Kartenname eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                        </div>
                        <div class="control-group">
                            <label for="cardTypeFiltersContainer">üß© Kartentyp (Mehrfachauswahl)</label>
                            <div id="cardTypeFiltersContainer" style="position: relative;"></div>
                        </div>
                    </div>

                    <div class="filter-actions">
                        <button class="btn btn-primary" onclick="applyCardFilters()">üîé Anzeigen</button>
                        <button class="btn btn-secondary" onclick="clearCardFilters()">üßπ Filter zur√ºcksetzen</button>
                        <button class="btn btn-success" onclick="copyFilteredCards()">üìã Gefilterte Karten kopieren</button>
                        <button class="btn btn-warning" onclick="generateFilteredCardsImage()">üñºÔ∏è Ansicht generieren</button>
                    </div>

                    <div class="filter-summary">
                        <span id="filteredCardCount">0 Karten</span>
                    </div>

                    <div class="filtered-cards-visual" id="filteredCardsVisual">
                        <h3>üÉè Karten-√úbersicht</h3>
                        <div class="filtered-grid" id="filteredGrid"></div>
                    </div>

                    <div class="cards-table">
                        <table>
                            <thead>
                                <tr>
                                    <th class="col-image">Bild</th>
                                    <th>Kartenname</th>
                                    <th>Set</th>
                                    <th>Nummer</th>
                                    <th>Typ</th>
                                    <th>Max Anzahl</th>
                                </tr>
                            </thead>
                            <tbody id="filteredCardsBody">
                                <tr>
                                    <td colspan="6" class="loading">Bitte Filter ausw√§hlen...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab 3: City League Development -->
        <div id="city-league" class="tab-content">
            <div class="container">
                <div class="header">
                    <h1>üáØüáµ City League Development</h1>
                </div>
                <div id="cityLeagueContent" style="padding: 30px; background: #ffffff;">
                    <div style="text-align: center; padding: 40px; color: #999;">L√§dt...</div>
                </div>
            </div>
        </div>
        
        <!-- Tab 4: Limitless Online Comparison -->
        <div id="limitless-online" class="tab-content">
            <div class="container">
                <div class="header">
                    <h1>üéÆ Limitless Online Comparison</h1>
                </div>
                <div id="limitlessContent" style="padding: 30px; background: #ffffff;">
                    <div style="text-align: center; padding: 40px; color: #999;">L√§dt...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Tab switching functionality
        function switchTab(tabName) {
            // Hide all tabs
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Deactivate all buttons
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Show selected tab
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
                
                // Load Limitless comparison if needed
                if (tabName === 'limitless-online') {
                    loadLimitlessComparison();
                }
            }
            
            // Activate selected button
            event.target.classList.add('active');
        }
        
        function loadLimitlessComparison() {
            const limitlessContent = document.getElementById('limitlessContent');
            
            fetch(BASE_PATH + 'data/limitless_online_decks_comparison.html')
                .then(response => response.text())
                .then(html => {
                    // Parse the loaded HTML
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(html, 'text/html');
                    
                    // Extract the container content
                    const container = doc.querySelector('.container');
                    if (container) {
                        // Get everything after the h1 title
                        const contentDivs = Array.from(container.children).slice(1);
                        
                        // Create a wrapper with the limitless-comparison class for styling
                        const wrapper = document.createElement('div');
                        wrapper.className = 'limitless-comparison';
                        
                        // Add content to wrapper
                        contentDivs.forEach(el => {
                            const clone = el.cloneNode(true);
                            wrapper.appendChild(clone);
                        });
                        
                        // Clear and set content
                        limitlessContent.innerHTML = '';
                        limitlessContent.appendChild(wrapper);
                    } else {
                        limitlessContent.innerHTML = '<div style="color: #e74c3c; padding: 20px;">Fehler beim Laden der Vergleichsdaten</div>';
                    }
                })
                .catch(err => {
                    console.error('Error loading comparison:', err);
                    limitlessContent.innerHTML = `
                        <div style="color: #e74c3c; padding: 20px;">
                            <strong>Fehler:</strong> Die Vergleichs-HTML konnte nicht geladen werden.
                            <br><small>${err.message}</small>
                        </div>
                    `;
                });
        }
    </script>
</body>
</html>
