<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokemon Deck Viewer & Builder</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 3px solid #667eea;
        }
        
        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .control-group {
            flex: 1;
            min-width: 200px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        .control-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .variant-selector {
            background: #e8f4f8;
            border: 2px solid #667eea;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .variant-selector h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .variant-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            cursor: pointer;
        }

        .variant-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            font-weight: bold;
            transition: transform 0.2s, background 0.2s, color 0.2s;
        }

        .variant-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .variant-toggle:hover {
            background: #667eea;
            color: white;
        }
        
        .variant-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .variant-checkbox {
            display: flex;
            align-items: center;
            background: white;
            padding: 10px 15px;
            border-radius: 6px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .variant-checkbox:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }
        
        .variant-checkbox input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 18px;
            height: 18px;
        }
        
        .variant-checkbox.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }
        
        .deck-select-wrapper {
            position: relative;
        }
        
        .deck-select-wrapper input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
        }
        
        .deck-select-wrapper input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .stats-section {
            padding: 30px;
            background: white;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .stat-card .label {
            font-size: 0.9em;
            opacity: 0.9;
            margin-bottom: 5px;
        }
        
        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }
        
        .matchups {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .matchup-box {
            padding: 20px;
            border-radius: 10px;
            background: #f8f9fa;
        }
        
        .matchup-box h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .matchup-box.good {
            border-left: 5px solid #28a745;
        }
        
        .matchup-box.bad {
            border-left: 5px solid #dc3545;
        }
        
        .matchup-item {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .cards-section {
            padding: 30px;
            background: #f8f9fa;
        }
        
        .cards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .deck-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .deck-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            max-height: 800px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .card-visual {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            background: #f0f0f0;
        }
        
        .card-visual:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        
        .card-visual img {
            width: 90px;
            height: 126px;
            display: block;
            object-fit: cover;
        }
        
        .card-visual .card-count-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2em;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .card-visual .card-name-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            color: white;
            padding: 10px;
            font-size: 0.85em;
            font-weight: 600;
        }
        
        .card-visual.no-image {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 210px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            text-align: center;
        }
        
        .card-visual.no-image .fallback-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        
        .card-visual.no-image .fallback-icon {
            font-size: 3em;
        }
        
        .cards-table {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }
        
        th.col-image {
            width: 100px;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .card-thumbnail {
            width: 80px;
            height: auto;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .card-thumbnail:hover {
            transform: scale(1.1);
        }
        
        .card-thumbnail-placeholder {
            width: 80px;
            height: 110px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 2em;
        }
        
        tbody tr:hover {
            background: #f8f9fa;
        }
        
        .card-count {
            font-weight: bold;
            color: #667eea;
            font-size: 1.1em;
        }
        
        .deck-builder {
            padding: 30px;
            background: white;
            border-top: 3px solid #667eea;
        }
        
        .deck-builder h2 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .builder-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-success {
            background: #28a745;
            color: white;
        }
        
        .deck-list {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
        }

        .card-filter-section {
            padding: 30px;
            background: #ffffff;
            border-top: 3px solid #667eea;
        }

        .card-filter-section h2 {
            margin-bottom: 10px;
            color: #333;
        }

        .card-filter-section p {
            color: #666;
            margin-bottom: 20px;
        }

        .filtered-cards-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: none;
        }

        .filtered-cards-visual.show {
            display: block;
        }

        .filtered-cards-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }

        .filtered-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            max-height: 800px;
            overflow-y: auto;
            padding: 10px;
        }

        .filter-row {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .filter-type-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .filter-type-checkbox {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-type-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .filter-type-checkbox.selected {
            border-color: #667eea;
            background: #eef2ff;
        }

        .filter-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .filter-summary {
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }
        
        .deck-card {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }
        
        .deck-card-controls {
            display: flex;
            gap: 5px;
        }
        
        .deck-card-controls button {
            padding: 5px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .btn-add {
            background: #28a745;
            color: white;
        }
        
        .btn-remove {
            background: #dc3545;
            color: white;
        }
        
        .deck-summary {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            text-align: center;
        }
        
        .deck-summary h3 {
            font-size: 1.5em;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }
        
        .error {
            background: #dc3545;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .percentage-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .percentage-high {
            background: #28a745;
            color: white;
        }
        
        .percentage-medium {
            background: #ffc107;
            color: #333;
        }
        
        .percentage-low {
            background: #6c757d;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¥ Pokemon Deck Viewer & Builder</h1>
            <p>Analysiere Decks, filtere Karten und baue deine perfekte Liste</p>
        </div>
        
        <div class="controls">
            <div class="control-row">
                <div class="control-group">
                    <label for="deckSearch">üîç Deck suchen:</label>
                    <input type="text" id="deckSearch" placeholder="Deck-Name eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                </div>
                <div class="control-group">
                    <label for="deckSelect">üéØ Deck Archetype w√§hlen:</label>
                    <select id="deckSelect" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                        <option value="">-- Bitte Deck ausw√§hlen --</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="filterSelect">üîç Karten Filter:</label>
                    <select id="filterSelect">
                        <option value="all">Alle Karten</option>
                        <option value="70">Karten in >70% der Decks</option>
                        <option value="50">Karten in >50% der Decks</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="stats-section" id="statsSection" style="display: none;">
            <div class="variant-selector" id="variantSelector" style="display: none;">
                <div class="variant-header" onclick="toggleVariantSelector()">
                    <h3>üîÑ Weitere Deck-Varianten dazupacken:</h3>
                    <span class="variant-toggle" id="variantToggle">‚ñº</span>
                </div>
                <p style="font-size: 0.9em; color: #666; margin-bottom: 10px;">
                    W√§hle zus√§tzliche Varianten aus, um mehr Karten-Optionen f√ºr dein Custom-Deck zu sehen
                </p>
                <div class="variant-options" id="variantOptions"></div>
            </div>
            
            <h2>üìä Deck Statistiken</h2>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="label">Ranking</div>
                    <div class="value" id="statRanking">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Win Rate</div>
                    <div class="value" id="statWinRate">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Matches Gespielt</div>
                    <div class="value" id="statMatches">-</div>
                </div>
                <div class="stat-card">
                    <div class="label">Matchup vs Top 20</div>
                    <div class="value" id="statBalance">-</div>
                </div>
            </div>
            
            <div class="matchups">
                <div class="matchup-box good">
                    <h3>‚úÖ Top Matchups (>50%)</h3>
                    <div id="topMatchups"></div>
                </div>
                <div class="matchup-box bad">
                    <h3>‚ùå Worst Matchups (<50%)</h3>
                    <div id="worstMatchups"></div>
                </div>
            </div>
        </div>
        
        <div class="cards-section">
            <div class="cards-header">
                <h2>üÉè Karten Liste</h2>
                <span id="cardCount">0 Karten</span>
            </div>
            
            <!-- Deck Visualisierung -->
            <div class="deck-visual" id="deckVisual" style="display: none;">
                <h3>üé® Deck √úbersicht</h3>
                <div class="deck-grid" id="deckGrid">
                    <!-- Karten werden hier dynamisch eingef√ºgt -->
                </div>
            </div>
            
            <div class="cards-table">
                <table>
                    <thead>
                        <tr>
                            <th class="col-image">Bild</th>
                            <th>Anzahl</th>
                            <th>Kartenname</th>
                            <th>Set</th>
                            <th>Nummer</th>
                            <th>% in Archetype</th>
                            <th>Aktion</th>
                        </tr>
                    </thead>
                    <tbody id="cardsBody">
                        <tr>
                            <td colspan="7" class="loading">Bitte w√§hle ein Deck aus...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        
        <div class="deck-builder">
            <h2>üõ†Ô∏è Deck Builder (60 Karten)</h2>
            <div class="builder-controls">
                <button class="btn btn-primary" onclick="exportToPokemonLive()">üìã F√ºr Pokemon Live kopieren</button>
                <button class="btn btn-secondary" onclick="clearDeck()">üóëÔ∏è Deck leeren</button>
                <button class="btn btn-success" onclick="autoComplete()">‚ö° Auto-Complete (60 Karten)</button>
            </div>
            
            <div class="deck-summary">
                <h3>Aktuell: <span id="deckCardCount">0</span> / 60 Karten</h3>
            </div>
            
            <div id="myDeckVisual" style="display: none;">
                <h3>üé¥ Dein Deck √úbersicht</h3>
                <div class="deck-grid" id="myDeckGrid"></div>
            </div>
            
            <div class="deck-list" id="deckList">
                <p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>
            </div>
        </div>

        <div class="card-filter-section" id="cardFilterSection">
            <h2>üß∞ Karten-Filter</h2>
            <p>Filtere alle gescrapten Karten nach Set und Kartentyp. Perfekt, um z. B. alle ben√∂tigten Karten aus einem Set zu sehen.</p>

            <div class="filter-row">
                <div class="control-group">
                    <label for="setFilterSelect">üì¶ Set</label>
                    <select id="setFilterSelect">
                        <option value="">Alle Sets</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="cardSearchInput">üîç Kartensuche</label>
                    <input type="text" id="cardSearchInput" placeholder="Kartenname eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                </div>
                <div class="control-group">
                    <label>üß© Kartentyp (Mehrfachauswahl)</label>
                    <div class="filter-type-options" id="cardTypeFilters"></div>
                </div>
            </div>

            <div class="filter-actions">
                <button class="btn btn-primary" onclick="applyCardFilters()">üîé Anzeigen</button>
                <button class="btn btn-secondary" onclick="clearCardFilters()">üßπ Filter zur√ºcksetzen</button>
                <button class="btn btn-success" onclick="copyFilteredCards()">üìã Gefilterte Karten kopieren</button>
            </div>

            <div class="filter-summary">
                <span id="filteredCardCount">0 Karten</span>
            </div>

            <div class="filtered-cards-visual" id="filteredCardsVisual">
                <h3>üÉè Karten-√úbersicht</h3>
                <div class="filtered-grid" id="filteredGrid"></div>
            </div>

            <div class="cards-table">
                <table>
                    <thead>
                        <tr>
                            <th class="col-image">Bild</th>
                            <th>Kartenname</th>
                            <th>Set</th>
                            <th>Nummer</th>
                            <th>Typ</th>
                            <th>Max Anzahl</th>
                        </tr>
                    </thead>
                    <tbody id="filteredCardsBody">
                        <tr>
                            <td colspan="6" class="loading">Bitte Filter ausw√§hlen...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <script>
        // Global data storage
        let cardsData = [];
        let matchupsData = [];
        let matchupDetailsData = [];
        let cityLeagueData = [];
        let myDeck = [];
        let cardTypeDatabase = new Map(); // Map of card name -> type
        let filteredCards = [];
        
        // Load data on page load
        document.addEventListener('DOMContentLoaded', async () => {
            await loadCardDatabase();  // Load card types first
            await loadCardsData();
            await loadMatchupsData();
            await loadMatchupDetailsData();
            await loadCityLeagueData();
            initializeCardFilterUI();
            setupEventListeners();
        });
        
        async function loadCardDatabase() {
            try {
                const response = await fetch('all_cards_database.csv');
                const text = await response.text();
                // Remove BOM if present
                let cleanText = text;
                if (cleanText.charCodeAt(0) === 0xFEFF) {
                    cleanText = cleanText.slice(1);
                }
                const lines = cleanText.split('\n');
                // Skip header: set;number;name;type;rarity
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    const parts = lines[i].split(';');
                    if (parts.length >= 4) {
                        const name = parts[2].trim();
                        const type = parts[3].trim();
                        if (name && type) {
                            cardTypeDatabase.set(name, type);
                        }
                    }
                }
                console.log('‚úì Card database loaded:', cardTypeDatabase.size, 'cards');
            } catch (error) {
                console.warn('Could not load card database:', error);
            }
        }
        
        async function loadCardsData() {
            try {
                const candidates = [
                    'unified_card_data.csv'
                ];
                let loaded = false;

                for (const fileName of candidates) {
                    try {
                        console.log('Attempting to load:', fileName);
                        const response = await fetch(fileName, {cache: 'no-store'});
                        console.log('Response status:', response.status, response.ok);
                        if (response.ok) {
                            const text = await response.text();
                            console.log('Loaded CSV, size:', text.length);
                            cardsData = parseCSV(text);
                            console.log('Parsed CSV, rows:', cardsData.size);
                            populateDeckDropdown();
                            loaded = true;
                            break;
                        }
                    } catch (err) {
                        console.error('Error loading', fileName, ':', err);
                    }
                }

                if (!loaded) {
                    throw new Error('Keine CSV-Datei gefunden');
                }
            } catch (error) {
                console.error('Error loading cards data:', error);
                showError('Fehler beim Laden der Kartendaten. Stelle sicher, dass unified_card_data.csv vorhanden ist.');
            }
        }
        
        async function loadMatchupsData() {
            try {
                const response = await fetch('limitless_online_decks.csv');
                if (response.ok) {
                    const text = await response.text();
                    matchupsData = parseCSV(text);
                    console.log('Loaded Limitless Online decks - Entries:', matchupsData.length);
                } else {
                    console.warn('Limitless Online deck data not found');
                }
            } catch (error) {
                console.error('Error loading Limitless deck data:', error);
            }
        }
        
        async function loadMatchupDetailsData() {
            try {
                const response = await fetch('limitless_online_decks_matchups.csv');
                if (response.ok) {
                    const text = await response.text();
                    matchupDetailsData = parseCSV(text);
                    console.log('Loaded Limitless matchup details - Entries:', matchupDetailsData.length);
                } else {
                    console.warn('Limitless matchup details not found');
                }
            } catch (error) {
                console.error('Error loading matchup details:', error);
            }
        }
        
        async function loadCityLeagueData() {
            try {
                const response = await fetch('city_league_archetypes_comparison.csv');
                if (response.ok) {
                    const text = await response.text();
                    cityLeagueData = parseCSV(text);
                    console.log('Loaded City League comparison - Entries:', cityLeagueData.length);
                } else {
                    console.warn('City League comparison data not found');
                }
            } catch (error) {
                console.error('Error loading City League data:', error);
                // Not critical if this fails
            }
        }
        
        function loadCardImageWithProxy(imgElement, originalUrl, cardName, count) {
            // Try adding _R_ to the URL if not present
            let urlWithR = originalUrl;
            if (originalUrl && !originalUrl.includes('_R_')) {
                // Insert _R_ before the extension
                urlWithR = originalUrl.replace(/\.([^.]+)$/, '_R_.$1');
            }
            
            // If direct load fails, try alternative image services
            const proxies = [
                // Try with _R_ suffix
                urlWithR,
                // Try weserv.nl proxy
                `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`,
                // Try another proxy service  
                `https://via.placeholder.com/200x280?text=${encodeURIComponent(cardName)}`
            ];
            
            let proxyIndex = 0;
            
            function tryNextProxy() {
                if (proxyIndex >= proxies.length) {
                    // All proxies failed, show fallback
                    imgElement.parentElement.classList.add('no-image');
                    imgElement.parentElement.innerHTML = `
                        <div class='fallback-content'>
                            <div class='fallback-icon'>üÉè</div>
                            <div>${cardName}</div>
                            <div class='card-count-badge'>${count}</div>
                        </div>
                    `;
                    return;
                }
                
                const currentUrl = proxies[proxyIndex];
                proxyIndex++;
                
                imgElement.src = currentUrl;
                imgElement.onerror = () => {
                    tryNextProxy();
                };
            }
            
            tryNextProxy();
        }
        
        function parseCSV(text) {
            const lines = text.split('\n');
            if (lines.length === 0) return [];
            
            // Handle BOM if present
            if (lines[0].charCodeAt(0) === 0xFEFF) {
                lines[0] = lines[0].substr(1);
            }
            
            const headerLine = lines[0].replace(/^\uFEFF/, ''); // Remove BOM from first line
            const headers = headerLine.split(';').map(h => {
                // Remove BOM from individual headers and trim
                return h.trim().replace(/^\uFEFF/, '').replace(/\r$/, '');
            });
            const data = [];
            
            console.log('CSV Headers:', headers); // Debug
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                
                const values = lines[i].split(';');
                const row = {};
                headers.forEach((header, index) => {
                    let value = values[index] ? values[index].trim().replace(/\r$/, '') : '';
                    // Ensure header name is clean
                    const cleanHeader = header.replace(/^\uFEFF/, '');
                    row[cleanHeader] = value;
                });
                data.push(row);
            }
            
            console.log('Parsed', data.length, 'rows'); // Debug
            return data;
        }
        
        function populateDeckDropdown() {
            const deckSelect = document.getElementById('deckSelect');
            const archetypes = [...new Set(cardsData.map(c => c.archetype))].sort((a, b) => a.localeCompare(b));
            
            archetypes.forEach(archetype => {
                const option = document.createElement('option');
                option.value = archetype;
                option.textContent = archetype;
                deckSelect.appendChild(option);
            });
        }
        
        function setupEventListeners() {
            document.getElementById('deckSelect').addEventListener('change', onDeckChange);
            document.getElementById('filterSelect').addEventListener('change', updateCardsDisplay);
            document.getElementById('deckSearch').addEventListener('input', filterDeckList);
            const setFilter = document.getElementById('setFilterSelect');
            if (setFilter) {
                setFilter.addEventListener('change', applyCardFilters);
            }
            const cardSearch = document.getElementById('cardSearchInput');
            if (cardSearch) {
                // Apply filter on Enter key
                cardSearch.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        applyCardFilters();
                    }
                });
                // Optional: Live search while typing (with debounce)
                let searchTimeout;
                cardSearch.addEventListener('input', () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        applyCardFilters();
                    }, 500); // Wait 500ms after user stops typing
                });
            }
        }

        function initializeCardFilterUI() {
            populateSetFilterOptions();
            renderCardTypeFilters();
            applyCardFilters();
        }

        function populateSetFilterOptions() {
            const setSelect = document.getElementById('setFilterSelect');
            if (!setSelect) return;

            const sets = [...new Set(cardsData.map(c => (c.set_code || '').trim()).filter(Boolean))]
                .sort((a, b) => a.localeCompare(b));

            sets.forEach(setCode => {
                const option = document.createElement('option');
                option.value = setCode;
                option.textContent = setCode;
                setSelect.appendChild(option);
            });
        }

        function renderCardTypeFilters() {
            const container = document.getElementById('cardTypeFilters');
            if (!container) return;

            const cardTypes = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
            container.innerHTML = '';

            cardTypes.forEach(type => {
                const label = document.createElement('label');
                label.className = 'filter-type-checkbox selected';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = type;
                checkbox.checked = true;
                checkbox.addEventListener('change', () => {
                    label.classList.toggle('selected', checkbox.checked);
                    applyCardFilters();
                });

                const span = document.createElement('span');
                span.textContent = type;

                label.appendChild(checkbox);
                label.appendChild(span);
                container.appendChild(label);
            });
        }

        function getSelectedCardTypes() {
            const container = document.getElementById('cardTypeFilters');
            if (!container) return new Set();

            const selected = new Set();
            const checkboxes = container.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach(cb => {
                if (cb.checked) selected.add(cb.value);
            });
            return selected;
        }

        function applyCardFilters() {
            const setFilter = document.getElementById('setFilterSelect');
            const selectedSet = setFilter ? setFilter.value : '';
            const searchInput = document.getElementById('cardSearchInput');
            const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';
            const selectedTypes = getSelectedCardTypes();

            const cardMap = new Map();

            cardsData.forEach(card => {
                const setCode = (card.set_code || '').trim();
                const cardNumber = (card.set_number || '').trim();
                const cardName = (card.card_name || '').trim();
                if (!cardName) return;

                if (selectedSet && setCode !== selectedSet) return;
                
                // Filter by search term
                if (searchTerm && !cardName.toLowerCase().includes(searchTerm)) return;

                const cardType = getCardType(cardName);
                if (selectedTypes.size > 0 && !selectedTypes.has(cardType)) return;

                const key = `${cardName}|${setCode}|${cardNumber}`;
                const totalCount = parseInt(card.total_count || '0', 10) || 0;
                const maxCount = parseInt(card.max_count || '0', 10) || 0;

                if (!cardMap.has(key)) {
                    cardMap.set(key, {
                        card_name: cardName,
                        set_code: setCode,
                        set_number: cardNumber,
                        card_type: cardType,
                        total_count: totalCount,
                        max_count: maxCount,
                        image_url: card.image_url || ''
                    });
                } else {
                    const existing = cardMap.get(key);
                    existing.total_count += totalCount;
                    existing.max_count = Math.max(existing.max_count, maxCount);
                }
            });

            filteredCards = Array.from(cardMap.values());
            // Sort by card type first
            filteredCards = sortCardsByType(filteredCards);
            
            // Show grid only if single set selected and all types are selected (no specific type filter) and no search term
            const allCardTypes = ['Pokemon', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
            const allTypesSelected = allCardTypes.every(type => selectedTypes.has(type));
            const showGrid = selectedSet && allTypesSelected && !searchTerm;
            updateFilteredCardsVisual(showGrid);
            
            renderFilteredCards();
        }

        function updateFilteredCardsVisual(show) {
            const visualDiv = document.getElementById('filteredCardsVisual');
            const grid = document.getElementById('filteredGrid');

            if (!show || filteredCards.length === 0) {
                visualDiv.classList.remove('show');
                return;
            }

            visualDiv.classList.add('show');

            // Sort cards by type, then set number, then relevance
            const sortedForGrid = [...filteredCards].sort((a, b) => {
                // First sort by card type
                const typeOrder = ['Pokemon', 'Trainer', 'Supporter', 'Item', 'Tool', 'Stadium', 'Special Energy', 'Energy'];
                const typeA = typeOrder.indexOf(a.card_type || 'Unknown');
                const typeB = typeOrder.indexOf(b.card_type || 'Unknown');
                if (typeA !== typeB) return (typeA === -1 ? 999 : typeA) - (typeB === -1 ? 999 : typeB);
                
                // Then by set number
                const numA = parseInt(a.set_number || '0', 10);
                const numB = parseInt(b.set_number || '0', 10);
                if (numA !== numB) return numA - numB;
                
                // Finally by relevance (max_count descending)
                const countA = parseInt(a.max_count || '0', 10);
                const countB = parseInt(b.max_count || '0', 10);
                return countB - countA;
            });

            grid.innerHTML = sortedForGrid.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" onclick="showCardImage('${imageUrl}', '${card.card_name}')">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="loadCardImageWithProxy(this, '${imageUrl}', '${card.card_name}', ${count})">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.card_name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">üÉè</div>
                                <div>${card.card_name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }

        function clearCardFilters() {
            const setSelect = document.getElementById('setFilterSelect');
            if (setSelect) setSelect.value = '';
            
            const searchInput = document.getElementById('cardSearchInput');
            if (searchInput) searchInput.value = '';

            const container = document.getElementById('cardTypeFilters');
            if (container) {
                const checkboxes = container.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    cb.checked = true;
                    cb.parentElement.classList.add('selected');
                });
            }

            const visualDiv = document.getElementById('filteredCardsVisual');
            if (visualDiv) visualDiv.classList.remove('show');

            applyCardFilters();
        }

        function renderFilteredCards() {
            const tbody = document.getElementById('filteredCardsBody');
            const countEl = document.getElementById('filteredCardCount');

            if (!tbody || !countEl) return;

            countEl.textContent = `${filteredCards.length} Karten`;
            tbody.innerHTML = '';

            if (filteredCards.length === 0) {
                const row = document.createElement('tr');
                row.innerHTML = `<td colspan="6" class="loading">Keine Karten gefunden.</td>`;
                tbody.appendChild(row);
                return;
            }

            filteredCards.forEach(card => {
                const row = document.createElement('tr');

                const imgCell = document.createElement('td');
                if (card.image_url) {
                    const img = document.createElement('img');
                    img.className = 'card-thumbnail';
                    img.src = card.image_url;
                    img.alt = card.card_name;
                    img.onerror = () => loadCardImageWithProxy(img, card.image_url, card.card_name, 1);
                    imgCell.appendChild(img);
                } else {
                    imgCell.innerHTML = `<div class="card-thumbnail-placeholder">üÉè</div>`;
                }

                const nameCell = document.createElement('td');
                nameCell.textContent = card.card_name;

                const setCell = document.createElement('td');
                setCell.textContent = card.set_code;

                const numberCell = document.createElement('td');
                numberCell.textContent = card.set_number;

                const typeCell = document.createElement('td');
                typeCell.textContent = card.card_type;

                const totalCell = document.createElement('td');
                totalCell.textContent = card.max_count;

                row.appendChild(imgCell);
                row.appendChild(nameCell);
                row.appendChild(setCell);
                row.appendChild(numberCell);
                row.appendChild(typeCell);
                row.appendChild(totalCell);

                tbody.appendChild(row);
            });
        }

        function copyFilteredCards() {
            if (!filteredCards || filteredCards.length === 0) {
                alert('Keine Karten zum Kopieren vorhanden.');
                return;
            }

            const lines = filteredCards.map(card => {
                const parts = [card.card_name, card.set_code, card.set_number].filter(Boolean);
                return parts.join(' ');
            });

            const textToCopy = lines.join('\n');

            navigator.clipboard.writeText(textToCopy).then(() => {
                alert('‚úÖ Gefilterte Karten wurden kopiert!');
            }).catch(() => {
                prompt('Kopiere die Liste:', textToCopy);
            });
        }
        
        function filterDeckList() {
            const searchTerm = document.getElementById('deckSearch').value.toLowerCase();
            const deckSelect = document.getElementById('deckSelect');
            const options = deckSelect.getElementsByTagName('option');
            
            for (let i = 1; i < options.length; i++) { // Skip first "-- Bitte..." option
                const optionText = options[i].textContent.toLowerCase();
                if (optionText.includes(searchTerm)) {
                    options[i].style.display = '';
                } else {
                    options[i].style.display = 'none';
                }
            }
            
            // Also filter variant options based on search term
            filterVariantOptions(searchTerm);
        }
        
        function filterVariantOptions(searchTerm) {
            const variantOptions = document.getElementById('variantOptions');
            if (!variantOptions) return;
            
            const checkboxes = variantOptions.querySelectorAll('.variant-checkbox');
            checkboxes.forEach(checkbox => {
                const label = checkbox.querySelector('span');
                const variantText = label.textContent.toLowerCase();
                if (variantText.includes(searchTerm)) {
                    checkbox.style.display = '';
                } else {
                    checkbox.style.display = 'none';
                }
            });
        }
        
        function onDeckChange() {
            const selectedDeck = document.getElementById('deckSelect').value;
            if (!selectedDeck) return;
            
            updateStats(selectedDeck);
            updateVariantSelector(selectedDeck);
            updateCardsDisplay();
        }
        
        let selectedVariants = [];
        let variantsCollapsed = false;

        function toggleVariantSelector() {
            const variantOptions = document.getElementById('variantOptions');
            const toggle = document.getElementById('variantToggle');
            if (!variantOptions || !toggle) return;

            variantsCollapsed = !variantsCollapsed;
            variantOptions.style.display = variantsCollapsed ? 'none' : 'flex';
            toggle.classList.toggle('collapsed', variantsCollapsed);
            toggle.textContent = variantsCollapsed ? '‚ñ∂' : '‚ñº';
        }
        
        function updateVariantSelector(mainDeck) {
            const variantSelector = document.getElementById('variantSelector');
            const variantOptions = document.getElementById('variantOptions');
            
            // Clear previous selections
            selectedVariants = [];
            
            // Get all unique archetypes and exclude the main deck
            const allArchetypes = [...new Set(cardsData.map(c => c.archetype))].sort();
            const variants = allArchetypes.filter(arch => 
                normalizeArchetypeName(arch) !== normalizeArchetypeName(mainDeck)
            );
            
            console.log('Variant Selector - Main deck:', mainDeck, '| Other archetypes available:', variants.length);
            
            if (variants.length === 0) {
                console.log('No variants found, hiding selector');
                variantSelector.style.display = 'none';
                return;
            }
            
            // Show selector and populate options with ALL available archetypes
            console.log('Showing variant selector with', variants.length, 'options');
            variantSelector.style.display = 'block';
            variantOptions.innerHTML = variants.map(variant => {
                const safeVariant = variant.replace(/'/g, "\\'").replace(/"/g, '&quot;');
                return `
                    <label class="variant-checkbox">
                        <input type="checkbox" value="${safeVariant}" onchange="toggleVariant('${safeVariant}')">
                        <span>${variant}</span>
                    </label>
                `;
            }).join('');

            variantsCollapsed = true;
            variantOptions.style.display = 'none';
            const toggle = document.getElementById('variantToggle');
            if (toggle) {
                toggle.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
            }
        }
        
        function toggleVariant(variantName) {
            const checkbox = document.querySelector(`input[value="${variantName}"]`);
            const label = checkbox.parentElement;
            
            if (checkbox.checked) {
                selectedVariants.push(variantName);
                label.classList.add('selected');
            } else {
                selectedVariants = selectedVariants.filter(v => v !== variantName);
                label.classList.remove('selected');
            }
            
            updateCardsDisplay();
        }
        
        function updateStats(deckName) {
            const statsSection = document.getElementById('statsSection');
            
            // Get both data sources
            const cityLeagueMatch = cityLeagueData.find(m => 
                normalizeArchetypeName(m.archetype) === normalizeArchetypeName(deckName)
            );
            
            // Get Limitless data from the main decks CSV (which has rank and win_rate)
            const limitlessMatch = matchupsData.find(m => 
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(deckName)
            );
            
            // Show section if we have ANY data
            if (cityLeagueMatch || limitlessMatch) {
                statsSection.style.display = 'block';
                
                // RANKING: From limitless_online_decks.csv "rank" column (HIGHEST PRIORITY)
                if (limitlessMatch && limitlessMatch.rank) {
                    document.getElementById('statRanking').textContent = `#${limitlessMatch.rank}`;
                } else {
                    document.getElementById('statRanking').textContent = '-';
                }
                
                // WIN RATE / √ò PLATZIERUNG: Limitless > City League
                if (limitlessMatch && limitlessMatch.win_rate) {
                    // win_rate is already formatted as "51.29%" in the CSV
                    document.getElementById('statWinRate').textContent = limitlessMatch.win_rate;
                    document.getElementById('statWinRate').parentElement.querySelector('.label').textContent = 'Win Rate';
                } else if (cityLeagueMatch && cityLeagueMatch.new_avg_placement) {
                    document.getElementById('statWinRate').textContent = cityLeagueMatch.new_avg_placement;
                    document.getElementById('statWinRate').parentElement.querySelector('.label').textContent = '√ò Platzierung';
                } else {
                    document.getElementById('statWinRate').textContent = '-';
                }
                
                // MATCHES / AUFTRITTE: Limitless count > City League appearances  
                if (limitlessMatch && limitlessMatch.count) {
                    document.getElementById('statMatches').textContent = limitlessMatch.count;
                    document.getElementById('statMatches').parentElement.querySelector('.label').textContent = 'Matches';
                } else if (cityLeagueMatch && cityLeagueMatch.new_appearances) {
                    document.getElementById('statMatches').textContent = cityLeagueMatch.new_appearances;
                    document.getElementById('statMatches').parentElement.querySelector('.label').textContent = 'Auftritte';
                } else {
                    document.getElementById('statMatches').textContent = '-';
                }
                
                // MATCHUP VS TOP 20: Show count >50% vs <50% when matchups are available
                const matchupBalance = getMatchupBalance(deckName);
                if (matchupBalance) {
                    document.getElementById('statBalance').textContent = `${matchupBalance.over50}:${matchupBalance.under50}`;
                    document.getElementById('statBalance').parentElement.querySelector('.label').textContent = 'Matchup vs Top 20';
                } else if (cityLeagueMatch && cityLeagueMatch.status) {
                    // Fallback: Show City League status
                    const status = cityLeagueMatch.status;
                    let statusEmoji = '‚óè';
                    if (status === 'NEU') statusEmoji = 'üÜï';
                    else if (status === 'BESTEHEND') statusEmoji = '‚úì';
                    else if (status === 'VERSCHWUNDEN') statusEmoji = '‚ùå';
                    document.getElementById('statBalance').textContent = `${statusEmoji} ${status}`;
                    document.getElementById('statBalance').parentElement.querySelector('.label').textContent = 'Status';
                } else if (limitlessMatch) {
                    document.getElementById('statBalance').textContent = '‚úì KOMPETITIV';
                    document.getElementById('statBalance').parentElement.querySelector('.label').textContent = 'Status';
                } else {
                    document.getElementById('statBalance').textContent = '-';
                }
                
                // MATCHUPS: IMMER aus Limitless Matchup-Daten, wenn vorhanden
                if (matchupDetailsData.length > 0) {
                    updateMatchupsDisplay(deckName);
                } else if (cityLeagueMatch) {
                    // Fallback: City League Trend-Info
                    const status = cityLeagueMatch.status || 'UNBEKANNT';
                    const trend = cityLeagueMatch.trend || '-';
                    const change = cityLeagueMatch.appearances_change || '0';
                    
                    let statusEmoji = '‚óè';
                    if (status === 'NEU') statusEmoji = 'üÜï';
                    else if (status === 'BESTEHEND') statusEmoji = '‚úì';
                    else if (status === 'VERSCHWUNDEN') statusEmoji = '‚ùå';
                    
                    let trendEmoji = '‚Üí';
                    if (trend === 'STEIGEND') trendEmoji = 'üìà';
                    else if (trend === 'FALLEND') trendEmoji = 'üìâ';
                    else if (trend === 'STABIL') trendEmoji = '‚û°Ô∏è';
                    
                    document.getElementById('topMatchups').innerHTML = `
                        <div class="matchup-item">
                            <span><strong>Status:</strong> ${statusEmoji} ${status}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Trend:</strong> ${trendEmoji} ${trend}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Ver√§nderung:</strong></span>
                            <span style="color: ${change > 0 ? '#28a745' : change < 0 ? '#dc3545' : '#666'}; font-weight: bold;">
                                ${change > 0 ? '+' : ''}${change} Auftritte
                            </span>
                        </div>
                    `;
                    
                    const placementChange = parseFloat(cityLeagueMatch.placement_change || '0').toFixed(1);
                    const avgPlacement = cityLeagueMatch.new_avg_placement || '-';
                    document.getElementById('worstMatchups').innerHTML = `
                        <div class="matchup-item">
                            <span><strong>Alte √ò Platzierung:</strong></span>
                            <span>${cityLeagueMatch.old_avg_placement || '-'}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>Neue √ò Platzierung:</strong></span>
                            <span>${avgPlacement}</span>
                        </div>
                        <div class="matchup-item">
                            <span><strong>√Ñnderung:</strong></span>
                            <span style="color: ${placementChange < 0 ? '#28a745' : placementChange > 0 ? '#dc3545' : '#666'}; font-weight: bold;">
                                ${placementChange > 0 ? '+' : ''}${placementChange}
                            </span>
                        </div>
                        <p style="margin-top: 15px; color: #666; font-size: 0.9em;">
                            <strong>Info:</strong> City League Daten zeigen Trends √ºber Zeitr√§ume, keine direkten Matchups.
                        </p>
                    `;
                }
                
            } else {
                statsSection.style.display = 'none';
            }
        }
        
        function normalizeArchetypeName(name) {
            if (!name) return '';
            return name.toLowerCase().trim()
                .replace(/\s+/g, ' ')
                .replace(/[√†√°√¢√£√§√•]/g, 'a')
                .replace(/[√®√©√™√´]/g, 'e')
                .replace(/[√¨√≠√Æ√Ø]/g, 'i')
                .replace(/[√≤√≥√¥√µ√∂]/g, 'o')
                .replace(/[√π√∫√ª√º]/g, 'u');
        }

        function getMatchupBalance(deckName) {
            if (!matchupDetailsData || matchupDetailsData.length === 0) return null;

            const deckMatchups = matchupDetailsData.filter(m =>
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(deckName)
            );

            if (deckMatchups.length === 0) return null;

            let over50 = 0;
            let under50 = 0;

            deckMatchups.forEach(m => {
                const winRate = parseFloat(String(m.win_rate || '').replace('%', '').replace(',', '.'));
                if (Number.isNaN(winRate)) return;
                if (winRate > 50) over50 += 1;
                else if (winRate < 50) under50 += 1;
            });

            return { over50, under50 };
        }
        
        function updateMatchupsDisplay(deckName) {
            // Get matchup details from limitless_online_decks_matchups.csv
            const deckMatchups = matchupDetailsData.filter(m => 
                normalizeArchetypeName(m.deck_name) === normalizeArchetypeName(deckName)
            );
            
            if (deckMatchups.length === 0) {
                document.getElementById('topMatchups').innerHTML = '<p>Keine Matchup-Daten verf√ºgbar</p>';
                document.getElementById('worstMatchups').innerHTML = '<p>Keine Matchup-Daten verf√ºgbar</p>';
                return;
            }
            
            const topMatchups = deckMatchups.filter(m => m.matchup_type === 'BEST').slice(0, 5);
            const worstMatchups = deckMatchups.filter(m => m.matchup_type === 'WORST').slice(0, 5);
            
            document.getElementById('topMatchups').innerHTML = topMatchups.map(m => 
                `<div class="matchup-item"><span>${m.opponent}</span><span style="color: #28a745; font-weight: bold;">${m.win_rate}% (${m.record})</span></div>`
            ).join('') || '<p>Keine Daten verf√ºgbar</p>';
            
            document.getElementById('worstMatchups').innerHTML = worstMatchups.map(m => 
                `<div class="matchup-item"><span>${m.opponent}</span><span style="color: #dc3545; font-weight: bold;">${m.win_rate}% (${m.record})</span></div>`
            ).join('') || '<p>Keine Daten verf√ºgbar</p>';
        }
        
        function updateCardsDisplay() {
            const selectedDeck = document.getElementById('deckSelect').value;
            const filter = document.getElementById('filterSelect').value;
            
            if (!selectedDeck) {
                document.getElementById('cardsBody').innerHTML = '<tr><td colspan="7" class="loading">Bitte w√§hle ein Deck aus...</td></tr>';
                document.getElementById('deckVisual').style.display = 'none';
                return;
            }
            
            // Filter cards for selected deck AND selected variants
            const decksToInclude = [selectedDeck, ...selectedVariants];
            let deckCards = cardsData.filter(c => decksToInclude.includes(c.archetype));
            
            console.log('Initial filtered cards:', deckCards.length, 'from archetype:', selectedDeck);
            if (deckCards.length > 0) {
                console.log('First card image_url:', deckCards[0].image_url);
            }
            
            // Aggregate cards by name (combine same cards from different variants)
            const cardMap = new Map();
            deckCards.forEach(card => {
                const key = `${card.card_name}_${card.set_code}_${card.set_number}`;
                if (!cardMap.has(key)) {
                    cardMap.set(key, { ...card, sources: [card.archetype] });
                } else {
                    const existing = cardMap.get(key);
                    if (!existing.sources.includes(card.archetype)) {
                        existing.sources.push(card.archetype);
                    }
                }
            });
            
            deckCards = Array.from(cardMap.values());
            
            console.log('After aggregation:', deckCards.length, 'cards');
            if (deckCards.length > 0) {
                console.log('First aggregated card:', deckCards[0].card_name, 'image_url:', deckCards[0].image_url);
            }
            
            // Apply percentage filter (only for main deck)
            if (filter === '70') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 70 ||
                    c.archetype !== selectedDeck
                );
            } else if (filter === '50') {
                deckCards = deckCards.filter(c => 
                    c.archetype === selectedDeck && parseFloat(c.percentage_in_archetype.replace(',', '.')) > 50 ||
                    c.archetype !== selectedDeck
                );
            }
            
            // Update count
            document.getElementById('cardCount').textContent = `${deckCards.length} Karten`;
            
            // Sort cards by type (Pokemon, Supporter, Item, Tool, Stadium, Special Energy, Energy)
            deckCards = sortCardsByType(deckCards);
            
            // Update deck visual grid
            updateDeckVisual(deckCards);
            
            // Display cards in table
            const tbody = document.getElementById('cardsBody');
            if (deckCards.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" class="loading">Keine Karten gefunden</td></tr>';
                return;
            }
            
            console.log('Final deck cards for display:', deckCards.length);
            if (deckCards.length > 0) {
                console.log('Sample card:', {
                    name: deckCards[0].card_name,
                    imageUrl: deckCards[0].image_url,
                    hasImage: !!deckCards[0].image_url
                });
            }
            
            tbody.innerHTML = deckCards.map(card => {
                const percentage = parseFloat(card.percentage_in_archetype.replace(',', '.'));
                const imageUrl = card.image_url || '';
                
                // Create thumbnail HTML
                let thumbnailHtml;
                if (imageUrl && imageUrl.trim() !== '') {
                    thumbnailHtml = `<img src="${imageUrl}" alt="${card.card_name}" class="card-thumbnail" onclick="showCardImage('${imageUrl}', '${card.card_name}')" referrerpolicy="no-referrer" onerror="loadCardImageWithProxy(this, '${imageUrl}', '${card.card_name}', 1)">`;
                } else {
                    thumbnailHtml = `<div class="card-thumbnail-placeholder">üÉè</div>`;
                }
                
                // Show source decks if from variants
                let sourceInfo = '';
                if (card.sources && card.sources.length > 1) {
                    sourceInfo = `<br><small style="color: #667eea;">aus: ${card.sources.join(', ')}</small>`;
                } else if (card.sources && card.sources[0] !== document.getElementById('deckSelect').value) {
                    sourceInfo = `<br><small style="color: #667eea;">aus: ${card.sources[0]}</small>`;
                }
                
                return `
                    <tr>
                        <td>${thumbnailHtml}</td>
                        <td class="card-count">${card.max_count}</td>
                        <td><strong>${card.card_name}</strong>${sourceInfo}</td>
                        <td>${card.set_code || '-'}</td>
                        <td>${card.set_number || '-'}</td>
                        <td><span style="color: ${percentage > 70 ? '#28a745' : percentage > 50 ? '#ffc107' : '#666'}; font-weight: bold;">${card.percentage_in_archetype}%</span></td>
                        <td><button class="btn btn-sm" onclick="addToDeck('${card.card_identifier}', ${card.max_count}, '${card.card_name}', '${imageUrl}')">‚ûï Hinzuf√ºgen</button></td>
                    </tr>
                `;
            }).join('');
        }
        
        function updateDeckVisual(deckCards) {
            const deckGrid = document.getElementById('deckGrid');
            const deckVisual = document.getElementById('deckVisual');
            
            if (deckCards.length === 0) {
                deckVisual.style.display = 'none';
                return;
            }
            
            deckVisual.style.display = 'block';
            
            // Show cards with images prominently
            deckGrid.innerHTML = deckCards.map(card => {
                const imageUrl = card.image_url || '';
                const count = card.max_count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" onclick="showCardImage('${imageUrl}', '${card.card_name}')">
                            <img src="${imageUrl}" 
                                 alt="${card.card_name}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="loadCardImageWithProxy(this, '${imageUrl}', '${card.card_name}', ${count})">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.card_name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">üÉè</div>
                                <div>${card.card_name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function showCardImage(imageUrl, cardName) {
            // Create modal to show full card image
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.9);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                cursor: pointer;
            `;
            
            modal.innerHTML = `
                <div style="max-width: 90%; max-height: 90%; text-align: center;">
                    <img src="${imageUrl}" alt="${cardName}" style="max-width: 100%; max-height: 80vh; border-radius: 15px; box-shadow: 0 10px 50px rgba(0,0,0,0.5);">
                    <div style="color: white; margin-top: 20px; font-size: 1.5em; font-weight: bold;">${cardName}</div>
                    <div style="color: #ccc; margin-top: 10px;">Klicke irgendwo, um zu schlie√üen</div>
                </div>
            `;
            
            modal.onclick = () => document.body.removeChild(modal);
            document.body.appendChild(modal);
        }
        
        function addToDeck(cardIdentifier, maxCount, cardName, imageUrl) {
            const existingCard = myDeck.find(c => c.identifier === cardIdentifier);
            
            if (existingCard) {
                if (existingCard.count < Math.min(4, maxCount)) {
                    existingCard.count++;
                }
            } else {
                myDeck.push({
                    identifier: cardIdentifier,
                    name: cardName,
                    count: 1,
                    maxCount: Math.min(4, maxCount),
                    imageUrl: imageUrl
                });
            }
            
            updateDeckDisplay();
        }
        
        function removeFromDeck(cardName) {
            const card = myDeck.find(c => c.name === cardName);
            if (card) {
                card.count--;
                if (card.count <= 0) {
                    myDeck = myDeck.filter(c => c.name !== cardName);
                }
            }
            updateDeckDisplay();
        }
        
        function updateDeckDisplay() {
            const deckList = document.getElementById('deckList');
            const totalCards = myDeck.reduce((sum, card) => sum + card.count, 0);
            
            document.getElementById('deckCardCount').textContent = totalCards;
            
            // Update visual grid
            updateMyDeckVisual();
            
            if (myDeck.length === 0) {
                deckList.innerHTML = '<p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>';
                return;
            }
            
            deckList.innerHTML = myDeck.map(card => {
                let cardVisual = '';
                if (card.imageUrl && card.imageUrl.trim() !== '') {
                    cardVisual = `
                        <div style="width: 60px; height: 80px; margin-right: 10px; cursor: pointer;" onclick="showCardImage('${card.imageUrl}', '${card.name}')">
                            <img src="${card.imageUrl}" alt="${card.name}" style="width: 100%; height: 100%; object-fit: cover; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);" referrerpolicy="no-referrer" onerror="loadCardImageWithProxy(this, '${card.imageUrl}', '${card.name}', 1)">
                        </div>
                    `;
                } else {
                    cardVisual = `
                        <div style="width: 60px; height: 80px; margin-right: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 5px; display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;">
                            üÉè
                        </div>
                    `;
                }
                
                return `
                    <div class="deck-card" style="display: flex; align-items: center;">
                        ${cardVisual}
                        <div style="flex: 1;">
                            <strong>${card.count}x ${card.name}</strong>
                        </div>
                        <div class="deck-card-controls">
                            <button class="btn-add" onclick="addToDeck('${card.identifier}', ${card.maxCount}, '${escapeHtml(card.name)}', '${card.imageUrl || ''}')">+</button>
                            <button class="btn-remove" onclick="removeFromDeck('${escapeHtml(card.name)}')">-</button>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function updateMyDeckVisual() {
            const myDeckVisual = document.getElementById('myDeckVisual');
            const myDeckGrid = document.getElementById('myDeckGrid');
            
            if (myDeck.length === 0) {
                myDeckVisual.style.display = 'none';
                return;
            }
            
            myDeckVisual.style.display = 'block';
            
            // Show each card ONCE with count badge (nicht mehrfach)
            myDeckGrid.innerHTML = myDeck.map(card => {
                const imageUrl = card.imageUrl || '';
                const count = card.count || 1;
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="card-visual" onclick="showCardImage('${imageUrl}', '${card.name}')">
                            <img src="${imageUrl}" alt="${card.name}" referrerpolicy="no-referrer" onerror="loadCardImageWithProxy(this, '${imageUrl}', '${card.name}', ${count})">
                            <div class="card-count-badge">${count}</div>
                            <div class="card-name-overlay">${card.name}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="card-visual no-image">
                            <div class="fallback-content">
                                <div class="fallback-icon">\ud83c\udccf</div>
                                <div>${card.name}</div>
                                <div class="card-count-badge">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
        }
        
        function clearDeck() {
            if (confirm('Willst du das Deck wirklich leeren?')) {
                myDeck = [];
                updateDeckDisplay();
            }
        }
        
        function autoComplete() {
            const selectedDeck = document.getElementById('deckSelect').value;
            if (!selectedDeck) {
                alert('Bitte w√§hle zuerst ein Deck aus!');
                return;
            }
            
            myDeck = [];
            let deckCards = cardsData.filter(c => c.archetype === selectedDeck);
            
            // Sort by card type first, then by percentage
            deckCards = sortCardsByType(deckCards);
            
            let totalCards = 0;
            for (const card of deckCards) {
                if (totalCards >= 60) break;
                
                // Berechne Durchschnitt: total_count / deck_count
                const avgCount = parseFloat(card.total_count) / parseFloat(card.deck_count);
                // Runde: ab x,5 aufrunden, sonst abrunden
                const recommendedCount = Math.round(avgCount);
                
                const count = Math.min(
                    recommendedCount || 1,
                    4,
                    60 - totalCards
                );
                
                if (count > 0) {
                    myDeck.push({
                        identifier: card.card_identifier,
                        name: card.card_name,
                        count: count,
                        maxCount: Math.min(4, recommendedCount || 4),
                        imageUrl: card.image_url || ''
                    });
                    totalCards += count;
                }
            }
            
            updateDeckDisplay();
        }
        
        function exportToPokemonLive() {
            if (myDeck.length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            let exportText = 'Pok√©mon: \n';
            let trainerText = 'Trainer: \n';
            let energyText = 'Energy: \n';
            
            myDeck.forEach(card => {
                const line = `${card.count} ${card.name} ${card.setCode || ''} ${card.setNumber || ''}\n`.trim() + '\n';
                
                // Simple categorization (you can improve this)
                if (card.name.includes('Energy') || card.name.includes('energie')) {
                    energyText += line;
                } else if (isTrainerCard(card.name)) {
                    trainerText += line;
                } else {
                    exportText += line;
                }
            });
            
            const fullExport = exportText + '\n' + trainerText + '\n' + energyText;
            
            navigator.clipboard.writeText(fullExport).then(() => {
                alert('‚úÖ Deckliste wurde in die Zwischenablage kopiert!\n\nF√ºge sie jetzt in Pokemon Live ein.');
            }).catch(err => {
                prompt('Kopiere diese Deckliste:', fullExport);
            });
        }
        
        function getCardType(cardName) {
            /**
             * Determines card type based on all_cards_database.csv
             * Falls back to keyword matching if not found in database
             * WICHTIG: Basic Energy Namen m√ºssen ZUERST gepr√ºft werden!
             */
            const name = cardName.toLowerCase();
            
            const basicEnergyNames = [
                'grass energy',
                'fire energy',
                'water energy',
                'lightning energy',
                'psychic energy',
                'fighting energy',
                'darkness energy',
                'metal energy',
                'fairy energy',
                'dragon energy'
            ];
            const specialEnergyNames = [
                'telepath'
            ];
            
            // FIRST: Check for basic energies (BEFORE database lookup!)
            if (basicEnergyNames.includes(name)) {
                return 'Energy';
            }
            
            // Special energies
            if (specialEnergyNames.includes(name)) {
                return 'Special Energy';
            }
            
            // Now try to get from database
            if (cardTypeDatabase.has(cardName)) {
                const dbType = cardTypeDatabase.get(cardName);
                
                // Map database types to our categories
                if (dbType === 'Supporter') return 'Supporter';
                if (dbType === 'Stadium') return 'Stadium';
                if (dbType === 'Item') return 'Item';
                if (dbType === 'Tool') return 'Tool';
                
                // Pokemon types (e.g., "GBasic", "WStage 1", "PBasic", etc.)
                if (dbType && (dbType.includes('Basic') || dbType.includes('Stage') || dbType.includes('V') || dbType.includes('VMAX'))) {
                    return 'Pokemon';
                }
                
                // Energy types from database
                if (dbType && dbType.includes('Energy')) {
                    if (dbType.includes('Special')) return 'Special Energy';
                    return 'Energy';
                }
            }
            
            // Fallback: keyword matching for remaining energy cards
            if (name.endsWith('energy') && !name.includes('special')) {
                return 'Energy';
            }
            
            // Energy cards
            if (name.includes('energy') || name.includes('energie')) {
                if (name.includes('special energy') || name.includes('blend') || name.includes('aurora') || 
                    name.includes('prism') || name.includes('rainbow') || name.includes('crystal') ||
                    name.includes('double colorless') || name.includes('triple') || name.includes('twin') ||
                    name.includes('fusion')) {
                    return 'Special Energy';
                }
                return 'Energy';
            }
            
            // Default: Pokemon
            return 'Pokemon';
        }
        
        function sortCardsByType(cards) {
            /**
             * Sort cards by type priority:
             * Pokemon ‚Üí Supporter ‚Üí Item ‚Üí Tool ‚Üí Stadium ‚Üí Special Energy ‚Üí Energy (ganz am Ende)
             * Within each type, sort by percentage (highest first) or by name
             */
            const typeOrder = {
                'Pokemon': 1,
                'Supporter': 2,
                'Item': 3,
                'Tool': 4,
                'Stadium': 5,
                'Special Energy': 6,
                'Energy': 7
            };
            
            return cards.sort((a, b) => {
                const typeA = getCardType(a.card_name);
                const typeB = getCardType(b.card_name);
                const orderA = typeOrder[typeA] || 99;
                const orderB = typeOrder[typeB] || 99;
                
                // First sort by type
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // Within same type, sort by percentage (highest first) if available
                if (a.percentage_in_archetype && b.percentage_in_archetype) {
                    const percA = parseFloat(a.percentage_in_archetype.replace(',', '.')) || 0;
                    const percB = parseFloat(b.percentage_in_archetype.replace(',', '.')) || 0;
                    if (percA !== percB) {
                        return percB - percA;
                    }
                }
                
                // Otherwise sort by name
                return a.card_name.localeCompare(b.card_name);
            });
        }
        
        function isTrainerCard(cardName) {
            const cardType = getCardType(cardName);
            return cardType !== 'Pokemon' && cardType !== 'Energy';
        }
        
        function escapeHtml(text) {
            return text.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }
        
        function showError(message) {
            const cardsBody = document.getElementById('cardsBody');
            cardsBody.innerHTML = `<tr><td colspan="6"><div class="error">${message}</div></td></tr>`;
        }
    </script>
    <!-- Version: 2026-02-05 09:25 -->
</body>
</html>
