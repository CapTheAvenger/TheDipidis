<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="data:,">
    <title>Pokemon TCG Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html { scroll-behavior: smooth; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            padding: 30px 20px;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .tabs-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            overflow: hidden;
        }
        
        .tab-navigation {
            display: flex;
            gap: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            flex-wrap: wrap;
            overflow-x: auto;
        }
        
        .tab-btn {
            padding: 12px 16px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 13px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .tab-btn.active {
            background: white;
            color: #667eea;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
            background: white;
            min-height: 400px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tab-content h1 {
            color: #333;
            margin-bottom: 30px;
            text-shadow: none;
            text-align: center;
        }
        
        .tab-content h2 {
            color: #34495e;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
            margin-top: 30px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 16px;
        }
        
        .error {
            background: #ffe6e6;
            border-left: 4px solid #e74c3c;
            color: #e74c3c;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px 0;
        }
        
        table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        table th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }
        
        table td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        table tbody tr:hover {
            background: #f8f9fa;
        }
        
        .metadata {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            text-align: center;
            font-weight: bold;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .stat-card .value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
        }
        
        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .trend {
            font-weight: bold;
        }
        
        .trend.improved { color: #27ae60; }
        .trend.declined { color: #e67e22; }
        .trend.stable { color: #95a5a6; }
        
        .change {
            font-weight: bold;
        }
        
        .change.positive { color: #27ae60; }
        .change.negative { color: #e74c3c; }
        
        .search-box {
            margin: 20px 0;
        }
        
        .search-box input {
            width: 100%;
            max-width: 400px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .footer {
            text-align: center;
            color: white;
            padding: 20px;
            margin-top: 30px;
        }

        .analysis-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .analysis-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .analysis-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .analysis-header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 3px solid #667eea;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .control-group select,
        .control-group input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .control-group select:focus,
        .control-group input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .cards-section {
            padding: 30px;
            background: #f8f9fa;
        }

        .cards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .card-search-input {
            width: 100%;
            max-width: 500px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
        }

        .card-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .cards-table {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .city-league-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .city-league-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .city-league-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Deck Visual Styles */
        .deck-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .deck-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            max-height: 800px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .card-visual {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            background: #f0f0f0;
        }
        
        .card-visual:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        
        .card-visual img {
            width: 90px;
            height: 126px;
            display: block;
            object-fit: cover;
        }
        
        .card-visual .card-count-badge {
            position: absolute;
            top: 3px;
            right: 3px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
            z-index: 2;
        }

        /* Deck Builder Styles */
        .deck-builder {
            padding: 30px;
            background: white;
            border-top: 3px solid #667eea;
        }
        
        .deck-builder h2 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .builder-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .rarity-pref-group {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            padding: 4px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .rarity-pref-btn {
            background: #ffffff;
            color: #333;
            border: 1px solid #d1d5db;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .rarity-pref-btn.active {
            background: #ffc107;
            border-color: #e0a800;
            color: #333;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .deck-summary {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .deck-summary h3 {
            margin: 0;
            color: #333;
        }

        .deck-list {
            background: white;
            border-radius: 10px;
            padding: 20px;
            min-height: 200px;
        }

        .cards-table-header {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .cards-table-header:hover {
            background: #e9ecef;
        }

        .cards-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cards-toggle {
            display: inline-block;
            width: 24px;
            height: 24px;
            margin-right: 10px;
            cursor: pointer;
            font-size: 20px;
            line-height: 24px;
            transition: transform 0.3s ease;
        }

        /* Pok√©ball icon - open state */
        .cards-toggle::before {
            content: '‚ö´';
            color: #667eea;
        }

        /* Pok√©ball icon - closed state */
        .cards-toggle.collapsed::before {
            content: '‚ö™';
            color: #667eea;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-card .label {
            opacity: 0.9;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }

        /* Matchups */
        .matchups-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        /* Deck Visual */
        .deck-visual {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }
        
        .deck-card {
            position: relative;
            width: 100%;
            padding-bottom: 140%;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        .deck-card:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .deck-card img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .card-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        
        .card-count {
            background: #667eea;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .card-percentage {
            color: white;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .card-max-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            padding: 2px 6px;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.7em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 2;
        }
        
        /* .card-deck-count removed as per user request */

        @media (max-width: 768px) {
            .matchups-grid {
                grid-template-columns: 1fr !important;
            }
            
            .deck-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
            }
        }

        /* Image View Modal */
        .image-view-modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow: auto;
        }

        .image-view-modal.show {
            display: block;
        }

        .image-view-content {
            background-color: #fff;
            margin: 2% auto;
            padding: 30px;
            width: 95%;
            max-width: 1400px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .image-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .image-view-header h3 {
            margin: 0;
            color: #333;
            font-size: 1.8em;
        }

        .image-view-close {
            background: #e74c3c;
            color: white;
            border: none;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .image-view-close:hover {
            background: #c0392b;
            transform: rotate(90deg);
        }

        .compact-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 12px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 10px;
        }

        .compact-card {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            aspect-ratio: 245/342;
        }

        .compact-card:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .compact-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .compact-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 50%;
            min-width: 24px;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .image-view-content {
                width: 98%;
                padding: 15px;
                margin: 5% auto;
            }

            .compact-card-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
                padding: 10px;
            }

            /* Mobile Compact Grid - f√ºr Screenshot ohne Scrollen */
            .mobile-compact-grid {
                grid-template-columns: repeat(10, 1fr) !important;
                gap: 3px !important;
                padding: 5px !important;
            }

            .mobile-compact-grid .compact-card {
                aspect-ratio: 245/342;
                border-radius: 3px;
            }

            .mobile-compact-grid .compact-badge {
                font-size: 8px !important;
                padding: 1px 3px !important;
                min-width: 14px !important;
                top: 2px;
                right: 2px;
            }

            .compact-badge {
                font-size: 11px;
                padding: 2px 6px;
                min-width: 20px;
            }
        }

        /* Single Card View Modal */
        .single-card-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            overflow: auto;
            animation: fadeIn 0.3s ease;
        }

        .single-card-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .single-card-modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90vh;
            animation: zoomIn 0.3s ease;
        }

        .single-card-modal-content img {
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 90vh;
            border-radius: 15px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        .single-card-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: #e74c3c;
            color: white;
            border: none;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .single-card-close:hover {
            background: #c0392b;
            transform: rotate(90deg) scale(1.1);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes zoomIn {
            from {
                transform: scale(0.7);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .single-card-modal-content {
                max-width: 95%;
            }

            .single-card-close {
                top: 10px;
                right: 10px;
                width: 40px;
                height: 40px;
                font-size: 24px;
            }
        }

        /* Rarity Switcher Modal Styles */
        .rarity-switcher-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s ease-in-out;
        }

        .rarity-switcher-modal.show {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .rarity-switcher-modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease-in-out;
        }

        .rarity-switcher-modal h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            font-size: 24px;
            text-align: center;
        }

        .rarity-options-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .rarity-option-card {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            background-color: #f9f9f9;
        }

        .rarity-option-card:hover {
            border-color: #4CAF50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
            transform: translateY(-2px);
        }

        .rarity-option-card.selected {
            border-color: #4CAF50;
            background-color: #e8f5e9;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .rarity-option-card img {
            width: 100%;
            max-width: 150px;
            height: auto;
            margin-bottom: 8px;
            border-radius: 4px;
        }


        .rarity-option-info {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
            line-height: 1.4;
        }

        .rarity-badge {
            display: inline-block;
            background-color: #FDB927;
            color: #333;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            margin-top: 5px;
        }

        .rarity-switcher-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .rarity-switcher-modal-buttons button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }

        .rarity-switcher-modal-buttons .mixed-rarity-btn {
            background-color: #ffc107;
            color: #333;
        }

        .rarity-switcher-modal-buttons .reset-rarity-btn {
            background-color: #6c757d;
        }

        .rarity-switcher-modal-buttons button:hover {
            background-color: #45a049;
        }

        .rarity-switcher-modal-buttons button:active {
            transform: scale(0.98);
        }

        .rarity-switcher-close {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .rarity-switcher-close:hover {
            color: #000;
        }

        .rarity-switcher-modal-content {
            position: relative;
        }

        @media (max-width: 768px) {
            .rarity-switcher-modal-content {
                max-width: 95%;
                max-height: 90vh;
                padding: 20px;
            }

            .rarity-options-list {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
            }

            .rarity-switcher-modal-buttons {
                flex-direction: column;
            }

            .rarity-switcher-modal-buttons button {
                width: 100%;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        /* =========================
           MOBILE OPTIMIZATIONS
           ========================= */
        
        /* Medium Mobile Devices (Tablets & Large Phones) */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .header p {
                font-size: 1em;
            }

            .tab-content {
                padding: 15px;
            }

            .stat-card .value {
                font-size: 2em;
            }

            table {
                font-size: 0.9em;
            }

            table th, table td {
                padding: 8px 5px;
            }
        }

        /* Small Mobile Devices (Most Smartphones) */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .container {
                max-width: 100%;
            }

            .header {
                padding: 20px 10px;
                margin-bottom: 15px;
            }

            .header h1 {
                font-size: 1.5em;
                margin-bottom: 5px;
            }

            .header p {
                font-size: 0.9em;
            }

            .tabs-container {
                border-radius: 10px;
            }

            .tab-navigation {
                padding: 10px;
                gap: 8px;
            }

            .tab-btn {
                padding: 10px 12px;
                font-size: 12px;
                min-height: 44px; /* Touch-Target Mindestgr√∂√üe */
            }

            .tab-content {
                padding: 10px;
                min-height: 300px;
            }

            .stat-card {
                padding: 15px;
            }

            .stat-card .value {
                font-size: 1.8em;
            }

            /* Controls auf Mobile optimieren */
            .controls {
                padding: 15px;
            }

            /* Control-Row: Vertical Stacking auf Mobile */
            .control-row {
                flex-direction: column;
                gap: 15px;
            }

            /* Control-Group: Volle Breite auf Mobile */
            .control-group {
                min-width: 100%;
                width: 100%;
            }

            /* Datum-Filter f√ºr Mobile optimieren */
            .controls input[type="date"],
            .controls input[type="text"],
            .controls select,
            .controls button {
                min-height: 44px; /* Touch-Target Mindestgr√∂√üe */
                font-size: 14px; /* Kompakter f√ºr Mobile */
                padding: 10px;
                width: 100%;
            }
            
            .control-group label {
                font-size: 12px;
                margin-bottom: 4px;
            }

            /* Grid-Layout f√ºr Datum-Filter auf Mobile: Stacked */
            .control-group > div[style*="grid-template-columns"] {
                display: flex !important;
                flex-direction: column !important;
                gap: 10px !important;
            }

            /* Tabellen horizontal scrollbar */
            .tab-content table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
                font-size: 0.85em;
            }

            .tab-content table th,
            .tab-content table td {
                padding: 6px 4px;
                font-size: 0.85em;
            }

            /* Buttons gr√∂√üer f√ºr Touch */
            button {
                min-width: 44px;
                min-height: 44px;
            }

            /* Karten-Grid optimieren */
            .card-grid {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)) !important;
                gap: 5px;
            }

            /* Deck-Overview Cards */
            #cityLeagueDeckOverview,
            #cityLeagueDeckSearchResults {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)) !important;
                gap: 10px;
            }

            /* Dein Deck Grid - Kleinere Karten auf Mobile */
            #cityLeagueMyDeckGrid {
                grid-template-columns: repeat(auto-fill, minmax(90px, 1fr)) !important;
                gap: 8px;
            }

            /* Deck-Karten Buttons kleiner auf Mobile */
            #cityLeagueMyDeckGrid .deck-card button {
                font-size: 10px !important;
                min-width: 16px !important;
                min-height: 16px !important;
            }

            #cityLeagueMyDeckGrid .deck-card > div[style*="grid-template-columns"] {
                grid-template-columns: 16px 1fr 16px !important;
                gap: 2px !important;
                bottom: 3px !important;
            }

            #cityLeagueMyDeckGrid .deck-card .card-max-count {
                font-size: 14px !important;
                width: 24px !important;
                height: 24px !important;
            }

            /* Stats √ºber Buttons kompakter */
            #cityLeagueMyDeckGrid .deck-card div[style*="bottom: 30px"] {
                font-size: 7px !important;
                padding: 1px 2px !important;
                bottom: 22px !important;
            }

            /* Metadata und Stats kompakter */
            .metadata {
                padding: 10px;
                font-size: 0.9em;
            }

            .stat-card h3 {
                font-size: 1em;
            }

            /* Modal Content auf Mobile */
            .image-view-content,
            .rarity-switcher-modal-content {
                padding: 10px;
                width: 98%;
            }

            .rarity-option-card {
                padding: 8px;
            }

            .rarity-option-card img {
                max-width: 100px;
            }
        }

        /* Very Small Mobile Devices (Small Phones) */
        @media (max-width: 375px) {
            .header h1 {
                font-size: 1.3em;
            }

            .tab-btn {
                padding: 8px 10px;
                font-size: 11px;
            }

            .stat-card .value {
                font-size: 1.5em;
            }

            .tab-content table th,
            .tab-content table td {
                padding: 4px 2px;
                font-size: 0.75em;
            }

            #cityLeagueDeckOverview,
            #cityLeagueDeckSearchResults {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)) !important;
            }

            /* Noch kleinere Deck-Karten auf kleinen Phones */
            #cityLeagueMyDeckGrid {
                grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)) !important;
                gap: 5px;
            }
        }

        /* Grid-Ansicht: Kompakte Darstellung f√ºr Screenshots */
        @media (max-width: 768px) {
            .grid-view-active #cityLeagueDeckOverview {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)) !important;
                gap: 5px;
            }

            .grid-view-active #cityLeagueDeckOverview .deck-card img {
                max-height: 84px;
            }

            .grid-view-active #cityLeagueDeckOverview .deck-card {
                font-size: 8px;
            }

            .grid-view-active #cityLeagueDeckOverview .card-max-count,
            .grid-view-active #cityLeagueDeckOverview .card-in-deck-count {
                font-size: 10px !important;
                width: 20px !important;
                height: 20px !important;
            }

            .grid-view-active #cityLeagueDeckOverview button {
                font-size: 8px !important;
                padding: 2px 4px !important;
                min-width: 14px !important;
                min-height: 14px !important;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¥ Pokemon TCG Analyse</h1>
            <p>Dein Portal f√ºr Meta-Analysen und Deckbuilding</p>
        </div>
        
        <div class="tabs-container">
            <div class="tab-navigation">
                <button class="tab-btn active" onclick="switchTab('city-league')">üáØüáµ City League Meta</button>
                <button class="tab-btn" onclick="switchTab('city-league-analysis')">üìä City League Deck Analysis</button>
                <button class="tab-btn" onclick="switchTab('current-meta')">üéÆ Current Meta</button>
                <button class="tab-btn" onclick="switchTab('current-analysis')">üìà Current Meta Deck Analysis</button>
                <button class="tab-btn" onclick="switchTab('past-meta')">üèÜ Past Meta</button>
                <button class="tab-btn" onclick="switchTab('cards')">üß∞ Cards</button>
            </div>
            
            <!-- Tab 1: City League Meta -->
            <div id="city-league" class="tab-content active">
                <div class="city-league-container">
                    <div class="city-league-header">
                        <h1>üáØüáµ City League Development</h1>
                    </div>
                    <div id="cityLeagueContent" style="padding: 30px; background: #ffffff;">
                        <div style="text-align: center; padding: 40px; color: #999;">L√§dt...</div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 2: City League Deck Analysis -->
            <div id="city-league-analysis" class="tab-content">
                <div class="container">
                    <div class="header">
                        <h1>ü¶Ö City League Deck Analysis</h1>
                        <p>Analyze and Build Decks</p>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group" style="margin-bottom: 20px;">
                            <label>üìÖ Turnier-Zeitraum Filter:</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 15px; align-items: end;">
                                <div>
                                    <label for="cityLeagueDateFrom" style="font-size: 0.9em; color: #666; display: block; margin-bottom: 5px;">Von:</label>
                                    <input type="date" id="cityLeagueDateFrom" onchange="applyCityLeagueDateFilter()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                </div>
                                <div>
                                    <label for="cityLeagueDateTo" style="font-size: 0.9em; color: #666; display: block; margin-bottom: 5px;">Bis:</label>
                                    <input type="date" id="cityLeagueDateTo" onchange="applyCityLeagueDateFilter()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                </div>
                                <div>
                                    <button onclick="resetCityLeagueDateFilter()" style="padding: 12px 20px; font-size: 0.95em; background: #f0f0f0; color: #333; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.background='#e0e0e0'" onmouseout="this.style.background='#f0f0f0'">üîÑ Alle Daten</button>
                                </div>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-group">
                                <label for="cityLeagueDeckSearch">üîç Deck suchen:</label>
                                <input type="text" id="cityLeagueDeckSearch" placeholder="Deck-Name eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                            </div>
                            <div class="control-group">
                                <label for="cityLeagueDeckSelect">üéØ Deck Archetype w√§hlen:</label>
                                <select id="cityLeagueDeckSelect" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                    <option value="">-- Bitte Deck ausw√§hlen --</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="cityLeagueFilterSelect">ü¶Ç Karten Filter:</label>
                                <select id="cityLeagueFilterSelect">
                                    <option value="all">Alle Karten</option>
                                    <option value="90">Karten in >90% der Decks (Core)</option>
                                    <option value="70">Karten in >70% der Decks</option>
                                    <option value="50">Karten in >50% der Decks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stats-section" id="cityLeagueStatsSection" style="display: none;">
                        <h2>üìä Deck Statistiken</h2>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="label">Cards in Deck (Unique / Total)</div>
                                <div class="value" id="cityLeagueStatCards">-</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Decks Used</div>
                                <div class="value" id="cityLeagueStatDecksUsed">-</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Avg Placement</div>
                                <div class="value" id="cityLeagueStatAvgPlacement">-</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="cards-section">
                        <div class="cards-header">
                            <h2>üÉè Karten Liste</h2>
                            <span style="font-size: 1.1em; color: #333;"><span id="cityLeagueCardCount">0 Karten</span><span id="cityLeagueCardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
                        </div>
                        
                        <!-- Deck Visualisierung -->
                        <div class="deck-visual" id="cityLeagueDeckVisual" style="display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="margin: 0;">üé® Deck √úbersicht (Tabelle)</h3>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-warning" onclick="toggleDeckGridView()" style="padding: 8px 16px; font-size: 0.9em;">üîÑ Grid</button>
                                    <button class="btn btn-primary" onclick="copyDeckOverview()" style="padding: 8px 16px; font-size: 0.9em;">üìã Copy</button>
                                </div>
                            </div>
                            <div class="deck-grid" id="cityLeagueDeckGrid"></div>
                        </div>
                        
                        <!-- Card Overview Grid (Collapsible) -->
                        <div class="cards-table-header" onclick="toggleCityLeagueDeckOverview()" style="margin-bottom: 30px;">
                            <div class="cards-header-left">
                                <span class="cards-toggle" id="cityLeagueDeckOverviewToggle"></span>
                                <h3>üìä Karten √úbersicht (sortiert)</h3>
                            </div>
                        </div>
                        <div id="cityLeagueDeckOverviewContent" style="display: block; margin-bottom: 30px;">
                            <div id="cityLeagueDeckOverview" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 15px; padding: 15px; background: #f8f9fa; border-radius: 10px;"></div>
                        </div>
                        
                        <!-- Toggle f√ºr Karten-Tabelle -->
                        <div class="cards-table-header" onclick="toggleCityLeagueCards()">
                            <div class="cards-header-left">
                                <span class="cards-toggle collapsed" id="cityLeagueCardsToggle"></span>
                                <h3>üìã Einzelne Karten</h3>
                            </div>
                        </div>
                        
                        <div id="cityLeagueCardsContent" style="display: none; margin-bottom: 30px;">
                            <input type="text" id="cityLeagueCardSearchInput" placeholder="üîç Karte suchen..." class="card-search-input" oninput="filterCityLeagueAnalysisCards()" style="margin-bottom: 15px; width: 100%; max-width: 500px;">
                            <div class="cards-table" id="cityLeagueAnalysisTable"></div>
                        </div>
                    </div>
                    
                    <!-- Deck Builder -->
                    <div class="deck-builder">
                        <h2>üõ†Ô∏è Deck Builder (60 Karten)</h2>
                        <div class="builder-controls">
                            <button class="btn btn-primary" onclick="copyDeck('cityLeague')">üìã Copy</button>
                            <button class="btn btn-warning" onclick="generateDeckGrid('cityLeague')">üñºÔ∏è Grid</button>
                            <button class="btn btn-secondary" onclick="clearDeck('cityLeague')">üóëÔ∏è Clear</button>
                            <div class="rarity-pref-group" aria-label="Rarity Preference">
                                <button class="rarity-pref-btn" onclick="setGlobalRarityPreference('auto')">Auto</button>
                                <button class="rarity-pref-btn" onclick="setGlobalRarityPreference('max')">Max</button>
                                <button class="rarity-pref-btn" onclick="setGlobalRarityPreference('min')">Min</button>
                                <button class="rarity-pref-btn" onclick="setGlobalRarityPreference('mixed')">Mixed</button>
                            </div>
                            <button class="btn btn-success" onclick="autoComplete('cityLeague')">‚ö° Generate Deck</button>
                        </div>
                        
                        <div class="deck-summary">
                            <h3>Aktuell: <span id="cityLeagueDeckCount">0</span> / 60 Karten <span id="cityLeagueDeckCountUnique" style="font-weight: normal; font-size: 0.9em; color: #666;">(0 Unique)</span></h3>
                        </div>
                        
                        <div id="cityLeagueMyDeckVisual" style="display: none;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h3 style="margin: 0;">üé¥ Dein Deck √úbersicht</h3>
                                <button onclick="toggleDeckGridCompact()" id="deckGridToggleBtn" style="background: #6c757d; color: white; border: none; padding: 6px 12px; border-radius: 5px; cursor: pointer; font-size: 0.9em;">üì∏ Kompakt</button>
                            </div>
                            <div class="deck-grid" id="cityLeagueMyDeckGrid"></div>
                        </div>
                        
                        <!-- Karten hinzuf√ºgen Bereich -->
                        <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                            <h3 style="margin-top: 0;">‚ûï Karte hinzuf√ºgen</h3>
                            <input type="text" id="cityLeagueDeckCardSearch" placeholder="üîç Kartennamen suchen..." class="card-search-input" style="margin-bottom: 15px; width: 100%; max-width: 500px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;">
                            <div id="cityLeagueDeckSearchResults" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px;"></div>
                        </div>
                        
                        <div class="deck-list" id="cityLeagueDeckList">
                            <p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 3: Current Meta -->
            <div id="current-meta" class="tab-content">
                <div class="container">
                    <div class="header">
                        <h1>üéÆ Limitless Online Comparison</h1>
                    </div>
                    <div id="currentMetaContent" style="padding: 30px; background: #ffffff;">
                        <div style="text-align: center; padding: 40px; color: #999;">L√§dt...</div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 4: Current Analysis -->
            <div id="current-analysis" class="tab-content">
                <div class="analysis-container">
                    <div class="analysis-header">
                        <h1>üìà Current Meta Deck Analysis</h1>
                        <p>Analyze and Build Decks</p>
                    </div>
                    <div class="controls">
                        <div class="control-row">
                            <div class="control-group">
                                <label for="currentDeckSearch">üîç Deck suchen:</label>
                                <input type="text" id="currentDeckSearch" placeholder="Deck-Name eingeben...">
                            </div>
                            <div class="control-group">
                                <label for="currentDeckSelect">üéØ Deck Archetype w√§hlen:</label>
                                <select id="currentDeckSelect">
                                    <option value="">-- Bitte Deck ausw√§hlen --</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="currentFilterSelect">ü¶Ç Karten Filter:</label>
                                <select id="currentFilterSelect">
                                    <option value="all">Alle Karten</option>
                                    <option value="90">Karten in >90% der Decks (Core)</option>
                                    <option value="70">Karten in >70% der Decks</option>
                                    <option value="50">Karten in >50% der Decks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="cards-section">
                        <div class="cards-header">
                            <h2>üÉè Karten Liste</h2>
                            <span style="font-size: 1.1em; color: #333;"><span id="currentCardCount">0 Karten</span><span id="currentCardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
                        </div>
                        
                        <!-- Deck √úbersicht -->
                        <div class="deck-visual" id="currentDeckVisual" style="display: none;">
                            <h3>üé® Deck √úbersicht</h3>
                            <div class="deck-grid" id="currentDeckGrid"></div>
                        </div>
                        
                        <!-- Toggle f√ºr Einzelne Karten -->
                        <div class="cards-table-header" onclick="toggleCurrentCards()">
                            <div class="cards-header-left">
                                <span class="cards-toggle collapsed" id="currentCardsToggle"></span>
                                <h3>üìã Einzelne Karten</h3>
                            </div>
                        </div>
                        
                        <div id="currentCardsContent" style="display: none;">
                            <input type="text" id="currentCardSearchInput" placeholder="üîç Karte suchen..." class="card-search-input" oninput="filterCurrentAnalysisCards()" style="margin-bottom: 15px;">
                            <div class="cards-table" id="currentAnalysisTable"></div>
                        </div>
                    </div>
                    
                    <!-- Deck Builder -->
                    <div class="deck-builder">
                        <h2>üõ†Ô∏è Deck Builder (60 Karten)</h2>
                        <div class="builder-controls">
                            <button class="btn btn-primary" onclick="copyDeck('current')">üìã Copy</button>
                            <button class="btn btn-warning" onclick="generateDeckGrid('current')">üñºÔ∏è Grid</button>
                            <button class="btn btn-secondary" onclick="clearDeck('current')">üóëÔ∏è Clear</button>
                            <button class="btn btn-success" onclick="autoComplete('current')">‚ö° Generate Deck</button>
                        </div>
                        
                        <div class="deck-summary">
                            <h3>Aktuell: <span id="currentDeckCount">0</span> / 60 Karten <span id="currentDeckCountUnique" style="font-weight: normal; font-size: 0.9em; color: #666;">(0 Unique)</span></h3>
                        </div>
                        
                        <div id="currentMyDeckVisual" style="display: none;">
                            <h3>üé¥ Dein Deck √úbersicht</h3>
                            <div class="deck-grid" id="currentMyDeckGrid"></div>
                        </div>
                        
                        <div class="deck-list" id="currentDeckList">
                            <p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 5: Past Meta -->
            <div id="past-meta" class="tab-content">
                <div class="analysis-container">
                    <div class="analysis-header">
                        <h1>üèÜ Past Tournament Meta</h1>
                        <p>Analyze and Build Decks</p>
                    </div>
                    <div class="controls">
                        <div class="control-row">
                            <div class="control-group">
                                <label for="pastDeckSearch">üîç Deck suchen:</label>
                                <input type="text" id="pastDeckSearch" placeholder="Deck-Name eingeben...">
                            </div>
                            <div class="control-group">
                                <label for="pastDeckSelect">üéØ Deck Archetype w√§hlen:</label>
                                <select id="pastDeckSelect">
                                    <option value="">-- Bitte Deck ausw√§hlen --</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="pastFilterSelect">ü¶Ç Karten Filter:</label>
                                <select id="pastFilterSelect">
                                    <option value="all">Alle Karten</option>
                                    <option value="90">Karten in >90% der Decks (Core)</option>
                                    <option value="70">Karten in >70% der Decks</option>
                                    <option value="50">Karten in >50% der Decks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="cards-section">
                        <div class="cards-header">
                            <h2>üÉè Karten Liste</h2>
                            <span style="font-size: 1.1em; color: #333;"><span id="pastCardCount">0 Karten</span><span id="pastCardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
                        </div>
                        
                        <!-- Deck √úbersicht -->
                        <div class="deck-visual" id="pastDeckVisual" style="display: none;">
                            <h3>üé® Deck √úbersicht</h3>
                            <div class="deck-grid" id="pastDeckGrid"></div>
                        </div>
                        
                        <!-- Toggle f√ºr Einzelne Karten -->
                        <div class="cards-table-header" onclick="togglePastCards()">
                            <div class="cards-header-left">
                                <span class="cards-toggle collapsed" id="pastCardsToggle"></span>
                                <h3>üìã Einzelne Karten</h3>
                            </div>
                        </div>
                        
                        <div id="pastCardsContent" style="display: none;">
                            <input type="text" id="pastCardSearchInput" placeholder="üîç Karte suchen..." class="card-search-input" oninput="filterPastMetaCards()" style="margin-bottom: 15px;">
                            <div class="cards-table" id="pastMetaTable"></div>
                        </div>
                    </div>
                    
                    <!-- Deck Builder -->
                    <div class="deck-builder">
                        <h2>üõ†Ô∏è Deck Builder (60 Karten)</h2>
                        <div class="builder-controls">
                            <button class="btn btn-primary" onclick="copyDeck('past')">üìã Copy</button>
                            <button class="btn btn-warning" onclick="generateDeckGrid('past')">üñºÔ∏è Grid</button>
                            <button class="btn btn-secondary" onclick="clearDeck('past')">üóëÔ∏è Clear</button>
                            <button class="btn btn-success" onclick="autoComplete('past')">‚ö° Generate Deck</button>
                        </div>
                        
                        <div class="deck-summary">
                            <h3>Aktuell: <span id="pastDeckCount">0</span> / 60 Karten <span id="pastDeckCountUnique" style="font-weight: normal; font-size: 0.9em; color: #666;">(0 Unique)</span></h3>
                        </div>
                        
                        <div id="pastMyDeckVisual" style="display: none;">
                            <h3>üé¥ Dein Deck √úbersicht</h3>
                            <div class="deck-grid" id="pastMyDeckGrid"></div>
                        </div>
                        
                        <div class="deck-list" id="pastDeckList">
                            <p style="text-align: center; color: #666;">F√ºge Karten von oben hinzu...</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 6: Cards -->
            <div id="cards" class="tab-content">
                <h1>üß∞ Card Database</h1>
                <div class="search-box">
                    <input type="text" id="cardSearch" placeholder="Suche nach Kartennamen..." onkeyup="filterCards()">
                </div>
                <div id="cardsContent" class="loading">L√§dt Daten...</div>
            </div>
        </div>
        
        <div class="footer">
            <p>üìÖ Letzte Aktualisierung: <span id="last-update">Loading...</span></p>
        </div>
    </div>
    
    <script>
        const BASE_PATH = './data/';
        
        // Tab switching
        function switchTab(tabName) {
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
                
                // Load data for the tab
                switch(tabName) {
                    case 'city-league':
                        if (!window.cityLeagueLoaded) loadCityLeagueData();
                        break;
                    case 'city-league-analysis':
                        if (!window.cityLeagueAnalysisLoaded) loadCityLeagueAnalysis();
                        break;
                    case 'current-meta':
                        if (!window.currentMetaLoaded) loadCurrentMeta();
                        break;
                    case 'current-analysis':
                        if (!window.currentAnalysisLoaded) loadCurrentAnalysis();
                        break;
                    case 'past-meta':
                        if (!window.pastMetaLoaded) loadPastMeta();
                        break;
                    case 'cards':
                        if (!window.cardsLoaded) loadCards();
                        break;
                }
            }
            
            // Set active button
            const activeBtn = Array.from(buttons).find(btn => 
                btn.getAttribute('onclick')?.includes(tabName)
            );
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        // CSV loading and parsing
        async function loadCSV(filename) {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`${BASE_PATH}${filename}?t=${timestamp}`);
                if (response.ok) {
                    const text = await response.text();
                    return parseCSV(text);
                }
                return null;
            } catch (e) {
                console.error(`Error loading ${filename}:`, e);
                return null;
            }
        }
        
        function parseCSV(text) {
            return parseCSVWithDelimiter(text, ';');
        }

        function parseCSVWithDelimiter(text, delimiter) {
            // Remove BOM if present
            if (text.charCodeAt(0) === 0xFEFF) {
                text = text.slice(1);
            }
            
            const lines = text.trim().split('\n').filter(line => line.trim());
            if (lines.length < 2) return [];
            
            const headers = lines[0].split(delimiter).map(h => h.trim());
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const values = lines[i].split(delimiter);
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = (values[index] || '').trim();
                });
                if (Object.values(row).some(v => v)) {
                    data.push(row);
                }
            }
            
            return data;
        }
        
        // Load all cards database for deck builder
        let allCardsDatabase = [];
        let cardsByNameMap = {};
        let englishSetCodes = null;
        let rarityPreferences = {};
        let globalRarityPreference = 'auto';
        async function loadAllCardsDatabase() {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`./data/all_cards_database.json?t=${timestamp}`);
                if (response.ok) {
                    const jsonData = await response.json();
                    // Extract cards array from JSON structure
                    allCardsDatabase = jsonData.cards || jsonData;
                    window.allCardsDatabase = allCardsDatabase;
                    cardsByNameMap = buildCardsByNameMap(allCardsDatabase);
                    window.cardsByNameMap = cardsByNameMap;
                    console.log(`‚úÖ Loaded ${allCardsDatabase.length} cards from all_cards_database.json`);
                    console.log(`üìä Karten mit mehreren Versionen:`, Object.keys(cardsByNameMap).filter(k => cardsByNameMap[k].length > 1).length);
                    
                    // Initialisiere Suche wenn sie existiert
                    const searchInput = document.getElementById('cityLeagueDeckCardSearch');
                    if (searchInput && searchInput.value.trim()) {
                        searchDeckCards();
                    }
                } else {
                    console.error('‚ùå Failed to load all_cards_database.json');
                }
            } catch (error) {
                console.error('Error loading all cards database:', error);
            }
        }

        async function loadSetMapping() {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`./pokemon_sets_mapping.csv?t=${timestamp}`);
                if (!response.ok) return;
                const text = await response.text();
                const rows = parseCSVWithDelimiter(text, ',');
                englishSetCodes = new Set(rows.map(row => row.set_code).filter(Boolean));
                window.englishSetCodes = englishSetCodes;
            } catch (error) {
                console.error('Error loading pokemon_sets_mapping.csv:', error);
            }
        }

        function buildCardsByNameMap(cards) {
            const map = {};
            cards.forEach(card => {
                if (!card.name) return;
                if (!map[card.name]) {
                    map[card.name] = [];
                }
                map[card.name].push(card);
            });
            return map;
        }

        function getCardVersionsByName(cardName) {
            return (cardsByNameMap[cardName] || []).slice();
        }

        function getEnglishCardVersions(cardName) {
            const versions = getCardVersionsByName(cardName);
            if (!englishSetCodes || englishSetCodes.size === 0) {
                return versions;
            }
            return versions.filter(version => englishSetCodes.has(version.set));
        }

        function loadRarityPreferences() {
            try {
                const raw = localStorage.getItem('rarityPreferences');
                rarityPreferences = raw ? JSON.parse(raw) : {};
            } catch (error) {
                rarityPreferences = {};
            }
            window.rarityPreferences = rarityPreferences;
            loadGlobalRarityPreference();
        }

        function saveRarityPreferences() {
            localStorage.setItem('rarityPreferences', JSON.stringify(rarityPreferences));
        }

        function loadGlobalRarityPreference() {
            globalRarityPreference = 'auto';
            updateGlobalRarityButtons();
        }

        function setGlobalRarityPreference(mode) {
            globalRarityPreference = mode || 'auto';
            updateGlobalRarityButtons();
            updateGenerateDeckButtonLabel();
        }

        function getGlobalRarityPreference() {
            return globalRarityPreference || 'auto';
        }

        function updateGlobalRarityButtons() {
            const buttons = document.querySelectorAll('.rarity-pref-btn');
            buttons.forEach(button => {
                const mode = button.textContent.toLowerCase();
                button.classList.toggle('active', mode === globalRarityPreference);
            });
        }

        function setRarityPreference(cardName, pref) {
            if (!cardName) return;
            rarityPreferences[cardName] = pref;
            saveRarityPreferences();
            updateGenerateDeckButtonLabel();
        }

        function getRarityPreference(cardName) {
            return rarityPreferences[cardName] || null;
        }

        function clearRarityPreference(cardName) {
            if (!cardName || !rarityPreferences[cardName]) return;
            delete rarityPreferences[cardName];
            saveRarityPreferences();
            updateGenerateDeckButtonLabel();
        }

        function getRarityModeLabel() {
            const globalPref = getGlobalRarityPreference();
            if (!globalPref || globalPref === 'auto') {
                return null;
            }
            if (globalPref && globalPref !== 'auto') {
                if (globalPref === 'max') return 'Max Rarity';
                if (globalPref === 'min') return 'Min Rarity';
                if (globalPref === 'mixed') return 'Mixed Rarity';
            }
            return null;
        }

        function updateGenerateDeckButtonLabel() {
            const label = getRarityModeLabel();
            const buttons = document.querySelectorAll("button[onclick^='autoComplete']");
            buttons.forEach(button => {
                const base = '‚ö° Generate Deck';
                button.textContent = label ? `${base} (${label})` : base;
            });
        }

        function getPreferredVersionForCard(cardName) {
            const pref = getRarityPreference(cardName);
            const globalPref = getGlobalRarityPreference();
            const versions = getEnglishCardVersions(cardName);
            if (versions.length === 0) return null;

            if (globalPref && (globalPref === 'max' || globalPref === 'min')) {
                const sorted = versions.slice().sort((a, b) => {
                    const priorityA = getRarityPriority(a.rarity);
                    const priorityB = getRarityPriority(b.rarity);
                    return priorityA - priorityB;
                });
                return globalPref === 'max' ? sorted[sorted.length - 1] : sorted[0];
            }

            if (!pref || globalPref === 'auto') {
                return null;
            }

            if (pref.mode === 'specific' && pref.set && pref.number) {
                return versions.find(v => v.set === pref.set && v.number === pref.number) || null;
            }

            if (pref.mode === 'max' || pref.mode === 'min') {
                const sorted = versions.slice().sort((a, b) => {
                    const priorityA = getRarityPriority(a.rarity);
                    const priorityB = getRarityPriority(b.rarity);
                    return priorityA - priorityB;
                });
                return pref.mode === 'max' ? sorted[sorted.length - 1] : sorted[0];
            }

            return null;
        }

        function getRarityPriority(rarity) {
            if (!rarity) return 0;
            const r = rarity.toLowerCase();

            // Standard rarities
            if (r.includes('common')) return 1;
            if (r.includes('uncommon')) return 2;
            if (r === 'rare' || r.includes('rare') && !r.includes('holo')) return 3;
            if (r.includes('holo rare')) return 4;

            // Gameplay rarities
            if (r.includes('double rare')) return 5;
            if (r.includes('triple rare')) return 6;
            if (r.includes('radiant rare')) return 7;
            if (r.includes('amazing rare')) return 8;

            // Art rarities
            if (r.includes('character holo rare') || r.includes('art rare') || r.includes('illustration rare')) return 9;
            if (r.includes('character super rare')) return 10;
            if (r.includes('special art rare') || r.includes('special illustration rare')) return 11;

            // High-end & secret rarities
            if (r.includes('ultra rare')) return 12;
            if (r.includes('rainbow rare')) return 13;
            if (r.includes('secret rare')) return 14;

            return 0;
        }
        
        // Helper function to convert rarity to abbreviation for image URLs
        function getRarityAbbreviation(rarity) {
            if (!rarity) return 'C'; // Default to Common
            
            const rarityMap = {
                'Common': 'C',
                'Uncommon': 'U',
                'Rare': 'R',
                'Holo Rare': 'R',
                'Double Rare': 'R',
                'Ultra Rare': 'UR',
                'Special Art Rare': 'SAR',
                'Rainbow Rare': 'RR',
                'Secret Rare': 'SR',
                'Shiny Rare': 'SHR',
                'Art Rare': 'AR',
                'Promo': 'P'
            };
            
            return rarityMap[rarity] || 'R'; // Default to Rare if unknown
        }
        
        // Render generic table
        function renderTable(data, containerId, title) {
            const content = document.getElementById(containerId);
            if (!data || data.length === 0) return;
            
            const headers = Object.keys(data[0]);
            let html = `<h2>${title}</h2><table><thead><tr>`;
            
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            data.forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    html += `<td>${row[header]}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            content.innerHTML = html;
        }
        
        // Load City League data from CSV (with cache-busting)
        let cityLeagueData = [];
        async function loadCityLeagueData() {
            const content = document.getElementById('cityLeagueContent');
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`${BASE_PATH}city_league_archetypes_comparison.csv?t=${timestamp}`);
                if (response.ok) {
                    const text = await response.text();
                    cityLeagueData = parseCSV(text);
                    
                    // Load tournament count and date range from main archetype CSV
                    let tournamentCount = 0;
                    let dateRange = '';
                    try {
                        const tournamentsResponse = await fetch(`${BASE_PATH}city_league_archetypes.csv?t=${timestamp}`);
                        if (tournamentsResponse.ok) {
                            const tournamentsText = await tournamentsResponse.text();
                            const tournamentsData = parseCSV(tournamentsText);
                            const uniqueTournaments = new Set(tournamentsData.map(d => d.tournament_id));
                            tournamentCount = uniqueTournaments.size;
                            
                            // Extract date range with proper date parsing
                            if (tournamentsData.length > 0) {
                                const dates = tournamentsData.map(d => d.date).filter(d => d);
                                if (dates.length > 0) {
                                    const parsedDates = dates.map(d => {
                                        const parts = d.split(' ');
                                        if (parts.length >= 3) {
                                            const day = parts[0];
                                            const month = parts[1];
                                            const year = parts[2];
                                            const monthMap = {'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'};
                                            const monthNum = monthMap[month] || '01';
                                            const fullYear = '20' + year;
                                            return {original: d, comparable: fullYear + monthNum + day.padStart(2, '0')};
                                        }
                                        return {original: d, comparable: '99999999'};
                                    });
                                    
                                    const minDateObj = parsedDates.reduce((a, b) => a.comparable < b.comparable ? a : b);
                                    const maxDateObj = parsedDates.reduce((a, b) => a.comparable > b.comparable ? a : b);
                                    dateRange = `${minDateObj.original} - ${maxDateObj.original}`;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Could not load tournament data:', e);
                    }
                    
                    renderCityLeagueTable(tournamentCount, dateRange);
                    window.cityLeagueLoaded = true;
                } else {
                    content.innerHTML = '<div class="error">Fehler beim Laden der City League Meta Daten</div>';
                }
            } catch (error) {
                console.error('Error loading City League data:', error);
                content.innerHTML = '<div class="error">Fehler beim Laden der City League Meta Daten</div>';
            }
        }
        
        // Render City League table with full structure matching original HTML
        function renderCityLeagueTable(tournamentCount = 0, dateRange = '') {
            const content = document.getElementById('cityLeagueContent');
            if (!content || !cityLeagueData || cityLeagueData.length === 0) return;
            
            // Separate data by status and trend
            const newArchetypes = cityLeagueData.filter(d => d.status === 'NEU');
            const disappeared = cityLeagueData.filter(d => d.status === 'VERSCHWUNDEN');
            const increased = cityLeagueData.filter(d => d.status !== 'NEU' && parseInt(d.count_change || 0) > 0)
                .sort((a, b) => parseInt(b.count_change) - parseInt(a.count_change));
            const decreased = cityLeagueData.filter(d => parseInt(d.count_change || 0) < 0)
                .sort((a, b) => parseInt(a.count_change) - parseInt(b.count_change));
            
            // Get max count for threshold filtering
            const maxCountForThreshold = Math.max(...cityLeagueData.map(d => parseInt(d.new_count || 0)));
            const countThreshold = maxCountForThreshold * 0.1;
            
            // Performance improvers/decliners
            const improvers = cityLeagueData
                .filter(d => parseFloat((d.avg_placement_change || '0').replace(',', '.')) < 0 && parseInt(d.new_count || 0) >= countThreshold)
                .sort((a, b) => parseFloat((a.avg_placement_change || '0').replace(',', '.')) - parseFloat((b.avg_placement_change || '0').replace(',', '.')))
                .slice(0, 10);
            
            const decliners = cityLeagueData
                .filter(d => parseFloat((d.avg_placement_change || '0').replace(',', '.')) > 0 && parseInt(d.new_count || 0) >= countThreshold)
                .sort((a, b) => parseFloat((b.avg_placement_change || '0').replace(',', '.')) - parseFloat((a.avg_placement_change || '0').replace(',', '.')))
                .slice(0, 10);
            
            const sorted = [...cityLeagueData].sort((a, b) => parseInt(b.new_count || 0) - parseInt(a.new_count || 0));
            const totalArchetypes = cityLeagueData.length;
            
            // Generate timestamp
            const now = new Date();
            const generatedDate = now.toLocaleString('de-DE', { 
                year: 'numeric', month: '2-digit', day: '2-digit', 
                hour: '2-digit', minute: '2-digit', second: '2-digit' 
            });
            
            // Get top 3 by count and placement
            const topByCount = [...cityLeagueData]
                .sort((a, b) => parseInt(b.new_count || 0) - parseInt(a.new_count || 0))
                .slice(0, 3);
            
            const maxCount = parseInt(topByCount[0]?.new_count || 0);
            const minCountThreshold = maxCount * 0.1;
            const topByPlacement = [...cityLeagueData]
                .filter(d => parseInt(d.new_count || 0) >= minCountThreshold)
                .sort((a, b) => parseFloat((a.new_avg_placement || '0').replace(',', '.')) - parseFloat((b.new_avg_placement || '0').replace(',', '.')))
                .slice(0, 3);
            
            const top10New = [...cityLeagueData]
                .sort((a, b) => parseInt(b.new_count || 0) - parseInt(a.new_count || 0))
                .slice(0, 10)
                .map(d => d.archetype);
            const top10Old = [...cityLeagueData]
                .sort((a, b) => parseInt(b.old_count || 0) - parseInt(a.old_count || 0))
                .slice(0, 10)
                .map(d => d.archetype);
            
            const entries = top10New.filter(arch => !top10Old.includes(arch));
            const exits = top10Old.filter(arch => !top10New.includes(arch));
            
            let html = `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 30px; text-align: center;">
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">üìÖ Generated: ${generatedDate}</span>
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">üìä Total Archetypes Tracked: ${totalArchetypes}</span>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">üìä Archetype Overview</h3>
                        <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${totalArchetypes}</div>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 15px; text-align: left;">
                            <strong>Top 3 by Count:</strong><br>
                            ${topByCount.map(d => `${d.archetype}: ${d.new_count}x`).join('<br>')}
                            <br><br>
                            <strong>Top 3 by Avg Placement:</strong><br>
                            ${topByPlacement.map(d => `${d.archetype}: ${d.new_avg_placement}`).join('<br>')}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">üîÑ Top 10 Changes</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; text-align: left;">
                            ${entries.length > 0 ? `<strong style="color: #7fff7f;">‚¨Ü Entries:</strong><br>${entries.map(arch => `${arch}`).join('<br>')}<br><br>` : ''}
                            ${exits.length > 0 ? `<strong style="color: #ff6b6b;">‚¨á Exits:</strong><br>${exits.map(arch => `${arch}`).join('<br>')}<br>` : ''}
                            ${entries.length === 0 && exits.length === 0 ? 'No changes in top 10' : ''}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">üìç Datenquelle</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px;">
                            <strong>Zeitraum:</strong><br>${dateRange || 'N/A'}<br><br>
                            <strong>Turniere:</strong><br>${tournamentCount || 0}
                        </div>
                    </div>
                </div>`;
            
            // Add conditional tables
            if (decreased.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìâ Popularity Decreases</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Change</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Avg Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decreased.slice(0, 10).forEach(d => {
                    const change = parseInt(d.count_change || 0);
                    const placement_change = parseFloat((d.avg_placement_change || '0').replace(',', '.'));
                    const placement_color = placement_change < 0 ? '#27ae60' : '#e74c3c';
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center; color: #e74c3c; font-weight: bold;">${change}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: ${placement_color}; font-weight: bold;">(${placement_change > 0 ? '+' : ''}${placement_change.toFixed(2)})</span></td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }
            
            if (improvers.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">‚≠ê Performance Improvers (Better Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Improvement</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Best Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                improvers.slice(0, 10).forEach(d => {
                    const improvement = Math.abs(parseFloat((d.avg_placement_change || '0').replace(',', '.')));
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_avg_placement}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                            <td style="padding: 12px; text-align: center; color: #27ae60; font-weight: bold;">-${improvement.toFixed(2)}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_best}</td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }
            
            if (decliners.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìâ Performance Decliners (Worse Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Avg</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Decline</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Best Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decliners.slice(0, 10).forEach(d => {
                    const decline = parseFloat((d.avg_placement_change || '0').replace(',', '.'));
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_avg_placement}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                            <td style="padding: 12px; text-align: center; color: #e74c3c; font-weight: bold;">+${decline.toFixed(2)}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_best}</td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }
            
            // Full comparison table
            html += `
                <div style="margin-bottom: 40px;">
                    <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">üìã Full Comparison Table (Top 30)</h2>
                    <div style="margin-bottom: 15px;">
                        <input type="text" id="cityLeagueSearchFilter" placeholder="Suche z.B.: draga, luca" 
                            style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #3498db; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);"
                            oninput="filterCityLeagueTable()">
                        <div id="cityLeagueSearchResults" style="margin-top: 8px; font-size: 14px; color: #7f8c8d;"></div>
                    </div>
                    <div id="cityLeagueFullTable"></div>
                </div>`;
            
            content.innerHTML = html;
            
            // Store sorted data globally for filtering
            window.cityLeagueSortedData = sorted;
            
            // Initial render
            renderFullComparisonTable(sorted.slice(0, 30));
        }
        
        // Render Full Comparison Table
        function renderFullComparisonTable(data) {
            const container = document.getElementById('cityLeagueFullTable');
            if (!container) return;
            
            const isMobile = window.innerWidth <= 768;
            let tableHTML = '';
            
            if (isMobile) {
                // Mobile: Kompakte Version ohne Trend, Count Old, Best Placement
                tableHTML = `
                <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 0.85em;">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 8px 4px; text-align: left; font-weight: 600;">Deck</th>
                            <th style="padding: 8px 4px; text-align: center; font-weight: 600;">Count</th>
                            <th style="padding: 8px 4px; text-align: center; font-weight: 600;">Avg</th>
                        </tr>
                    </thead>
                    <tbody>`;
                
                data.forEach(d => {
                    const changeValue = parseInt(d.count_change || 0);
                    const changeColor = changeValue > 0 ? '#27ae60' : changeValue < 0 ? '#e74c3c' : '#95a5a6';
                    const placementChange = parseFloat((d.avg_placement_change || '0').replace(',', '.'));
                    const placementColor = placementChange < 0 ? '#27ae60' : placementChange > 0 ? '#e74c3c' : '#95a5a6';
                    
                    tableHTML += `
                        <tr style="border-bottom: 1px solid #ecf0f1;">
                            <td style="padding: 8px 4px; font-weight: bold; font-size: 0.9em;">${d.archetype}</td>
                            <td style="padding: 8px 4px; text-align: center;">${d.new_count} <span style="color: ${changeColor}; font-weight: bold; font-size: 0.85em;">(${changeValue > 0 ? '+' : ''}${changeValue})</span></td>
                            <td style="padding: 8px 4px; text-align: center;">${d.new_avg_placement} <span style="color: ${placementColor}; font-weight: bold; font-size: 0.85em;">(${placementChange > 0 ? '+' : ''}${placementChange.toFixed(2)})</span></td>
                        </tr>`;
                });
                
                tableHTML += `</tbody></table>`;
            } else {
                // Desktop: Volle Version
                tableHTML = `
                <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Trend</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Count Old</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Count New</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Count Œî</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Avg Placement</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
                data.forEach(d => {
                    const trendColor = d.trend === 'VERBESSERT' ? '#27ae60' : d.trend === 'VERSCHLECHTERT' ? '#e67e22' : '#95a5a6';
                    const trendArrow = d.trend === 'VERBESSERT' ? '‚Üë' : d.trend === 'VERSCHLECHTERT' ? '‚Üì' : '‚Üí';
                    const changeValue = parseInt(d.count_change || 0);
                    const changeColor = changeValue > 0 ? '#27ae60' : '#e74c3c';
                    
                    tableHTML += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center; font-size: 1.2em; color: ${trendColor}; font-weight: bold;">${trendArrow}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center; color: ${changeColor}; font-weight: bold;">(${changeValue > 0 ? '+' : ''}${changeValue})</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement}</td>
                        </tr>`;
                });
                
                tableHTML += `</tbody></table>`;
            }
            
            container.innerHTML = tableHTML;
        }
        
        // Filter City League Table
        function filterCityLeagueTable() {
            const searchInput = document.getElementById('cityLeagueSearchFilter');
            const resultsDiv = document.getElementById('cityLeagueSearchResults');
            if (!searchInput || !window.cityLeagueSortedData) return;
            
            const searchText = searchInput.value.trim();
            
            // If empty, show top 30
            if (!searchText) {
                renderFullComparisonTable(window.cityLeagueSortedData.slice(0, 30));
                resultsDiv.textContent = '';
                return;
            }
            
            // Split by comma and trim
            const searchTerms = searchText.split(',').map(term => term.trim().toLowerCase()).filter(term => term);
            
            // Filter: show decks that contain ANY of the search terms
            const filtered = window.cityLeagueSortedData.filter(d => {
                const archetype = d.archetype.toLowerCase();
                return searchTerms.some(term => archetype.includes(term));
            });
            
            // Render filtered results
            renderFullComparisonTable(filtered);
            
            // Update results info
            if (filtered.length === 0) {
                resultsDiv.textContent = 'Keine Ergebnisse gefunden';
                resultsDiv.style.color = '#e74c3c';
            } else {
                resultsDiv.textContent = `${filtered.length} Ergebnis${filtered.length !== 1 ? 'se' : ''} gefunden`;
                resultsDiv.style.color = '#27ae60';
            }
        }
        
        // Load City League Analysis
        async function loadCityLeagueAnalysis() {
            console.log('Loading City League Analysis...');
            const data = await loadCSV('city_league_analysis.csv');
            console.log('Loaded data:', data ? `${data.length} rows` : 'null');
            
            // Also load archetypes data for placement statistics
            const archetypesData = await loadCSV('city_league_archetypes.csv');
            console.log('Loaded archetypes data:', archetypesData ? `${archetypesData.length} rows` : 'null');
            
            // Load comparison data for current deck counts (new_count)
            const comparisonData = await loadCSV('city_league_archetypes_comparison.csv');
            console.log('Loaded comparison data:', comparisonData ? `${comparisonData.length} rows` : 'null');

            if (data && data.length > 0) {
                console.log('Processing archetypes...');
                window.cityLeagueAnalysisData = data;
                window.cityLeagueArchetypesData = archetypesData;
                window.cityLeagueComparisonData = comparisonData;
                populateCityLeagueDeckSelect(data, comparisonData);
                window.cityLeagueAnalysisLoaded = true;
            } else {
                const tableContainer = document.getElementById('cityLeagueAnalysisTable');
                if (tableContainer) {
                    const errorMsg = data === null ? 'Fehler beim Laden der City League Analysis Daten' : 'Keine Daten gefunden';
                    console.error(errorMsg);
                    tableContainer.innerHTML = `<div class="error">${errorMsg}</div>`;
                }
            }
        }
        
        function populateCityLeagueDeckSelect(data, comparisonData) {
            // Create a map of archetype names to their current deck counts from comparison data
            const comparisonMap = new Map();
            if (comparisonData && comparisonData.length > 0) {
                comparisonData.forEach(row => {
                    if (row.archetype && row.new_count) {
                        comparisonMap.set(row.archetype.toLowerCase(), parseInt(row.new_count || 0));
                    }
                });
                console.log('Loaded comparison counts for', comparisonMap.size, 'archetypes');
            }
            
            // Extract unique archetypes with their deck counts
            const archetypeMap = new Map();
            data.forEach(row => {
                if (row.archetype && !archetypeMap.has(row.archetype)) {
                    // Use new_count from comparison data if available, otherwise fall back to total_decks_in_archetype
                    const deckCount = comparisonMap.get(row.archetype.toLowerCase()) || parseInt(row.total_decks_in_archetype || 0);
                    archetypeMap.set(row.archetype, {
                        name: row.archetype,
                        deckCount: deckCount
                    });
                }
            });
            
            const archetypeList = Array.from(archetypeMap.values());
            console.log('Found archetypes:', archetypeList.length);
            
            // Sort by deck count descending to get top meta decks
            const sortedByMeta = [...archetypeList].sort((a, b) => b.deckCount - a.deckCount);
            const top10 = sortedByMeta.slice(0, 10);
            const rest = sortedByMeta.slice(10).sort((a, b) => a.name.localeCompare(b.name));
            
            console.log('Top 10 meta decks:', top10.map(d => `${d.name} (${d.deckCount})`));
            
            const select = document.getElementById('cityLeagueDeckSelect');
            if (!select) return;
            
            // Clear and repopulate
            select.innerHTML = '<option value="">-- Bitte Deck ausw√§hlen --</option>';
            
            // Add top 10 meta decks
            if (top10.length > 0) {
                const topGroup = document.createElement('optgroup');
                topGroup.label = 'üî• Top 10 Meta Decks';
                top10.forEach(archetype => {
                    const option = document.createElement('option');
                    option.value = archetype.name;
                    option.textContent = `${archetype.name} (${archetype.deckCount} Decks)`;
                    topGroup.appendChild(option);
                });
                select.appendChild(topGroup);
            }
            
            // Add remaining decks alphabetically
            if (rest.length > 0) {
                const restGroup = document.createElement('optgroup');
                restGroup.label = 'üìã Weitere Decks (A-Z)';
                rest.forEach(archetype => {
                    const option = document.createElement('option');
                    option.value = archetype.name;
                    option.textContent = `${archetype.name} (${archetype.deckCount} Decks)`;
                    restGroup.appendChild(option);
                });
                select.appendChild(restGroup);
            }
            
            // Add change event listener
            select.onchange = function() {
                if (this.value) {
                    loadCityLeagueDeckData(this.value);
                } else {
                    clearCityLeagueDeckView();
                }
            };
            
            // Enable search functionality
            const searchInput = document.getElementById('cityLeagueDeckSearch');
            if (searchInput) {
                searchInput.oninput = function() {
                    const searchTerm = this.value.toLowerCase();
                    // Search through all options in all optgroups
                    Array.from(select.querySelectorAll('option')).forEach(option => {
                        if (option.value) {
                            option.style.display = option.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
                        }
                    });
                    // Hide optgroups if all options are hidden
                    Array.from(select.querySelectorAll('optgroup')).forEach(group => {
                        const hasVisibleOptions = Array.from(group.querySelectorAll('option')).some(opt => opt.style.display !== 'none');
                        group.style.display = hasVisibleOptions ? '' : 'none';
                    });
                };
            }
        }
        
        // Date filter functions for City League
        function resetCityLeagueDateFilter() {
            document.getElementById('cityLeagueDateFrom').value = '';
            document.getElementById('cityLeagueDateTo').value = '';
            window.cityLeagueDateFilterActive = false;
            updateCityLeagueDateFilterStatus();
            // Reload current deck if one is selected
            const selectedArchetype = document.getElementById('cityLeagueDeckSelect')?.value;
            if (selectedArchetype) {
                loadCityLeagueDeckData(selectedArchetype);
            }
        }
        
        function applyCityLeagueDateFilter() {
            const dateFrom = document.getElementById('cityLeagueDateFrom').value;
            const dateTo = document.getElementById('cityLeagueDateTo').value;
            
            // Set filter active if at least one date is set
            if (dateFrom || dateTo) {
                window.cityLeagueDateFilterActive = true;
                window.cityLeagueDateFrom = dateFrom || '1900-01-01';
                window.cityLeagueDateTo = dateTo || '2099-12-31';
            } else {
                // If both dates are cleared, disable filter
                window.cityLeagueDateFilterActive = false;
            }
            
            updateCityLeagueDateFilterStatus();
            
            // Reload current deck if one is selected
            const selectedArchetype = document.getElementById('cityLeagueDeckSelect')?.value;
            if (selectedArchetype) {
                loadCityLeagueDeckData(selectedArchetype);
            }
        }
        
        function updateCityLeagueDateFilterStatus() {
            const statusEl = document.getElementById('cityLeagueDateFilterStatus');
            if (!statusEl) return;
            
            const dateFrom = document.getElementById('cityLeagueDateFrom').value;
            const dateTo = document.getElementById('cityLeagueDateTo').value;
            
            if (dateFrom && dateTo) {
                statusEl.textContent = `Gefiltert: ${formatDate(dateFrom)} bis ${formatDate(dateTo)}`;
                statusEl.style.color = 'rgba(255,255,255,1)';
            } else if (dateFrom) {
                statusEl.textContent = `Gefiltert: Ab ${formatDate(dateFrom)}`;
                statusEl.style.color = 'rgba(255,255,255,1)';
            } else if (dateTo) {
                statusEl.textContent = `Gefiltert: Bis ${formatDate(dateTo)}`;
                statusEl.style.color = 'rgba(255,255,255,1)';
            } else {
                statusEl.textContent = 'Alle Turniere werden angezeigt';
                statusEl.style.color = 'rgba(255,255,255,0.8)';
            }
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr + 'T00:00:00');
            const day = date.getDate();
            const month = date.getMonth() + 1;
            const year = date.getFullYear();
            return `${day.toString().padStart(2, '0')}.${month.toString().padStart(2, '0')}.${year}`;
        }
        
        // Parse Japanese date format (e.g., "01 Feb 26") to YYYY-MM-DD
        function parseJapaneseDate(dateStr) {
            if (!dateStr || dateStr.trim() === '') return '';
            
            const parts = dateStr.trim().split(/[.\s]+/);
            if (parts.length < 3) return '';
            
            const day = parts[0].padStart(2, '0');
            const monthStr = parts[1];
            const year = parts[2].length === 2 ? '20' + parts[2] : parts[2];
            
            const monthMap = {
                'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06',
                'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',
                'Januar': '01', 'Februar': '02', 'M√§rz': '03', 'April': '04', 'Mai': '05', 'Juni': '06',
                'Juli': '07', 'August': '08', 'September': '09', 'Oktober': '10', 'November': '11', 'Dezember': '12'
            };
            
            const month = monthMap[monthStr] || '01';
            return `${year}-${month}-${day}`;
        }
        
        // Recalculate card statistics based on filtered tournament data
        function recalculateCardStatsForFilteredData(filteredCards, archetype) {
            // Count unique tournaments/decks in filtered data
            const uniqueTournamentIds = new Set();
            filteredCards.forEach(card => {
                if (card.tournament_id) {
                    uniqueTournamentIds.add(card.tournament_id);
                }
            });
            const totalDecks = uniqueTournamentIds.size;
            
            // Group cards by card_name and recalculate stats
            const cardStatsMap = new Map();
            
            filteredCards.forEach(row => {
                const cardName = row.card_name;
                if (!cardStatsMap.has(cardName)) {
                    cardStatsMap.set(cardName, {
                        tournaments: new Set(),
                        counts: [],
                        sampleRow: row
                    });
                }
                
                const stats = cardStatsMap.get(cardName);
                if (row.tournament_id) {
                    stats.tournaments.add(row.tournament_id);
                }
                const count = parseInt(row.count || 0);
                if (count > 0) {
                    stats.counts.push(count);
                }
            });
            
            // Create new cards array with recalculated stats
            const recalculatedCards = [];
            cardStatsMap.forEach((stats, cardName) => {
                const row = { ...stats.sampleRow };
                
                // Recalculate deck_count (how many decks contain this card)
                const deck_count = stats.tournaments.size;
                
                // Recalculate max_count (most common count)
                let max_count = 0;
                if (stats.counts.length > 0) {
                    const countFrequency = {};
                    stats.counts.forEach(c => {
                        countFrequency[c] = (countFrequency[c] || 0) + 1;
                    });
                    max_count = parseInt(Object.keys(countFrequency).reduce((a, b) => 
                        countFrequency[a] > countFrequency[b] ? a : b
                    ));
                }
                
                // Recalculate percentage
                const percentage = totalDecks > 0 ? (deck_count / totalDecks * 100) : 0;
                
                // Recalculate average count
                const avg_count = stats.counts.length > 0 
                    ? (stats.counts.reduce((a, b) => a + b, 0) / stats.counts.length) 
                    : 0;
                
                // Update row with recalculated values
                row.deck_count_in_selected = deck_count;
                row.max_count = max_count;
                row.percentage_in_archetype = percentage.toFixed(1);
                row.avg_count = avg_count.toFixed(2);
                row.total_decks_in_archetype = totalDecks;
                
                recalculatedCards.push(row);
            });
            
            console.log(`Recalculated stats for ${recalculatedCards.length} unique cards based on ${totalDecks} filtered tournaments`);
            return recalculatedCards;
        }
        
        // Aggregate card statistics from filtered tournament data
        function aggregateCardStatsByDate(filteredCards) {
            // Group by card_name
            const cardMap = new Map();
            
            // Calculate total decks across all tournaments
            // For each unique tournament date, get the total_decks_in_archetype value
            const tournamentDecksMap = new Map();
            filteredCards.forEach(row => {
                if (row.tournament_date) {
                    const date = row.tournament_date;
                    const decksInTournament = parseInt(row.total_decks_in_archetype || 0);
                    tournamentDecksMap.set(date, decksInTournament);
                }
            });
            
            // Sum up decks across all tournaments
            let totalDecks = 0;
            tournamentDecksMap.forEach(decks => {
                totalDecks += decks;
            });
            
            console.log('DEBUG: Tournament deck counts:', Array.from(tournamentDecksMap.entries()));
            console.log('DEBUG: Total decks across all tournaments:', totalDecks);
            
            filteredCards.forEach(row => {
      const cardName = row.card_name;
                
                if (!cardMap.has(cardName)) {
                    cardMap.set(cardName, {
                        sampleRow: row,
                        totalCount: 0,
                        maxCountValues: [],
                        deckCounts: 0,
                        tournamentsWithCard: new Set(),
                        tournamentDeckCountsWithCard: new Map()
                    });
                } else {
                    const cardData = cardMap.get(cardName);
                    // Update sample row if current row has more complete data
                    if (!cardData.sampleRow.image_url && row.image_url) {
                        cardData.sampleRow = row;
                    } else if (!cardData.sampleRow.set_code && row.set_code) {
                        cardData.sampleRow = row;
                    }
                }
                
                const cardData = cardMap.get(cardName);
                
                // Aggregate counts
                cardData.totalCount += parseInt(row.total_count || 0);
                const maxCount = parseInt(row.max_count || 0);
                if (maxCount > 0) {
                    cardData.maxCountValues.push(maxCount);
                }
                cardData.deckCounts += parseInt(row.deck_count || 0);
                
                if (row.tournament_date) {
                    cardData.tournamentsWithCard.add(row.tournament_date);
                    // Track deck count for each tournament where this card appeared
                    const decksInTournament = parseInt(row.total_decks_in_archetype || 0);
                    cardData.tournamentDeckCountsWithCard.set(row.tournament_date, decksInTournament);
                }
            });
            
            // Create aggregated result
            const result = [];
            
            cardMap.forEach((data, cardName) => {
                const row = { ...data.sampleRow };
                
                // Calculate aggregated max_count (most common value)
                let max_count = 0;
                if (data.maxCountValues.length > 0) {
                    const countFreq = {};
                    data.maxCountValues.forEach(val => {
                        countFreq[val] = (countFreq[val] || 0) + 1;
                    });
                    max_count = parseInt(Object.keys(countFreq).reduce((a, b) => 
                        countFreq[a] > countFreq[b] ? a : b
                    ));
                }
                
                // Calculate percentage based on actual deck counts
                // data.deckCounts is the sum of deck_count values (number of decks containing this card)
                // totalDecks is the sum of total_decks_in_archetype values (total number of decks in all tournaments)
                const percentage = totalDecks > 0 ? (data.deckCounts / totalDecks * 100) : 0;
                
                // Calculate average count
                const tournamentsWithCard = data.tournamentsWithCard.size;
                const avgCount = tournamentsWithCard > 0 ? (data.totalCount / tournamentsWithCard) : 0;
                
                // Update row and preserve important fields from sampleRow
                row.total_count = data.totalCount;
                row.max_count = max_count;
                row.deck_count = data.deckCounts;
                row.deck_count_in_selected = data.deckCounts; // Number of decks containing this card
                row.total_decks_in_archetype = totalDecks;
                row.percentage_in_archetype = percentage.toFixed(1);
                row.avg_count = avgCount.toFixed(2);
                // Explicitly preserve these fields from sampleRow
                row.set_code = data.sampleRow.set_code || '';
                row.image_url = data.sampleRow.image_url || '';
                row.rarity = data.sampleRow.rarity || '';
                row.set_number = data.sampleRow.set_number || '';
                
                // Debug: Log M3 cards
                if (row.set_code === 'M3' || (row.image_url && row.image_url.includes('/M3/'))) {
                    console.log(`M3 card aggregated: ${row.card_name}, set_code: ${row.set_code}, url: ${row.image_url}`);
                }
                
                result.push(row);
            });
            
            console.log(`Aggregated ${result.length} unique cards from ${totalDecks} decks across ${tournamentDecksMap.size} tournaments`);
            return result;
        }
        
        function loadCityLeagueDeckData(archetype) {
            console.log('Loading deck data for:', archetype);
            const data = window.cityLeagueAnalysisData;
            if (!data) return;
            
            // Filter cards for this archetype
            let deckCards = data.filter(row => row.archetype === archetype);
            console.log('Found cards (before date filter):', deckCards.length);
            
            // Apply date filter if active
            if (window.cityLeagueDateFilterActive) {
                const dateFrom = window.cityLeagueDateFrom;
                const dateTo = window.cityLeagueDateTo;
                
                console.log('DEBUG: Filtering by date range:', dateFrom, 'to', dateTo);
                
                const dateDebugSample = [];
                deckCards = deckCards.filter(row => {
                    const tournamentDate = parseJapaneseDate(row.tournament_date);
                    
                    // Collect first 5 examples for debugging
                    if (dateDebugSample.length < 5) {
                        dateDebugSample.push({
                            raw: row.tournament_date,
                            parsed: tournamentDate,
                            passes: tournamentDate && tournamentDate >= dateFrom && tournamentDate <= dateTo
                        });
                    }
                    
                   if (!tournamentDate) return false; // Exclude cards without valid date when filter is active
                    return tournamentDate >= dateFrom && tournamentDate <= dateTo;
                });
                
                console.log('DEBUG: Date filter examples:', dateDebugSample);
                console.log(`Date filter applied (${dateFrom} to ${dateTo}):`, deckCards.length, 'cards');
            }
            
            console.log('Found cards (before deduplication):', deckCards.length);
            
            // Aggregate cards stats if date filter is active
            if (window.cityLeagueDateFilterActive && deckCards.length > 0) {
                deckCards = aggregateCardStatsByDate(deckCards);
                console.log('After aggregating by date:', deckCards.length, 'unique cards');
            }
            
            // Dedupliziere: Nur neueste low-rarity Version pro Karte
            deckCards = deduplicateCards(deckCards);
            console.log('Found cards (after deduplication):', deckCards.length);
            
            // Store unfiltered deck cards for filter function
            window.currentCityLeagueDeckCards = deckCards;
            
            // Calculate stats - use max_count which represents typical deck composition
            const totalCardsInDeck = deckCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            const uniqueCards = deckCards.length;
            
            // Get current deck count - depends on whether date filter is active
            let decksCount = '-';
            
            if (window.cityLeagueDateFilterActive) {
                // When date filter is active, use the aggregated total_decks_in_archetype
                // This value was already calculated correctly in aggregateCardStatsByDate()
                decksCount = deckCards[0]?.total_decks_in_archetype || '-';
                console.log(`Using deck count from filtered/aggregated data: ${decksCount} decks`);
            } else {
                // No date filter - use total count from comparison data
                const comparisonData = window.cityLeagueComparisonData || [];
                const comparisonMatch = comparisonData.find(row => 
                    row.archetype && row.archetype.toLowerCase() === archetype.toLowerCase()
                );
                if (comparisonMatch && comparisonMatch.new_count) {
                    decksCount = comparisonMatch.new_count;
                    console.log(`Using current deck count from comparison data: ${decksCount}`);
                } else {
                    // Fallback to analysis data if comparison not available
                    decksCount = deckCards[0]?.total_decks_in_archetype || '-';
                    console.log(`Fallback to analysis data deck count: ${decksCount}`);
                }
            }
            
            // Calculate average placement from archetypes data
            const archetypesData = window.cityLeagueArchetypesData || [];
            const archetypeMatches = archetypesData.filter(row => 
                row.archetype && row.archetype.toLowerCase() === archetype.toLowerCase()
            );
            const avgPlacement = archetypeMatches.length > 0
                ? (archetypeMatches.reduce((sum, row) => sum + parseInt(row.placement || 0), 0) / archetypeMatches.length).toFixed(2)
                : '-';
            
            // Update stats
            document.getElementById('cityLeagueStatCards').textContent = `${uniqueCards} / ${totalCardsInDeck}`;
            document.getElementById('cityLeagueStatDecksUsed').textContent = decksCount;
            document.getElementById('cityLeagueStatAvgPlacement').textContent = avgPlacement !== '-' ? avgPlacement : '-';
            document.getElementById('cityLeagueStatsSection').style.display = 'block';
            
            // Render cards table
            renderCityLeagueAnalysisTable(deckCards);
            
            // Show deck visual
            renderCityLeagueDeckVisual(deckCards);
            
            // Render sorted overview grid
            renderOverviewCards(deckCards);
            
            // Apply current filter (this will update counts and re-filter if needed)
            applyCityLeagueFilter();
        }
        
        function clearCityLeagueDeckView() {
            document.getElementById('cityLeagueStatsSection').style.display = 'none';
            document.getElementById('cityLeagueDeckVisual').style.display = 'none';
            document.getElementById('cityLeagueAnalysisTable').innerHTML = '';
            document.getElementById('cityLeagueCardCount').textContent = '0 Karten';
            document.getElementById('cityLeagueCardCountSummary').textContent = '/ 0 Total';
        }
        
        // Helper function to fix Japanese card image URLs
        function fixJapaneseCardImageUrl(url, setCode) {
            if (!url) return url;
            
            // M3 set cards need URL correction for Japanese versions
            // English: tpci/M3/M3_046_R_EN_LG.png (with leading zero)
            // Japanese: tpc/M3/M3_46_R_JP_LG.png (without leading zero)
            const isM3Set = setCode === 'M3' || url.includes('/M3/');
            const hasEnInUrl = url.includes('_EN_');
            
            if (isM3Set && hasEnInUrl) {
                const originalUrl = url;
                
                // Replace tpci with tpc
                url = url.replace('/tpci/', '/tpc/');
                
                // Replace EN with JP
                url = url.replace(/_EN_/g, '_JP_');
                
                // Remove leading zeros from card number (M3_046 ‚Üí M3_46)
                url = url.replace(/\/M3_0+(\d+)_/g, '/M3_$1_');
                
                console.log(`M3 URL corrected: ${originalUrl} ‚Üí ${url}`);
            }
            
            return url;
        }
        
        function renderCityLeagueDeckVisual(cards) {
            const visualContainer = document.getElementById('cityLeagueDeckVisual');
            const gridContainer = document.getElementById('cityLeagueDeckGrid');
            if (!gridContainer) return;
            
            // Use the same sorting logic as "Karten √úbersicht (sortiert)"
            const sortedCards = sortCardsByType([...cards]);
            
            // Debug: Count M3 cards
            const m3Cards = sortedCards.filter(c => c.set_code === 'M3' || (c.image_url && c.image_url.includes('/M3/')));
            if (m3Cards.length > 0) {
                console.log(`Rendering ${m3Cards.length} M3 cards in deck visual. First 3:`, 
                    m3Cards.slice(0, 3).map(c => ({ name: c.card_name, set_code: c.set_code, url: c.image_url }))
                );
            }
            
            let html = '';
            sortedCards.forEach(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                const percentage = parseFloat(card.percentage_in_archetype || 0).toFixed(1);
                const maxCount = card.max_count || '?';
                const deckCount = card.deck_count_in_selected || 0;
                
                html += `
                    <div class="deck-card" title="${card.card_name} - ${percentage}% in ${maxCount}x">
                        <img src="${imageUrl}" alt="${card.card_name}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect width=%22245%22 height=%22342%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2218%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                        <div class="card-max-count">${maxCount}</div>
                        <div class="card-overlay">
                            <div class="card-percentage">${percentage}%</div>
                        </div>
                    </div>
                `;
            });
            
            gridContainer.innerHTML = html;
            visualContainer.style.display = 'block';
        }
        
        function toggleDeckGridView() {
            const gridContainer = document.getElementById('cityLeagueDeckGrid');
            if (!gridContainer) return;
            
            // Check current view mode
            const isGridView = gridContainer.style.display !== 'none';
            
            if (isGridView) {
                // Already showing grid, do nothing or could toggle to table
                alert('‚úÖ Grid-Ansicht ist bereits aktiv!');
            } else {
                // Refresh the grid view
                const cards = window.currentCityLeagueDeckCards;
                if (cards && cards.length > 0) {
                    renderCityLeagueDeckVisual(cards);
                }
            }
        }
        
        function copyDeckOverview() {
            const cards = window.currentCityLeagueDeckCards;
            if (!cards || cards.length === 0) {
                alert('‚ùå Keine Karten zum Kopieren!');
                return;
            }
            
            // Sort cards using the same logic
            const sortedCards = sortCardsByType([...cards]);
            
            // Group by category
            const pokemon = [];
            const trainer = [];
            const energy = [];
            let pokemonCount = 0;
            let trainerCount = 0;
            let energyCount = 0;
            
            sortedCards.forEach(card => {
                const cardType = card.type || card.card_type || '';
                const category = getCardTypeCategory(cardType);
                const maxCount = parseInt(card.max_count) || 1;
                const cardName = card.card_name || '';
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                const line = `${maxCount} ${cardName} ${setCode} ${setNumber}`.trim();
                
                if (category === 'Pokemon') {
                    pokemon.push(line);
                    pokemonCount += maxCount;
                } else if (category === 'Energy' || category === 'Special Energy') {
                    energy.push(line);
                    energyCount += maxCount;
                } else {
                    // Supporter, Item, Tool, Stadium all go to Trainer
                    trainer.push(line);
                    trainerCount += maxCount;
                }
            });
            
            // Build output text
            let output = '';
            
            if (pokemon.length > 0) {
                output += `Pok√©mon: ${pokemonCount}\n`;
                output += pokemon.join('\n') + '\n\n';
            }
            
            if (trainer.length > 0) {
                output += `Trainer: ${trainerCount}\n`;
                output += trainer.join('\n') + '\n\n';
            }
            
            if (energy.length > 0) {
                output += `Energy: ${energyCount}\n`;
                output += energy.join('\n');
            }
            
            // Copy to clipboard
            navigator.clipboard.writeText(output).then(() => {
                alert('‚úÖ Deck wurde in die Zwischenablage kopiert!');
            }).catch(err => {
                console.error('Fehler beim Kopieren:', err);
                alert('‚ùå Fehler beim Kopieren in die Zwischenablage!');
            });
        }

        function renderCityLeagueAnalysisTable(data) {
            console.log('renderCityLeagueAnalysisTable called with', data ? data.length : 0, 'rows');
            const tableContainer = document.getElementById('cityLeagueAnalysisTable');
            if (!tableContainer) {
                console.error('Table container not found!');
                return;
            }
            if (!data || data.length === 0) {
                console.warn('No data to render');
                tableContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #666;">Bitte w√§hle ein Deck aus...</p>';
                return;
            }

            // Use the same sorting logic as "Karten √úbersicht (sortiert)"
            const sortedData = sortCardsByType([...data]);
            
            let html = '<table><thead><tr>';
            html += '<th class="col-image">Bild</th>';
            html += '<th>Cards in Deck</th>';
            html += '<th>Kartenname</th>';
            html += '<th>Set</th>';
            html += '<th>Nummer</th>';
            html += '<th>% in Archetype</th>';
            html += '<th>Deck Count</th>';
            html += '<th>Aktion</th>';
            html += '</tr></thead><tbody>';

            sortedData.forEach(row => {
                const imageUrl = row.image_url || '';
                const cardName = row.card_name || '';
                const setCode = row.set_code || '';
                const setNumber = row.set_number || '';
                const maxCount = row.max_count || '?';
                const percentage = parseFloat(row.percentage_in_archetype || 0).toFixed(1);
                const deckCount = row.deck_count || '?';
                const totalDecks = row.total_decks_in_archetype || '?';
                
                // Get current deck count from window.cityLeagueDeck
                const deck = window.cityLeagueDeck || {};
                const currentDeckCount = deck[cardName] || 0;
                
                html += '<tr>';
                // Image with green badge if card is in deck
                html += `<td class="col-image"><div style="position: relative; display: inline-block;">`;
                html += `<img src="${imageUrl}" alt="${cardName}" style="width: 60px; border-radius: 4px; cursor: zoom-in;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2284%22%3E%3Crect width=%2260%22 height=%2284%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2210%22%3ENo Image%3C/text%3E%3C/svg%3E'" onclick="showSingleCard('${imageUrl}', '${cardName.replace(/'/g, "\\'")}')">`;
                if (currentDeckCount > 0) {
                    html += `<div style="position: absolute; top: 2px; left: 2px; background: #28a745; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.7em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">${currentDeckCount}</div>`;
                }
                html += `</div></td>`;
                html += `<td><strong>${currentDeckCount}/${maxCount}</strong></td>`;
                html += `<td><strong>${cardName}</strong></td>`;
                html += `<td>${setCode}</td>`;
                html += `<td>${setNumber}</td>`;
                html += `<td><strong>${percentage}%</strong></td>`;
                html += `<td>${deckCount} / ${totalDecks}</td>`;
                html += `<td><button class="btn btn-primary" onclick="addCardToDeck('cityLeague', '${cardName.replace(/'/g, "\\'")}')">+ Add</button></td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            tableContainer.innerHTML = html;
            console.log('Table rendered successfully');
        }
        
        function applyCityLeagueFilter() {
            const filterSelect = document.getElementById('cityLeagueFilterSelect');
            const archetype = document.getElementById('cityLeagueDeckSelect')?.value;
            
            if (!filterSelect || !archetype || !window.currentCityLeagueDeckCards) return;
            
            const filterValue = filterSelect.value;
            const allCards = window.currentCityLeagueDeckCards;
            let filteredCards = [...allCards];
            
            if (filterValue !== 'all') {
                const threshold = parseInt(filterValue);
                filteredCards = filteredCards.filter(card => parseFloat(card.percentage_in_archetype || 0) >= threshold);
            }
            
            console.log(`Filter applied: ${filterValue}, showing ${filteredCards.length} of ${allCards.length} cards`);
            
            // Calculate total card counts (sum of max_count)
            const filteredTotal = filteredCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            const allTotal = allCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            
            // Update table
            renderCityLeagueAnalysisTable(filteredCards);
            
            // Update overview grid with filtered cards
            renderOverviewCards(filteredCards);
            
            // Update deck visual grid
            renderCityLeagueDeckVisual(filteredCards);
            
            // Update card counts (unique filtered cards / total cards in deck)
            updateCityLeagueCardCounts(filteredCards.length, filteredTotal, allTotal);
        }
        
        function updateCityLeagueCardCounts(uniqueCount, filteredTotal, allTotal) {
            const countEl = document.getElementById('cityLeagueCardCount');
            const summaryEl = document.getElementById('cityLeagueCardCountSummary');
            
            if (countEl) {
                countEl.textContent = `${uniqueCount} Karten`;
            }
            if (summaryEl) {
                summaryEl.textContent = `/ ${filteredTotal} Total`;
            }
        }
        
        // Add filter change listener
        document.addEventListener('DOMContentLoaded', function() {
            const filterSelect = document.getElementById('cityLeagueFilterSelect');
            if (filterSelect) {
                filterSelect.onchange = applyCityLeagueFilter;
            }
        });

        function filterCityLeagueAnalysisCards() {
            const searchTerm = (document.getElementById('cityLeagueCardSearchInput')?.value || '').toLowerCase();
            const rows = document.querySelectorAll('#cityLeagueAnalysisTable table tbody tr');
            let visibleCount = 0;

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const visible = text.includes(searchTerm);
                row.style.display = visible ? '' : 'none';
                if (visible) visibleCount += 1;
            });

            const countEl = document.getElementById('cityLeagueCardCount');
            if (countEl) {
                countEl.textContent = `${visibleCount} Karten`;
            }
        }

        // Toggle functions for card tables
        function toggleCityLeagueCards() {
            const content = document.getElementById('cityLeagueCardsContent');
            const toggle = document.getElementById('cityLeagueCardsToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }
        
        // Toggle function for deck overview (starts expanded)
        function toggleCityLeagueDeckOverview() {
            const content = document.getElementById('cityLeagueDeckOverviewContent');
            const toggle = document.getElementById('cityLeagueDeckOverviewToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }
        
        // City League Deck Builder Functions
        if (!window.cityLeagueDeck) {
            window.cityLeagueDeck = {};
        }
        
        function addCardToDeck(source, cardName, setCode, setNumber) {
            if (source !== 'cityLeague') return;
            
            const deck = window.cityLeagueDeck;

            // Apply saved rarity preference when no version is specified
            if ((!setCode || !setNumber) && cardName) {
                const preferredVersion = getPreferredVersionForCard(cardName);
                if (preferredVersion) {
                    setCode = preferredVersion.set;
                    setNumber = preferredVersion.number;
                }
            }
            
            // CRITICAL FIX: Check if card already exists with a different key format
            // If card exists as "CardName" but we're adding "CardName (SET NUM)", update the existing key
            let deckKey = (setCode && setNumber) ? `${cardName} (${setCode} ${setNumber})` : cardName;
            
            // Check if there's already an entry for this card (with or without version info)
            let existingKey = null;
            if (deck[deckKey]) {
                existingKey = deckKey; // Exact match
            } else if (deck[cardName]) {
                existingKey = cardName; // Card exists without version
            } else {
                // Check if any key starts with this card name
                for (const key in deck) {
                    if (key === cardName || key.startsWith(cardName + ' (')) {
                        existingKey = key;
                        break;
                    }
                }
            }
            
            // If we found an existing key and it's different from our new key, migrate it
            if (existingKey && existingKey !== deckKey && setCode && setNumber) {
                console.log(`Migrating deck entry from "${existingKey}" to "${deckKey}"`);
                deck[deckKey] = deck[existingKey];
                delete deck[existingKey];
            } else if (existingKey) {
                deckKey = existingKey; // Use the existing key
            }
            
            if (!deck[deckKey]) {
                deck[deckKey] = 0;
            }
            
            const currentTotal = Object.values(deck).reduce((sum, count) => sum + count, 0);
            if (currentTotal >= 60) {
                alert('Deck ist voll (60 Karten)!');
                return;
            }
            
            // Check if card is a base energy or Ace Spec (no 4-copy limit for these)
            const cards = window.currentCityLeagueDeckCards || [];
            const allCardsDb = window.allCardsDatabase || [];
            let cardData = cards.find(c => c.card_name === cardName);
            if (!cardData && setCode && setNumber) {
                cardData = allCardsDb.find(c => c.name === cardName && c.set === setCode && c.number === setNumber);
            }
            const isBaseEnergy = cardData && (cardData.type || cardData.card_type || '').toLowerCase() === 'energy' && 
                                (cardName || '').match(/^(Fire|Water|Grass|Lightning|Psychic|Fighting|Darkness|Metal|Fairy|Dragon|Colorless|Neutral)\s+Energy$/i);
            const isAceSpec = cardData && (cardData.is_ace_spec === 'Yes' || cardData.is_ace_spec === true);
            
            // Check if card already has 4 copies (only applies to non-energy, non-ace-spec cards)
            if (!isBaseEnergy && !isAceSpec && deck[deckKey] >= 4) {
                alert('Maximal 4 Kopien pro Karte!');
                return;
            }
            
            // Ace Spec cards can only have 1 copy in deck
            if (isAceSpec && deck[deckKey] >= 1) {
                alert('Ace Spec Karten d√ºrfen nur 1x im Deck sein!');
                return;
            }
            
            deck[deckKey]++;
            console.log(`Added card to deck: ${deckKey} -> ${deck[deckKey]}`);
            updateDeckDisplay('cityLeague');
        }
        
        function removeCardFromDeck(source, deckKey) {
            if (source !== 'cityLeague') return;
            
            const deck = window.cityLeagueDeck;
            if (deck[deckKey] && deck[deckKey] > 0) {
                deck[deckKey]--;
                if (deck[deckKey] === 0) {
                    delete deck[deckKey];
                }
                updateDeckDisplay('cityLeague');
            }
        }
        
        function clearDeck(source) {
            if (source !== 'cityLeague') return;
            
            if (confirm('M√∂chtest du wirklich alle Karten aus dem Deck entfernen?')) {
                window.cityLeagueDeck = {};
                updateDeckDisplay('cityLeague');
            }
        }
        
        function updateDeckDisplay(source) {
            if (source !== 'cityLeague') return;
            
            const deck = window.cityLeagueDeck;
            const total = Object.values(deck).reduce((sum, count) => sum + count, 0);
            const unique = Object.keys(deck).filter(k => deck[k] > 0).length;
            
            const countEl = document.getElementById('cityLeagueDeckCount');
            const uniqueEl = document.getElementById('cityLeagueDeckCountUnique');
            
            if (countEl) countEl.textContent = total;
            if (uniqueEl) uniqueEl.textContent = `(${unique} Unique)`;
            
            // Update the My Deck grid
            renderMyDeckGrid('cityLeague');
            
            // Update the Deck Overview table and Cards Overview with current deck counts
            const currentCards = window.currentCityLeagueDeckCards;
            if (currentCards && currentCards.length > 0) {
                renderCityLeagueAnalysisTable(currentCards);
                renderOverviewCards(currentCards);
            }
        }
        
        function renderMyDeckGrid(source) {
            if (source !== 'cityLeague') return;
            
            const deck = window.cityLeagueDeck;
            const allCards = window.currentCityLeagueDeckCards || [];
            const allCardsFromDb = window.allCardsDatabase || [];
            
            // Build card data maps: by name and by name+set+number
            const cardDataByName = {};
            const cardDataByKey = {};
            
            // First, add cards from currentCityLeagueDeckCards
            allCards.forEach(card => {
                cardDataByName[card.card_name] = card;
            });
            
            // Then add cards from allCardsDatabase with both keys
            allCardsFromDb.forEach(card => {
                const imageUrl = buildCardImageUrl(card.set, card.number, card.rarity);
                const cardData = {
                    card_name: card.name,
                    image_url: imageUrl,
                    percentage_in_archetype: 0,
                    type: card.type || 'Unknown',
                    card_type: card.type || 'Unknown',
                    set_code: card.set,
                    set_number: card.number
                };
                
                // Key by name only
                if (!cardDataByName[card.name]) {
                    cardDataByName[card.name] = cardData;
                }
                
                // Key by "name (SET NUM)" for exact version match
                const versionKey = `${card.name} (${card.set} ${card.number})`;
                cardDataByKey[versionKey] = cardData;
            });
            
            // Convert deck to array with card data
            const deckCards = [];
            for (const [deckKey, count] of Object.entries(deck)) {
                if (count <= 0) continue;
                
                // Try exact match first (with SET NUM), then fallback to name only
                let cardData = cardDataByKey[deckKey] || cardDataByName[deckKey];
                
                // If still not found, extract card name from "CardName (SET NUM)" format
                if (!cardData) {
                    const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                    if (baseNameMatch) {
                        const baseName = baseNameMatch[1];
                        const setMatch = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                        
                        if (setMatch) {
                            const setCode = setMatch[1];
                            const setNumber = setMatch[2];
                            
                            // Try to find exact card in allCardsDatabase
                            const exactCard = allCardsFromDb.find(c => 
                                c.name === baseName && c.set === setCode && c.number === setNumber
                            );
                            
                            if (exactCard) {
                                const imageUrl = buildCardImageUrl(exactCard.set, exactCard.number, exactCard.rarity);
                                cardData = {
                                    card_name: exactCard.name,
                                    image_url: imageUrl,
                                    percentage_in_archetype: 0,
                                    type: exactCard.type || 'Unknown',
                                    card_type: exactCard.type || 'Unknown',
                                    set_code: exactCard.set,
                                    set_number: exactCard.number,
                                    rarity: exactCard.rarity
                                };
                            } else {
                                // Fallback to base name - keep original image_url!
                                const baseCardData = cardDataByName[baseName];
                                if (baseCardData) {
                                    console.log(`[renderMyDeckGrid] Using base card data for: ${baseName}, keeping image_url: ${baseCardData.image_url}`);
                                    cardData = {
                                        ...baseCardData,
                                        set_code: setCode,
                                        set_number: setNumber
                                        // Keep original image_url from baseCardData
                                    };
                                } else {
                                    console.warn(`[renderMyDeckGrid] Card not found: ${baseName} (${setCode} ${setNumber})`);
                                }
                            }
                        } else {
                            // No set info in key, use base name
                            cardData = cardDataByName[baseName];
                        }
                    }
                }
                
                if (!cardData) continue;

                const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                const baseName = baseNameMatch ? baseNameMatch[1] : (cardData.card_name || deckKey);
                const archetypeData = cardDataByName[baseName];
                if (archetypeData) {
                    cardData = {
                        ...cardData,
                        percentage_in_archetype: archetypeData.percentage_in_archetype || cardData.percentage_in_archetype,
                        card_type: archetypeData.card_type || archetypeData.type || cardData.card_type,
                        type: archetypeData.type || archetypeData.card_type || cardData.type
                    };
                }

                const globalPref = getGlobalRarityPreference();
                const pref = getRarityPreference(baseName);
                if (archetypeData && globalPref === 'auto' && (!pref || pref.mode !== 'specific')) {
                    cardData.image_url = archetypeData.image_url || cardData.image_url;
                }
                
                deckCards.push({...cardData, deck_count_in_selected: count, deck_key: deckKey});
            }
            
            // Apply sorting logic like other views
            const sortedDeckCards = sortCardsByType(deckCards);
            
            // Build grid from deck
            let html = '';
            sortedDeckCards.forEach(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                const percentage = parseFloat(card.percentage_in_archetype || 0).toFixed(1);
                const count = card.deck_count_in_selected || 1;
                const cardNameEscaped = card.card_name.replace(/'/g, "\\'");
                const deckKeyEscaped = (card.deck_key || card.card_name).replace(/'/g, "\\'");
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                // Calculate average count
                const totalCount = parseInt(card.total_count || 0);
                const totalDecksInArchetype = parseInt(card.total_decks_in_archetype || 1);
                const avgCount = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0.00';
                
                html += `
                    <div class="deck-card" style="position: relative;" title="${card.deck_key || card.card_name} (${count}x) - ${percentage}%">
                        <img src="${imageUrl}" alt="${card.card_name}" style="cursor: zoom-in;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect fill=%22%23667eea%22 width=%22245%22 height=%22342%22/%3E%3Ctext fill=%22white%22 x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 font-size=%2220%22%3EKeine Bild%3C/text%3E%3C/svg%3E'" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped}')">
                        <div class="card-max-count">${count}</div>
                        
                        <!-- Stats √ºber den Buttons -->
                        <div style="position: absolute; bottom: 30px; left: 5px; right: 5px; background: rgba(0,0,0,0.75); color: white; padding: 2px 4px; border-radius: 4px; font-size: 8px; text-align: center; z-index: 2; white-space: nowrap; overflow: hidden;">
                            <div style="font-weight: bold;">${percentage}% | √ò ${avgCount}x</div>
                        </div>
                        
                        <div style="position: absolute; bottom: 5px; left: 5px; right: 5px; display: grid; grid-template-columns: 20px 1fr 20px; gap: 3px; z-index: 3; align-items: center;">
                            <button onclick="removeCardFromDeck('cityLeague', '${deckKeyEscaped}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; width: 20px; height: 20px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 12px;">‚àí</button>
                            <button onclick="openRaritySwitcher('${cardNameEscaped}', '${deckKeyEscaped}')" style="background: #ffc107; color: #333; border: none; border-radius: 3px; padding: 2px 4px; cursor: pointer; font-size: 11px; font-weight: bold; text-align: center; min-width: 20px;">‚òÖ</button>
                            <button onclick="addCardToDeck('cityLeague', '${cardNameEscaped}', '${setCode}', '${setNumber}')" style="background: #28a745; color: white; border: none; border-radius: 3px; width: 20px; height: 20px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 12px;">+</button>
                        </div>
                        <div class="card-overlay">
                            <div class="card-percentage">${percentage}%</div>
                        </div>
                    </div>
                `;
            });
            
            const gridContainer = document.getElementById('cityLeagueMyDeckGrid');
            if (gridContainer) {
                gridContainer.innerHTML = html;
                const visualContainer = document.getElementById('cityLeagueMyDeckVisual');
                if (visualContainer && html.length > 0) {
                    visualContainer.style.display = 'block';
                }
            }
        }
        
        // ========== CARD SORTING & ORGANIZATION FUNCTIONS ==========
        
        function getCardTypeCategory(cardType) {
            /**
             * Determines the category of a card based on the type field
             * type format: "GBasic", "WBasic", "PStage1", "PStage2", "Supporter", "Item", "Tool", "Stadium", "Special Energy", "Energy"
             */
            if (!cardType) return 'Pokemon';
            
            // Check if it's a Pokemon (type starts with element letter)
            if (cardType.charAt(0).match(/[GRWLPFDMNC]/)) {
                return 'Pokemon';
            }
            
            // Check exact matches for trainer types
            if (cardType === 'Supporter') return 'Supporter';
            if (cardType === 'Item') return 'Item';
            if (cardType === 'Tool') return 'Tool';
            if (cardType === 'Stadium') return 'Stadium';
            if (cardType === 'Special Energy') return 'Special Energy';
            if (cardType === 'Energy') return 'Energy';
            if (cardType === 'Trainer') return 'Item';
            
            // Fallback to Pokemon
            return 'Pokemon';
        }
        
        function sortCardsByType(cards) {
            /**
             * Sort cards:
             * 1. By Category (Pokemon, Supporter, Item, etc.)
             * 2. By Element (for Pokemon: G, R, W, L, P, F, D, M, N, C)
             * 3. By PERCENTAGE (highest first!)
             * 4. By Evolution Chain (keep together: Basic, Stage1, Stage2)
             * 5. By Set Number
             */
            
            // Pokemon Evolution Chains (from pokemondb.net/evolution)
            const evolutionChains = {
                'Bulbasaur': ['Bulbasaur', 'Ivysaur', 'Venusaur'],
                'Ivysaur': ['Bulbasaur', 'Ivysaur', 'Venusaur'],
                'Venusaur': ['Bulbasaur', 'Ivysaur', 'Venusaur'],
                'Charmander': ['Charmander', 'Charmeleon', 'Charizard'],
                'Charmeleon': ['Charmander', 'Charmeleon', 'Charizard'],
                'Charizard': ['Charmander', 'Charmeleon', 'Charizard'],
                'Squirtle': ['Squirtle', 'Wartortle', 'Blastoise'],
                'Wartortle': ['Squirtle', 'Wartortle', 'Blastoise'],
                'Blastoise': ['Squirtle', 'Wartortle', 'Blastoise'],
                'Pichu': ['Pichu', 'Pikachu', 'Raichu'],
                'Pikachu': ['Pichu', 'Pikachu', 'Raichu'],
                'Raichu': ['Pichu', 'Pikachu', 'Raichu'],
                'Riolu': ['Riolu', 'Lucario', 'Mega Lucario ex'],
                'Lucario': ['Riolu', 'Lucario', 'Mega Lucario ex'],
                'Mega Lucario ex': ['Riolu', 'Lucario', 'Mega Lucario ex'],
                'Eevee': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Vaporeon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Jolteon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Flareon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Espeon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Umbreon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Leafeon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Glaceon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Sylveon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Shaymin': ['Shaymin'],
                'Dialga': ['Dialga'],
                'Palkia': ['Palkia'],
                'Kyogre': ['Kyogre'],
                'Groudon': ['Groudon'],
                'Rayquaza': ['Rayquaza'],
                'Jirachi': ['Jirachi'],
                'Deoxys': ['Deoxys'],
                'Budew': ['Budew', 'Roserade'],
                'Roserade': ['Budew', 'Roserade'],
                'Chimecho': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Chimchar': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Monferno': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Infernape': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Piplup': ['Piplup', 'Prinplup', 'Empoleon'],
                'Prinplup': ['Piplup', 'Prinplup', 'Empoleon'],
                'Empoleon': ['Piplup', 'Prinplup', 'Empoleon'],
                'Turtwig': ['Turtwig', 'Grotle', 'Torterra'],
                'Grotle': ['Turtwig', 'Grotle', 'Torterra'],
                'Torterra': ['Turtwig', 'Grotle', 'Torterra'],
                'Makuhita': ['Makuhita', 'Hariyama'],
                'Hariyama': ['Makuhita', 'Hariyama'],
                'Lunatone': ['Lunatone'],
                'Solrock': ['Solrock'],
                'Cornerstone Mask Oger': ['Cornerstone Mask Oger'],
                'Ting-Lu': ['Ting-Lu'],
                'Oricorio': ['Oricorio'],
                'Drilbur': ['Drilbur', 'Excadrill'],
                'Excadrill': ['Drilbur', 'Excadrill'],
                'Hawlucha': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Rowlet': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Dartrix': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Decidueye': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Ethan\'s Sudowoodo': ['Ethan\'s Sudowoodo'],
                'Fezandipiti ex': ['Fezandipiti ex'],
                'Mega Zygarde ex': ['Mega Zygarde ex'],
                'Escadrill': ['Escadrill'],
                'Psyduck': ['Psyduck', 'Golduck'],
                'Golduck': ['Psyduck', 'Golduck'],
                'Flutter Mane': ['Flutter Mane'],
                'Lillie\'s Certainty ex': ['Lillie\'s Certainty ex'],
                'Munkidori': ['Munkidori'],
                'Togepi': ['Togepi', 'Togetic', 'Togekiss'],
                'Togetic': ['Togepi', 'Togetic', 'Togekiss'],
                'Togekiss': ['Togepi', 'Togetic', 'Togekiss']
            };
            
            const elementOrder = {
                'G': 1,  // Grass
                'R': 2,  // Fire
                'W': 3,  // Water
                'L': 4,  // Lightning
                'P': 5,  // Psychic
                'F': 6,  // Fighting
                'D': 7,  // Darkness
                'M': 8,  // Metal
                'N': 9,  // Dragon
                'C': 10  // Colorless
            };
            
            const evolutionOrder = {
                'Basic': 1,
                'Stage1': 2,
                'Stage2': 3
            };
            
            const typeOrder = {
                'Pokemon': 1,
                'Supporter': 2,
                'Item': 3,
                'Tool': 4,
                'Stadium': 5,
                'Special Energy': 6,
                'Energy': 7
            };
            
            return cards.sort((a, b) => {
                const cardTypeA = a.type || a.card_type || '';
                const cardTypeB = b.type || b.card_type || '';
                
                const categoryA = getCardTypeCategory(cardTypeA);
                const categoryB = getCardTypeCategory(cardTypeB);
                
                const orderA = typeOrder[categoryA] || 99;
                const orderB = typeOrder[categoryB] || 99;
                
                // FIRST: Sort by main category (Pokemon, Supporter, etc.)
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // Parse percentage once for both cards
                const percA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                const percB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                
                // For Pokemon: sort by element first
                if (categoryA === 'Pokemon' && categoryB === 'Pokemon') {
                    const elementA = cardTypeA.charAt(0);
                    const elementB = cardTypeB.charAt(0);
                    const evolutionA = cardTypeA.substring(1).replace(/\s+/g, '');
                    const evolutionB = cardTypeB.substring(1).replace(/\s+/g, '');
                    
                    const elemOrderA = elementOrder[elementA] || 99;
                    const elemOrderB = elementOrder[elementB] || 99;
                    
                    // Different element: sort by element order
                    if (elemOrderA !== elemOrderB) {
                        return elemOrderA - elemOrderB;
                    }
                    
                    // SAME ELEMENT: Sort by PERCENTAGE (highest first)
                    if (percA !== percB) {
                        return percB - percA;
                    }
                    
                    // Same percentage: sort by SET NUMBER (f√ºr korrekte Reihenfolge)
                    const setNumA = parseInt((a.set_number || '0').toString().replace(/[^\d]/g, '')) || 0;
                    const setNumB = parseInt((b.set_number || '0').toString().replace(/[^\d]/g, '')) || 0;
                    if (setNumA !== setNumB) {
                        return setNumA - setNumB;
                    }
                    
                    // Same set number: sort by evolution stage (falls mehrere Versionen)
                    const evolOrderA = evolutionOrder[evolutionA] || 99;
                    const evolOrderB = evolutionOrder[evolutionB] || 99;
                    
                    if (evolOrderA !== evolOrderB) {
                        return evolOrderA - evolOrderB;
                    }
                }
                
                // For non-Pokemon cards: Sort by PERCENTAGE (highest first)
                if (percA !== percB) {
                    return percB - percA;
                }
                
                // Same percentage: sort by set number
                const setNumA = parseInt((a.set_number || '0').toString().replace(/[^\d]/g, '')) || 0;
                const setNumB = parseInt((b.set_number || '0').toString().replace(/[^\d]/g, '')) || 0;
                if (setNumA !== setNumB) {
                    return setNumA - setNumB;
                }
                
                // Finally by name
                const nameA = a.card_name || a.name || '';
                const nameB = b.card_name || b.name || '';
                return nameA.localeCompare(nameB);
            });
        }
        
        function deduplicateCards(cards) {
            /**
             * F√ºr jede Karte (gleicher Name) nur die neueste low-rarity Version behalten
             */
            const setOrder = {
                // 2026 Sets
                'PRE': 108, 'SFA': 107, 'ASC': 106,
                // 2025 Sets
                'MEG': 105, 'MEP': 104, 'SP': 103, 'SVE': 102,
                // 2024 Sets
                'SCR': 101, 'TWM': 100, 'TEF': 99, 'PAR': 98, 'PAF': 97, 'PAL': 96, 'OBF': 95,
                // 2023 Sets
                'MEW': 94, 'SVI': 93, 'CRZ': 92, 'SIT': 91, 'LOR': 90, 'PGO': 89,
                // Special/Promo (higher than SSH)
                'BLK': 99, 'WHT': 98, 'SSP': 94,
                // 2022 Sets
                'ASR': 88, 'BRS': 87, 'FST': 86, 'CEL': 85, 'EVS': 84, 'CRE': 83,
                // 2021 Sets
                'BST': 82, 'SHF': 81, 'VIV': 80, 'CPA': 79, 'DAA': 78,
                // 2020 Sets
                'RCL': 77, 'SSH': 76, 'CEC': 75
            };
            
            const rarityOrder = {
                'Common': 1,
                'Uncommon': 2,
                'Rare': 3,
                'Holo Rare': 4,
                'Ultra Rare': 5,
                'Secret Rare': 6,
                'Hyper Rare': 7,
                'Special Rare': 8,
                'Illustration Rare': 9,
                'Promo': 10
            };
            
            const cardMap = new Map();
            
            cards.forEach(card => {
                const cardName = card.card_name;
                
                if (!cardMap.has(cardName)) {
                    cardMap.set(cardName, card);
                } else {
                    const existing = cardMap.get(cardName);
                    const existingSetPriority = setOrder[existing.set_code] || 0;
                    const newSetPriority = setOrder[card.set_code] || 0;
                    const existingRarityPriority = rarityOrder[existing.rarity] || 99;
                    const newRarityPriority = rarityOrder[card.rarity] || 99;
                    
                    // Bevorzuge: 1. Low Rarity (Common/Uncommon), 2. Neuestes Set
                    if (newRarityPriority < existingRarityPriority) {
                        // Niedrigere Rarity gewinnt - aber behalte aggregierte Daten
                        // Nur √ºberschreiben wenn neue Werte nicht leer sind
                        if (card.image_url) existing.image_url = card.image_url;
                        if (card.set_code) existing.set_code = card.set_code;
                        if (card.rarity) existing.rarity = card.rarity;
                        if (card.set_number) existing.set_number = card.set_number;
                    } else if (newRarityPriority === existingRarityPriority && newSetPriority > existingSetPriority) {
                        // Gleiche Rarity, aber neueres Set - behalte aggregierte Daten
                        // Nur √ºberschreiben wenn neue Werte nicht leer sind
                        if (card.image_url) existing.image_url = card.image_url;
                        if (card.set_code) existing.set_code = card.set_code;
                        if (card.rarity) existing.rarity = card.rarity;
                        if (card.set_number) existing.set_number = card.set_number;
                    }
                    // Falls set_code fehlt aber image_url das Set zeigt, extrahiere es
                    if (!existing.set_code && existing.image_url) {
                        if (existing.image_url.includes('/M3/')) {
                            existing.set_code = 'M3';
                            console.log(`Set code M3 extracted from URL for: ${existing.card_name}`);
                        }
                    }
                }
            });
            
            // Debug: Count cards with set_code after deduplication
            const result = Array.from(cardMap.values());
            const m3Cards = result.filter(c => c.set_code === 'M3' || (c.image_url && c.image_url.includes('/M3/')));
            if (m3Cards.length > 0) {
                console.log(`After deduplicateCards: ${m3Cards.length} M3 cards. First 3:`, 
                    m3Cards.slice(0, 3).map(c => ({ name: c.card_name, set_code: c.set_code, url: c.image_url }))
                );
            }
            
            return result;
        }
        
        // ========== DECK OVERVIEW RENDERING FUNCTIONS ==========
        
        function renderOverviewCards(cards) {
            /**
             * Renders deck overview for City League Analysis
             * Shows cards in a responsive grid with:
             * - Card image
             * - Red circle (top-right): max_count
             * - Green circle (top-left): deck_count (how many in selected deck - starts at 0)
             * - Card name
             * - Percentage and average count
             */
            // Karten sind bereits in loadCityLeagueDeckData() dedupliziert
            const sortedCards = sortCardsByType([...cards]);
            
            // Get current deck state
            const deck = window.cityLeagueDeck || {};
            
            // Log for debugging
            console.log('RENDERED OVERVIEW CARDS - Sorted by type:');
            sortedCards.slice(0, 10).forEach((card, idx) => {
                console.log(`${idx + 1}. ${card.card_name} (${card.type || card.card_type || 'UNKNOWN'}) - ${getCardTypeCategory(card.type || card.card_type || '')}`);
            });
            
            const overviewContainer = document.getElementById('cityLeagueDeckOverview');
            if (!overviewContainer) return;
            
            const gridHtml = sortedCards.map(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                // Konvertiere Komma zu Punkt f√ºr parseFloat (CSV verwendet Komma als Dezimaltrennzeichen)
                const percentageStr = (card.percentage_in_archetype || '0').toString().replace(',', '.');
                let percentage = parseFloat(percentageStr);
                const maxCount = card.max_count || '-';
                
                // Get actual deck count from window.cityLeagueDeck
                // Try both: card name only AND "CardName (SET NUM)" format
                let deckCount = deck[card.card_name] || 0;
                if (deckCount === 0 && card.set_code && card.set_number) {
                    const versionKey = `${card.card_name} (${card.set_code} ${card.set_number})`;
                    deckCount = deck[versionKey] || 0;
                }
                // Also check all deck keys that start with the card name
                if (deckCount === 0) {
                    for (const key in deck) {
                        if (key.startsWith(card.card_name + ' (')) {
                            deckCount += deck[key];
                        }
                    }
                }
                
                // Calculate average count over all decks (total_count / total_decks_in_archetype)
                const totalCount = parseInt(card.total_count || 0);
                const totalDecksInArchetype = parseInt(card.total_decks_in_archetype || 1);
                const avgCount = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0';
                
                // Card image or placeholder
                let imgHtml = '';
                if (imageUrl && imageUrl.trim() !== '') {
                    imgHtml = `<img src="${imageUrl}" alt="${card.card_name}" referrerpolicy="no-referrer" style="width: 100%; aspect-ratio: 2.5/3.5; object-fit: cover; cursor: zoom-in;" onerror="this.style.opacity='0.3'" onclick="event.stopPropagation(); showSingleCard('${imageUrl}', '${card.card_name.replace(/'/g, "\\'")}');">`;
                } else {
                    imgHtml = `<div style="width: 100%; aspect-ratio: 2.5/3.5; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;">üÉè</div>`;
                }
                
                return `
                    <div class="card-item" style="position: relative; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; background: white;">
                        <div style="position: relative; width: 100%;">
                            ${imgHtml}
                            
                            <!-- Red badge: Max Count (top-right) -->
                            <div style="position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">
                                ${maxCount}
                            </div>
                            
                            <!-- Green badge: Deck Count (top-left) - only show if > 0 -->
                            ${deckCount > 0 ? `
                            <div style="position: absolute; top: 5px; left: 5px; background: #28a745; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">
                                ${deckCount}
                            </div>
                            ` : ''}
                        </div>
                        
                        <!-- Card info section -->
                        <div style="padding: 8px; background: white; font-size: 0.75em; text-align: center; min-height: 60px; display: flex; flex-direction: column; justify-content: space-between;">
                            <div>
                                <div style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 600; margin-bottom: 3px; color: #333; font-size: 0.9em;">
                                    ${card.card_name}
                                </div>
                                <div style="color: #999; font-size: 0.75em; margin-bottom: 3px;">
                                    ${card.set_code || ''} ${card.set_number || ''}
                                </div>
                                <div style="color: #666; font-size: 0.85em;">
                                    ${percentage.toFixed(2).replace('.', ',')}% | √ò ${avgCount}x
                                </div>
                            </div>
                            
                            <!-- Add button -->
                            <button class="btn btn-success" style="padding: 4px 8px; font-size: 0.75em; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; transition: all 0.2s; margin-top: 8px; width: 100%;" onclick="addCardToDeck('cityLeague', '${card.card_name.replace(/'/g, "\\'")}', '${card.set_code || ''}', '${card.set_number || ''}')" title="Add to deck">Add to Deck</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            overviewContainer.innerHTML = gridHtml;
        }
        
        function generateDeckGrid(source) {
            if (source !== 'cityLeague') return;
            
            const deck = window.cityLeagueDeck;
            if (!deck || Object.keys(deck).length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            const modal = document.getElementById('imageViewModal');
            const grid = document.getElementById('compactCardGrid');
            const allCards = window.currentCityLeagueDeckCards || [];
            const allCardsDb = window.allCardsDatabase || [];
            
            // Build a map of card data keyed by name
            const cardDataMap = {};
            allCards.forEach(card => {
                cardDataMap[card.card_name] = card;
            });
            
            // Convert deck to array with card data
            const deckCards = [];
            for (const [deckKey, count] of Object.entries(deck)) {
                if (count <= 0) continue;
                
                // Extract card name from deckKey (handle "CardName (SET NUM)" format)
                const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                const cardName = baseNameMatch ? baseNameMatch[1] : deckKey;
                
                let cardData = cardDataMap[cardName] || cardDataMap[deckKey];
                
                // If not found, try to find in allCardsDatabase
                if (!cardData) {
                    const setMatch = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                    if (setMatch) {
                        const exactCard = allCardsDb.find(c => c.name === cardName);
                        if (exactCard) {
                            const imageUrl = buildCardImageUrl(setMatch[1], setMatch[2], exactCard.rarity || 'Common');
                            cardData = {
                                card_name: exactCard.name,
                                image_url: imageUrl,
                                type: exactCard.type || 'Unknown',
                                set_code: setMatch[1]
                            };
                        }
                    }
                }
                
                if (!cardData) continue;
                
                deckCards.push({...cardData, deck_count_in_selected: count, card_name: cardName});
            }
            
            // Sort cards using the standard sorting function
            const sortedCards = sortCardsByType(deckCards);
            
            // Check if mobile device
            const isMobile = window.innerWidth <= 768;
            
            // Build grid HTML
            grid.innerHTML = sortedCards.map(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                const count = card.deck_count_in_selected || 1;
                const cardName = card.card_name || '';
                const cardNameEscaped = (cardName || '').replace(/'/g, "\\'");
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" title="${cardName} (${count}x)" style="cursor: zoom-in;" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped}')">
                            <img src="${imageUrl}" 
                                 alt="${cardName}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect width=%22245%22 height=%22342%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2218%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.8em; margin-bottom: 5px;">${cardName.substring(0, 15)}</div>
                                <div class="compact-badge" style="position: static;">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            // Add mobile-specific class for compact layout
            if (isMobile) {
                grid.classList.add('mobile-compact-grid');
            } else {
                grid.classList.remove('mobile-compact-grid');
            }
            
            modal.classList.add('show');
        }
        
        function copyDeck(source) {
            if (source !== 'cityLeague') return;
            
            const deck = window.cityLeagueDeck;
            if (!deck || Object.keys(deck).length === 0) {
                alert('Deck ist leer!');
                return;
            }
            
            const allCards = window.currentCityLeagueDeckCards || [];
            const cardDataMap = {};
            allCards.forEach(card => {
                cardDataMap[card.card_name] = card;
            });
            
            // Build array from deck with card data
            const deckCards = [];
            for (const [cardName, count] of Object.entries(deck)) {
                if (count <= 0) continue;
                const cardData = cardDataMap[cardName];
                if (!cardData) continue;
                deckCards.push({...cardData, deck_count_in_selected: count});
            }
            
            // Sort using same logic
            const sortedCards = sortCardsByType(deckCards);
            
            // Group by category
            const pokemon = [];
            const trainer = [];
            const energy = [];
            let pokemonCount = 0;
            let trainerCount = 0;
            let energyCount = 0;
            
            sortedCards.forEach(card => {
                const cardType = card.type || card.card_type || '';
                const category = getCardTypeCategory(cardType);
                const count = card.deck_count_in_selected || 1;
                const cardName = card.card_name || '';
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                const line = `${count} ${cardName} ${setCode} ${setNumber}`.trim();
                
                if (category === 'Pokemon') {
                    pokemon.push(line);
                    pokemonCount += count;
                } else if (category === 'Energy' || category === 'Special Energy') {
                    energy.push(line);
                    energyCount += count;
                } else {
                    trainer.push(line);
                    trainerCount += count;
                }
            });
            
            // Build output
            let output = '';
            if (pokemon.length > 0) {
                output += `Pok√©mon: ${pokemonCount}\n`;
                output += pokemon.join('\n') + '\n\n';
            }
            if (trainer.length > 0) {
                output += `Trainer: ${trainerCount}\n`;
                output += trainer.join('\n') + '\n\n';
            }
            if (energy.length > 0) {
                output += `Energy: ${energyCount}\n`;
                output += energy.join('\n');
            }
            
            navigator.clipboard.writeText(output).then(() => {
                alert('‚úÖ Deck wurde in die Zwischenablage kopiert!');
            }).catch(err => {
                console.error('Fehler beim Kopieren:', err);
                alert('‚ùå Fehler beim Kopieren in die Zwischenablage!');
            });
        }
        
        function generateDeckGrid(source) {
            if (source !== 'cityLeague') return;
            
            const deck = window.cityLeagueDeck;
            if (!deck || Object.keys(deck).length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            const modal = document.getElementById('imageViewModal');
            const grid = document.getElementById('compactCardGrid');
            const allCards = window.currentCityLeagueDeckCards || [];
            
            // Build a map of card data keyed by name
            const cardDataMap = {};
            allCards.forEach(card => {
                cardDataMap[card.card_name] = card;
            });
            
            // Convert deck to array with card data
            const deckCards = [];
            for (const [cardName, count] of Object.entries(deck)) {
                if (count <= 0) continue;
                
                const cardData = cardDataMap[cardName];
                if (!cardData) continue;
                
                deckCards.push({...cardData, deck_count_in_selected: count});
            }
            
            // Sort cards using the standard sorting function
            const sortedCards = sortCardsByType(deckCards);
            
            // Build grid HTML
            grid.innerHTML = sortedCards.map(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                const count = card.deck_count_in_selected || 1;
                const cardName = card.card_name || '';
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" title="${cardName} (${count}x)">
                            <img src="${imageUrl}" 
                                 alt="${cardName}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect width=%22245%22 height=%22342%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2218%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.8em; margin-bottom: 5px;">${cardName.substring(0, 15)}</div>
                                <div class="compact-badge" style="position: static;">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            modal.classList.add('show');
        }
        
        function closeImageView() {
            const modal = document.getElementById('imageViewModal');
            modal.classList.remove('show');
        }
        
        function showSingleCard(imageUrl, cardName) {
            const modal = document.getElementById('singleCardModal');
            const img = document.getElementById('singleCardImage');
            const title = document.getElementById('singleCardTitle');
            
            img.src = imageUrl;
            img.alt = cardName;
            if (title) {
                title.textContent = cardName;
            }
            
            modal.classList.add('show');
        }
        
        function closeSingleCard() {
            const modal = document.getElementById('singleCardModal');
            modal.classList.remove('show');
        }
        
        function autoComplete(source) {
            if (source !== 'cityLeague') return;
            
            const cards = window.currentCityLeagueDeckCards;
            if (!cards || cards.length === 0) {
                alert('Keine Karten zum Erg√§nzen!');
                return;
            }
            
            console.log('[autoComplete] Starting autoComplete');
            console.log('[autoComplete] Total available cards:', cards.length);
            
            // Get current deck state
            const deck = window.cityLeagueDeck || {};
            let currentTotal = Object.values(deck).reduce((sum, count) => sum + count, 0);
            
            if (currentTotal >= 60) {
                alert('Deck ist bereits voll (60 Karten)!');
                return;
            }
            
            // Ace Spec Identifikation: erst is_ace_spec Feld nutzen, dann Type fallback
            const isAceSpec = (card) => {
                // Prefer is_ace_spec field if available
                if (card.is_ace_spec !== undefined) {
                    const val = (card.is_ace_spec || '').toString().toLowerCase();
                    return val === 'yes' || val === 'true';
                }
                // Fallback: check type field
                const type = (card.type || card.card_type || '').toLowerCase();
                return type.includes('ace spec');
            };
            
            // Basis Energien Identifikation - d√ºrfen √∂fter als 4x sein
            const isBaseEnergy = (card) => {
                const type = (card.type || card.card_type || '').toLowerCase();
                return type === 'energy' && (card.card_name || '').match(/^(Fire|Water|Grass|Lightning|Psychic|Fighting|Darkness|Metal|Fairy|Dragon|Colorless|Neutral)\s+Energy$/i);
            };
            
            // Step 1: Deduplicate cards by card_name (keep highest percentage)
            const uniqueCards = {};
            for (const card of cards) {
                const cardName = card.card_name;
                
                if (!uniqueCards[cardName]) {
                    uniqueCards[cardName] = card;
                } else {
                    const newPercentage = parseFloat((card.percentage_in_archetype || '0').toString().replace(',', '.'));
                    const existingPercentage = parseFloat((uniqueCards[cardName].percentage_in_archetype || '0').toString().replace(',', '.'));
                    
                    if (newPercentage > existingPercentage) {
                        uniqueCards[cardName] = card;
                    }
                }
            }
            
            let deckCards = Object.values(uniqueCards);
            console.log('[autoComplete] After deduplication:', deckCards.length, 'unique cards');
            
            // Debug: Log all card types to understand structure
            const typeSet = new Set();
            deckCards.forEach(card => {
                const type = card.type || card.card_type || '';
                typeSet.add(type);
            });
            console.log('[autoComplete] Card types found:', Array.from(typeSet));
            
            // Step 2: Sort by percentage (descending)
            deckCards.sort((a, b) => {
                const percentageA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.'));
                const percentageB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.'));
                return percentageB - percentageA;
            });
            
            let cardsToAdd = [];
            const addedNames = new Set(Object.keys(deck).filter(name => deck[name] > 0));
            
            // Step 3: Find and add best Ace Spec (highest percentage) - only 1x
            let bestAceSpec = null;
            for (const card of deckCards) {
                if (isAceSpec(card)) {
                    bestAceSpec = card;
                    console.log('[autoComplete] Selected Ace Spec:', bestAceSpec.card_name);
                    break;
                }
            }
            
            if (bestAceSpec && !addedNames.has(bestAceSpec.card_name)) {
                cardsToAdd.push({ ...bestAceSpec, addCount: 1 });
                addedNames.add(bestAceSpec.card_name);
                currentTotal += 1;
                console.log('[autoComplete] Added Ace Spec (1x):', bestAceSpec.card_name);
            } else {
                console.log('[autoComplete] WARNING: No Ace Spec found or already in deck');
            }
            
            // Step 4: Add remaining cards from highest percentage downwards with average count
            // Skip cards with very low usage (< 5%) to avoid random tech cards
            const MINIMUM_PERCENTAGE_THRESHOLD = 5.0;
            
            for (const card of deckCards) {
                if (currentTotal >= 60) break;
                
                const cardName = card.card_name;
                
                // Skip if already added
                if (addedNames.has(cardName)) continue;
                
                // Skip Ace Spec cards (except the best one already added)
                if (isAceSpec(card)) continue;
                
                // Check percentage threshold - skip very low-usage cards (including wrong energy types)
                const percentage = parseFloat((card.percentage_in_archetype || '0').toString().replace(',', '.'));
                if (percentage < MINIMUM_PERCENTAGE_THRESHOLD) {
                    console.log('[autoComplete] Skipping low-usage card:', cardName, '(' + percentage.toFixed(2) + '% < 5%)');
                    continue;
                }
                
                // Calculate AVERAGE count for this card: total_count / total_decks_in_archetype
                const totalCount = parseFloat(card.total_count) || 1;
                const totalDecksInArchetype = parseFloat(card.total_decks_in_archetype) || 1;
                let addCount = Math.round(totalCount / totalDecksInArchetype);
                
                // For base energies, no limit. For other cards, max 4
                if (!isBaseEnergy(card)) {
                    addCount = Math.max(1, Math.min(addCount, 4));
                } else {
                    addCount = Math.max(1, addCount);
                }
                
                // Don't exceed deck limit (60 total cards)
                addCount = Math.min(addCount, 60 - currentTotal);
                
                if (addCount > 0) {
                    cardsToAdd.push({ ...card, addCount: addCount });
                    addedNames.add(cardName);
                    currentTotal += addCount;
                    console.log('[autoComplete] Adding:', addCount + 'x', cardName, '(' + percentage.toFixed(2) + '%, avg:', (totalCount/totalDecksInArchetype).toFixed(2) + ')');
                }
            }
            
            console.log('[autoComplete] Total cards to add:', currentTotal, 'in', cardsToAdd.length, 'unique entries');
            
            // Show summary grouped by type
            let summary = `Auto-Complete wird ${currentTotal} Karten hinzuf√ºgen:\n\n`;
            let pokemon = [], trainer = [], energy = [];
            
            cardsToAdd.forEach(card => {
                const cardType = card.type || card.card_type || '';
                const category = getCardTypeCategory(cardType);
                const line = `${card.addCount}x ${card.card_name}`;
                
                if (category === 'Pokemon') pokemon.push(line);
                else if (category === 'Energy') energy.push(line);
                else trainer.push(line);
            });
            
            if (pokemon.length > 0) summary += `Pok√©mon:\n${pokemon.join('\n')}\n\n`;
            if (trainer.length > 0) summary += `Trainer:\n${trainer.join('\n')}\n\n`;
            if (energy.length > 0) summary += `Energy:\n${energy.join('\n')}`;
            
            if (confirm(summary + '\n\nFortsetzung?')) {
                // Add all cards to deck
                cardsToAdd.forEach(card => {
                    for (let i = 0; i < card.addCount; i++) {
                        const globalPref = getGlobalRarityPreference();
                        const preferredVersion = getPreferredVersionForCard(card.card_name);
                        if (globalPref === 'auto') {
                            addCardToDeck('cityLeague', card.card_name);
                        } else if (preferredVersion) {
                            addCardToDeck('cityLeague', card.card_name, preferredVersion.set, preferredVersion.number);
                        } else {
                            addCardToDeck('cityLeague', card.card_name, card.set_code, card.set_number);
                        }
                    }
                });
                console.log('[autoComplete] Deck completed!');
                // Show the deck grid with images
                renderMyDeckGrid('cityLeague');
            }
        }
        
        function searchDeckCards() {
            const searchInput = document.getElementById('cityLeagueDeckCardSearch');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const resultsContainer = document.getElementById('cityLeagueDeckSearchResults');
            if (!resultsContainer) return;
            
            // Clear selection when search changes
            if (searchTerm !== window.lastCardSearch) {
                window.selectedCardName = null;
                window.lastCardSearch = searchTerm;
            }
            
            if (!searchTerm) {
                resultsContainer.innerHTML = '';
                window.selectedCardName = null;
                return;
            }
            
            // Search in ALL cards database
            const allAvailableCards = window.allCardsDatabase || [];
            
            // Debug logging
            if (allAvailableCards.length === 0) {
                console.warn('[searchDeckCards] allCardsDatabase is empty or not loaded yet');
                resultsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Kartendatenbank wird geladen...</div>';
                return;
            }
            
            // If a card name is selected, show all versions
            if (window.selectedCardName) {
                showCardVersions(window.selectedCardName, resultsContainer);
                return;
            }
            
            // STAGE 1: Show unique card names
            const matchingCards = allAvailableCards.filter(card => 
                card.name && card.name.toLowerCase().includes(searchTerm)
            );
            
            // Get unique card names
            const uniqueNames = [...new Set(matchingCards.map(c => c.name))].sort();
            
            console.log(`[searchDeckCards] Search term: "${searchTerm}", found ${uniqueNames.length} unique cards (${matchingCards.length} versions)`);
            
            if (uniqueNames.length === 0) {
                resultsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Keine Karten gefunden</div>';
                return;
            }
            
            // Build list of card names (limit to 20)
            const limitedNames = uniqueNames.slice(0, 20);
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 6px;">';
            
            limitedNames.forEach(cardName => {
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                const versionsCount = matchingCards.filter(c => c.name === cardName).length;
                const deck = window.cityLeagueDeck || {};
                const currentCount = deck[cardName] || 0;
                
                // Get first version for thumbnail image
                const firstVersion = matchingCards.find(c => c.name === cardName);
                const imageUrl = firstVersion ? buildCardImageUrl(firstVersion.set, firstVersion.number, firstVersion.rarity) : '';
                
                html += `
                    <div onclick="selectCardName('${cardNameEscaped}')" style="background: white; padding: 8px; border-radius: 4px; cursor: pointer; transition: all 0.2s; border-left: 2px solid #667eea; display: flex; gap: 8px; align-items: center;" onmouseover="this.style.background='#f9f9f9'; this.style.transform='translateX(3px)';" onmouseout="this.style.background='white'; this.style.transform='translateX(0)';">
                        <div style="width: 40px; height: 50px; background: #f5f5f5; border-radius: 3px; overflow: hidden; flex-shrink: 0;">
                            <img src="${imageUrl}" alt="${cardName}" style="width: 100%; height: 100%; object-fit: contain; cursor: zoom-in;" onerror="this.style.display='none';" loading="lazy">
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; color: #333; font-size: 0.9em; line-height: 1.2; white-space: normal; word-break: break-word;">${cardName}</div>
                            <div style="font-size: 0.75em; color: #999;">${versionsCount} Version${versionsCount > 1 ? 'en' : ''}</div>
                        </div>
                        ${currentCount > 0 ? `<div style="background: #28a745; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.75em; font-weight: bold; flex-shrink: 0;">${currentCount}x</div>` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            resultsContainer.innerHTML = html;
        }
        
        function selectCardName(cardName) {
            window.selectedCardName = cardName;
            searchDeckCards(); // Refresh to show versions
        }
        
        function showCardVersions(cardName, container) {
            const allCards = window.allCardsDatabase || [];
            const versions = allCards.filter(c => c.name === cardName);
            
            const deck = window.cityLeagueDeck || {};
            
            // Calculate total count of all versions of this card in deck
            let totalCount = 0;
            for (const [key, count] of Object.entries(deck)) {
                if (key.startsWith(cardName + ' (') || key === cardName) {
                    totalCount += count;
                }
            }
            
            let html = '<div style="grid-column: 1 / -1; background: #f8f9fa; padding: 10px; border-radius: 8px; margin-bottom: 10px;">';
            html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
            html += `<div style="font-weight: bold; color: #333;">üé¥ ${cardName}</div>`;
            html += `<button onclick="window.selectedCardName=null; searchDeckCards();" style="background: #6c757d; color: white; border: none; padding: 5px 15px; border-radius: 5px; cursor: pointer; font-size: 0.85em;">‚Üê Zur√ºck</button>`;
            html += '</div>';
            html += `<div style="font-size: 0.85em; color: #666; margin-top: 8px;">${versions.length} Versionen | ${totalCount}x im Deck</div>`;
            html += '</div>';
            
            // Add card versions directly - they will be grid items in the parent grid
            versions.forEach(card => {
                const setCode = card.set || '';
                const setNumber = card.number || '';
                const rarityFull = card.rarity || '';
                
                // Check if THIS specific version is in the deck
                const deckKey = `${cardName} (${setCode} ${setNumber})`;
                const versionCount = deck[deckKey] || 0;
                
                // Try to build image URL - fallback to placeholder
                const imageUrl = buildCardImageUrl(setCode, setNumber, rarityFull);
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                
                html += `
                    <div style="position: relative; text-align: center; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.15); transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='scale(1.03)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.25)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 6px rgba(0,0,0,0.15)';">
                        <div style="position: relative; cursor: zoom-in; background: #f5f5f5;" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped} (${setCode} ${setNumber})')">
                            <img src="${imageUrl}" alt="${cardName}" style="width: 100%; height: 160px; object-fit: contain;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" loading="lazy">
                            <div style="display: none; width: 100%; height: 160px; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; flex-direction: column; padding: 8px;">
                                <div style="font-size: 2em; margin-bottom: 5px;">üÉè</div>
                                <div style="font-size: 0.7em; text-align: center;">${setCode}<br>${setNumber}</div>
                            </div>
                        </div>
                        ${versionCount > 0 ? `<div style="position: absolute; top: 4px; left: 4px; background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.75em; font-weight: bold; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${versionCount}</div>` : ''}
                        <button onclick="addCardToDeck('cityLeague', '${cardNameEscaped}', '${setCode}', '${setNumber}')" style="position: absolute; top: 4px; right: 4px; background: #28a745; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.3); z-index: 10; transition: all 0.2s;" onmouseover="this.style.transform='scale(1.1)'; this.style.background='#218838';" onmouseout="this.style.transform='scale(1)'; this.style.background='#28a745';" title="Zum Deck hinzuf√ºgen">+</button>
                        <div style="padding: 8px; background: white; border-top: 1px solid #f0f0f0;">
                            <div style="font-size: 0.7em; color: #666; font-weight: 600;">${setCode} ${setNumber}</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function buildCardImageUrl(setCode, setNumber, rarity) {
            // Build Limitless CDN URL with fallback patterns
            // Pattern: https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpci/{SET}/{SET}_{NUMBER}_R_EN_LG.png
            
            if (!setCode || !setNumber) {
                return 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect fill=%22%23667eea%22 width=%22245%22 height=%22342%22/%3E%3Ctext fill=%22white%22 x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 font-size=%2220%22%3EKeine Daten%3C/text%3E%3C/svg%3E';
            }
            
            // Determine rarity code
            let rarityCode = 'R'; // Default to Rare
            if (rarity) {
                const r = rarity.toLowerCase();
                if (r.includes('uncommon')) rarityCode = 'U';
                else if (r.includes('common') && !r.includes('uncommon')) rarityCode = 'C';
                else if (r.includes('holo')) rarityCode = 'R';
            }
            
            // Pad numeric card numbers to 3 digits (86 -> 086, TG24 stays TG24)
            let paddedNumber = setNumber;
            if (/^\d+$/.test(setNumber)) {
                paddedNumber = setNumber.padStart(3, '0');
            }
            
            // Build URL: MEG_086_R_EN_LG.png
            return `https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpci/${setCode}/${setCode}_${paddedNumber}_${rarityCode}_EN_LG.png`;
        }
        
        // Initialize deck card search listener
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('cityLeagueDeckCardSearch');
            if (searchInput) {
                searchInput.addEventListener('input', searchDeckCards);
            }
        });

        function toggleDeckGridCompact() {
            const grid = document.getElementById('cityLeagueMyDeckGrid');
            const btn = document.getElementById('deckGridToggleBtn');
            if (!grid || !btn) return;
            
            if (grid.classList.contains('mobile-compact-grid')) {
                grid.classList.remove('mobile-compact-grid');
                btn.textContent = 'üì∏ Kompakt';
                btn.style.background = '#6c757d';
            } else {
                grid.classList.add('mobile-compact-grid');
                btn.textContent = 'üìä Normal';
                btn.style.background = '#28a745';
            }
        }

        function toggleCurrentCards() {
            const content = document.getElementById('currentCardsContent');
            const toggle = document.getElementById('currentCardsToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }

        function togglePastCards() {
            const content = document.getElementById('pastCardsContent');
            const toggle = document.getElementById('pastCardsToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }

        // Filter functions
        function filterCurrentAnalysisCards() {
            const searchTerm = (document.getElementById('currentCardSearchInput')?.value || '').toLowerCase();
            const rows = document.querySelectorAll('#currentAnalysisTable table tbody tr');
            let visibleCount = 0;

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const visible = text.includes(searchTerm);
                row.style.display = visible ? '' : 'none';
                if (visible) visibleCount += 1;
            });

            const countEl = document.getElementById('currentCardCount');
            if (countEl) {
                countEl.textContent = `${visibleCount} Karten`;
            }
        }

        function filterPastMetaCards() {
            const searchTerm = (document.getElementById('pastCardSearchInput')?.value || '').toLowerCase();
            const rows = document.querySelectorAll('#pastMetaTable table tbody tr');
            let visibleCount = 0;

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const visible = text.includes(searchTerm);
                row.style.display = visible ? '' : 'none';
                if (visible) visibleCount += 1;
            });

            const countEl = document.getElementById('pastCardCount');
            if (countEl) {
                countEl.textContent = `${visibleCount} Karten`;
            }
        }

        // Deck Builder functions (placeholder implementations)
        const deckBuilders = {
            cityLeague: [],
            current: [],
            past: []
        };

        // Toggle for Current Meta cards
        // Load Current Meta
        async function loadCurrentMeta() {
            const currentMetaContent = document.getElementById('currentMetaContent');
            
            try {
                const response = await fetch(BASE_PATH + 'data/limitless_online_decks_comparison.html');
                if (!response.ok) throw new Error('HTML nicht gefunden');
                
                const html = await response.text();
                
                // Parse the loaded HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Extract the container content
                const container = doc.querySelector('.container');
                if (container) {
                    // Get everything after the h1 title
                    const contentDivs = Array.from(container.children).slice(1);
                    
                    // Create a wrapper for styling
                    const wrapper = document.createElement('div');
                    wrapper.className = 'limitless-comparison';
                    
                    // Add content to wrapper
                    contentDivs.forEach(el => {
                        const clone = el.cloneNode(true);
                        wrapper.appendChild(clone);
                    });
                    
                    // Clear and set content
                    currentMetaContent.innerHTML = '';
                    currentMetaContent.appendChild(wrapper);
                } else {
                    currentMetaContent.innerHTML = '<div style="color: #e74c3c; padding: 20px;">Fehler beim Laden der Vergleichsdaten</div>';
                }
                
                window.currentMetaLoaded = true;
            } catch (error) {
                console.error('Error loading Current Meta:', error);
                currentMetaContent.innerHTML = `
                    <div style="color: #e74c3c; padding: 20px;">
                        <strong>Fehler:</strong> Die Vergleichs-HTML konnte nicht geladen werden.
                        <br><small>${error.message}</small>
                    </div>
                `;
            }
        }

        
        // Load Current Analysis
        async function loadCurrentAnalysis() {
            const tableContainer = document.getElementById('currentAnalysisTable');
            const data = await loadCSV('current_meta_card_data.csv');
            
            if (data) {
                renderDeckAnalysisTable(data, tableContainer, 'currentCardCount', 'currentCardCountSummary');
                window.currentAnalysisLoaded = true;
            } else if (tableContainer) {
                tableContainer.innerHTML = '<div class="error">current_meta_card_data.csv nicht gefunden</div>';
            }
        }
        
        // Load Past Meta
        async function loadPastMeta() {
            const tableContainer = document.getElementById('pastMetaTable');
            const data = await loadCSV('tournament_cards_data_cards.csv');
            
            if (data) {
                renderDeckAnalysisTable(data, tableContainer, 'pastCardCount', 'pastCardCountSummary');
                window.pastMetaLoaded = true;
            } else if (tableContainer) {
                tableContainer.innerHTML = '<div class="error">tournament_cards_data_cards.csv nicht gefunden</div>';
            }
        }

        // Generic function to render deck analysis tables
        function renderDeckAnalysisTable(data, container, countElementId, summaryElementId) {
            if (!container || !data || data.length === 0) return;

            const headers = Object.keys(data[0]);
            let html = '<table><thead><tr>';
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';

            data.forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    html += `<td>${row[header]}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;

            const countEl = document.getElementById(countElementId);
            const summaryEl = document.getElementById(summaryElementId);
            if (countEl && summaryEl) {
                countEl.textContent = `${data.length} Karten`;
                summaryEl.textContent = `/ ${data.length} Total`;
            }
        }
        
        // Load Cards
        let allCards = [];
        async function loadCards() {
            const content = document.getElementById('cardsContent');
            
            // Try to load all card data sources
            const cityLeague = await loadCSV('city_league_analysis.csv');
            const currentMeta = await loadCSV('current_meta_card_data.csv');
            const pastMeta = await loadCSV('tournament_cards_data_cards.csv');
            
            if (cityLeague || currentMeta || pastMeta) {
                allCards = [];
                
                if (cityLeague) allCards = allCards.concat(cityLeague);
                if (currentMeta) allCards = allCards.concat(currentMeta);
                if (pastMeta) allCards = allCards.concat(pastMeta);
                
                renderTable(allCards, 'cardsContent', 'üß∞ Combined Card Database');
                window.cardsLoaded = true;
            } else {
                content.innerHTML = '<div class="error">Fehler beim Laden der Kartendaten</div>';
            }
        }
        
        function filterCards() {
            const searchTerm = document.getElementById('cardSearch').value.toLowerCase();
            const tables = document.querySelectorAll('#cardsContent table tbody');
            
            tables.forEach(tbody => {
                const rows = tbody.querySelectorAll('tr');
                rows.forEach(row => {
                    const text = row.textContent.toLowerCase();
                    row.style.display = text.includes(searchTerm) ? '' : 'none';
                });
            });
        }
        
        // Rarity Switcher Functions
        let currentRaritySwitcherCard = null;

        function openRaritySwitcher(cardName, deckKey) {
            if (!window.allCardsDatabase) {
                alert('Karten-Datenbank noch nicht geladen...');
                return;
            }

            // Extract card name from deckKey if needed (handle "CardName (SET NUM)" format)
            const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
            const actualCardName = baseNameMatch ? baseNameMatch[1] : cardName;
            
            // Extract set and number from deckKey (e.g., "Boss's Orders (RCL 189)" -> set="RCL", number="189")
            const setNumMatch = deckKey.match(/\(([A-Z0-9]+)\s+(\d+[A-Z]*)\)/);
            let currentSet = '';
            let currentNumber = '';
            if (setNumMatch) {
                currentSet = setNumMatch[1];
                currentNumber = setNumMatch[2];
            }
            
            console.log(`[openRaritySwitcher] cardName: ${cardName}, deckKey: ${deckKey}, actualCardName: ${actualCardName}`);

            currentRaritySwitcherCard = { cardName: actualCardName, deckKey };
            
            // Find current card's data
            let currentCard = null;
            if (currentSet && currentNumber) {
                currentCard = window.allCardsDatabase.find(c => 
                    c.name === actualCardName && c.set === currentSet && c.number === currentNumber
                );
            }
            
            // Determine if this is a Pokemon card or Trainer/Energy card
            // Trainer/Energy types: Supporter, Item, Stadium, Tool, Energy, Special Energy, Basic Energy
            const trainerEnergyTypes = ['Supporter', 'Item', 'Stadium', 'Tool', 'Energy', 'Special Energy', 'Basic Energy'];
            const isPokemonCard = currentCard && currentCard.type && !trainerEnergyTypes.includes(currentCard.type);
            
            // Find all versions based on card type
            let versions = [];
            
            if (isPokemonCard) {
                // POKEMON CARDS: Use international_prints from Limitless "Int. Prints" table
                // This is THE definitive source - shows ALL functionally identical cards
                // regardless of artwork, illustrator, or set
                if (currentCard && currentCard.international_prints) {
                    // Parse the comma-separated list of international prints
                    // Format: "ASC-113,MEG-77,MEG-160,MEG-179,MEG-188,MPROMO-12"
                    const intPrintIds = currentCard.international_prints.split(',').map(s => s.trim());
                    const intPrintSet = new Set(intPrintIds);
                    
                    // Find all cards that match any of these set-number combinations
                    versions = window.allCardsDatabase.filter(card => {
                        const cardId = `${card.set}-${card.number}`;
                        return intPrintSet.has(cardId) && card.name === actualCardName;
                    });
                    
                    console.log(`[Pokemon Card] Found ${versions.length} international prints from Limitless data`);
                    console.log(`[Pokemon Card] Int. Print IDs:`, intPrintIds);
                } else {
                    // No international_prints data available - show only current card
                    versions = currentCard ? [currentCard] : [];
                    console.warn(`[Pokemon Card] No international_prints data available, showing only current version`);
                    if (versions.length === 1 && currentCard) {
                        alert(`‚ö†Ô∏è International Print Daten f√ºr diese Karte noch nicht verf√ºgbar.\n\nBitte All Cards Scraper neu laufen lassen mit international_prints Support.`);
                    }
                }
            } else {
                // TRAINER/ENERGY CARDS: Use name-based matching
                // All versions with same name are functionally identical (reprints)
                if (window.cardsByNameMap && window.cardsByNameMap[actualCardName]) {
                    versions = window.cardsByNameMap[actualCardName].slice();
                    console.log(`[Trainer/Energy] Found ${versions.length} reprints via name matching`);
                } else if (window.allCardsDatabase) {
                    versions = window.allCardsDatabase.filter(card => card.name === actualCardName);
                    console.log(`[Trainer/Energy] Found ${versions.length} reprints via direct search`);
                } else {
                    versions = currentCard ? [currentCard] : [];
                }
            }
            
            // Filter to English sets only if we have the set mapping
            if (window.englishSetCodes && window.englishSetCodes.size > 0) {
                versions = versions.filter(version => window.englishSetCodes.has(version.set));
                console.log(`[openRaritySwitcher] After English filter: ${versions.length} versions`);
            }
            
            if (versions.length === 0) {
                alert(`Keine Versionen f√ºr "${actualCardName}" gefunden.\n\nM√∂gliche Gr√ºnde:\n- Karte nicht in all_cards_database.csv\n- Falscher Kartenname\n- Nur japanische Sets verf√ºgbar\n\nGesuchter Name: "${actualCardName}"`);
                console.error(`[openRaritySwitcher] No versions found for "${actualCardName}". Available cards:`, Object.keys(window.cardsByNameMap || {}).slice(0, 10));
                return;
            }

            // Build rarity options
            const optionsList = document.getElementById('rarityOptionsList');
            optionsList.innerHTML = '';

            versions.forEach(version => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'rarity-option-card';
                
                // Check if this is the current version
                const versionKey = `${actualCardName} (${version.set} ${version.number})`;
                if (deckKey === versionKey) {
                    optionDiv.classList.add('selected');
                }
                
                optionDiv.onclick = () => selectRarityVersion(version.set, version.number, deckKey, actualCardName);
                
                let imageHtml = '';
                const imageUrl = version.image_url || buildCardImageUrl(version.set, version.number, version.rarity);
                imageHtml = `<img src="${imageUrl}" alt="${actualCardName} - ${version.rarity}" loading="lazy">`;
                
                const rarityBadgeColor = getRarityColor(version.rarity);
                
                optionDiv.innerHTML = `
                    ${imageHtml}
                    <div class="rarity-option-info">
                        <div><strong>${version.set} ${version.number}</strong></div>
                        <div style="font-size: 11px; color: #999;">Rarity: ${version.rarity || 'N/A'}</div>
                    </div>
                    <div class="rarity-badge" style="background-color: ${rarityBadgeColor};">
                        ${version.rarity || 'Unknown'}
                    </div>
                `;
                
                optionsList.appendChild(optionDiv);
            });

            document.getElementById('raritySwitcherTitle').textContent = `${actualCardName} - Rarity Switcher`;
            const modal = document.getElementById('raritySwitcherModal');
            modal.classList.add('show');
        }

        function selectRarityVersion(setCode, setNumber, oldDeckKey, cardName) {
            if (!window.cityLeagueDeck) return;

            // Extract card name from oldDeckKey if needed
            const match = oldDeckKey.match(/^(.+?)\s*\(/);
            const actualCardName = cardName || (match ? match[1] : oldDeckKey);
            
            // Create new key with new version
            const newKey = `${actualCardName} (${setCode} ${setNumber})`;
            
            // Get current count for this card
            const currentCount = window.cityLeagueDeck[oldDeckKey] || 0;
            
            if (currentCount > 0) {
                // Remove from old key
                delete window.cityLeagueDeck[oldDeckKey];
                
                // Add to new key
                window.cityLeagueDeck[newKey] = currentCount;

                // Save preference
                setRarityPreference(actualCardName, { mode: 'specific', set: setCode, number: setNumber });
                
                // Refresh the grid display
                renderMyDeckGrid('cityLeague');
            }

            closeRaritySwitcher();
        }

        function closeRaritySwitcher() {
            const modal = document.getElementById('raritySwitcherModal');
            modal.classList.remove('show');
            currentRaritySwitcherCard = null;
        }

        function getRarityColor(rarity) {
            const colors = {
                'Common': '#A0A0A0',
                'Uncommon': '#6B8E23',
                'Rare': '#DAA520',
                'Holo Rare': '#FFD700',
                'Double Rare': '#FF6B9D',
                'Double Rare Holo': '#FF1493',
                'Secret Rare': '#8B008B',
                'Secret Rare Gold': '#FF8C00'
            };
            return colors[rarity] || '#CCCCCC';
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const lastUpdate = localStorage.getItem('lastScraperUpdate') || new Date().toLocaleDateString('de-DE');
            document.getElementById('last-update').textContent = lastUpdate;
            
            // Load all cards database for deck builder
            loadAllCardsDatabase();
            loadSetMapping();
            loadRarityPreferences();
            updateGenerateDeckButtonLabel();
            
            // Load first tab automatically
            loadCityLeagueData();
            window.cityLeagueLoaded = true;
        });
    </script>
    
    <!-- Image View Modal -->
    <div id="imageViewModal" class="image-view-modal" onclick="if(event.target === this) closeImageView()">
        <div class="image-view-content">
            <div class="image-view-header">
                <h3>üé® Deck Karten √úbersicht</h3>
                <button class="image-view-close" onclick="closeImageView()">‚úï</button>
            </div>
            <div id="compactCardGrid" class="compact-card-grid"></div>
        </div>
    </div>
    
    <!-- Single Card View Modal -->
    <div id="singleCardModal" class="single-card-modal" onclick="if(event.target === this) closeSingleCard()">
        <div class="single-card-modal-content">
            <button class="single-card-close" onclick="closeSingleCard()">‚úï</button>
            <img id="singleCardImage" src="" alt="" referrerpolicy="no-referrer">
        </div>
    </div>

    <!-- Rarity Switcher Modal -->
    <div id="raritySwitcherModal" class="rarity-switcher-modal" onclick="if(event.target === this) closeRaritySwitcher()">
        <div class="rarity-switcher-modal-content">
            <span class="rarity-switcher-close" onclick="closeRaritySwitcher()">‚úï</span>
            <h2 id="raritySwitcherTitle">Karte - Rarity Switcher</h2>
            
            <div id="rarityOptionsList" class="rarity-options-list">
                <!-- Wird dynamisch gef√ºllt -->
            </div>
            
        </div>
    </div>
</body>
</html>
