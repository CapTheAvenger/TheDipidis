<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <link rel="icon" href="data:,">
    <title>Pokemon TCG Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html { scroll-behavior: smooth; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            min-height: -webkit-fill-available;
            padding: 20px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            padding: 30px 20px;
        }
        
        .header h1 {
            font-size: clamp(1.5em, 6vw, 2.5em);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.95;
        }
        
        .tabs-container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 30px;
            overflow: hidden;
        }
        
        .tab-navigation {
            display: flex;
            gap: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 15px;
            flex-wrap: nowrap;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
        }
        
        .tab-btn {
            padding: 12px 16px;
            border: none;
            background: rgba(255,255,255,0.2);
            color: white;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: max(13px, 0.9em);
            white-space: nowrap;
            flex-shrink: 0;
            min-height: 44px;
        }
        
        .tab-btn:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .tab-btn.active {
            background: white;
            color: #667eea;
        }
        
        .tab-content {
            display: none;
            padding: 30px;
            background: white;
            min-height: 400px;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .tab-content h1 {
            color: #333;
            margin-bottom: 30px;
            text-shadow: none;
            text-align: center;
            font-size: clamp(1.3em, 4vw, 2em);
        }
        
        .tab-content h2 {
            color: #34495e;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
            margin-top: 30px;
            font-size: clamp(1.1em, 3vw, 1.5em);
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #999;
            font-size: 16px;
        }
        
        .error {
            background: #ffe6e6;
            border-left: 4px solid #e74c3c;
            color: #e74c3c;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 20px 0;
            display: block;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        
        table thead, table tbody {
            display: table;
            width: 100%;
            table-layout: fixed;
        }
        
        table thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        table th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            font-size: max(14px, 0.95em);
        }
        
        table td {
            padding: 12px;
            border-bottom: 1px solid #ecf0f1;
            font-size: max(14px, 0.9em);
        }
        
        table tbody tr:hover {
            background: #f8f9fa;
        }
        
        .metadata {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 30px;
            text-align: center;
            font-weight: bold;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .stat-card h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .stat-card .value {
            font-size: clamp(1.8em, 5vw, 2.5em);
            font-weight: bold;
            margin: 10px 0;
        }
        
        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(300px, 100%), 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .trend {
            font-weight: bold;
        }
        
        .trend.improved { color: #27ae60; }
        .trend.declined { color: #e67e22; }
        .trend.stable { color: #95a5a6; }
        
        .change {
            font-weight: bold;
        }
        
        .change.positive { color: #27ae60; }
        .change.negative { color: #e74c3c; }
        
        .search-box {
            margin: 20px 0;
        }
        
        .search-box input {
            width: 100%;
            max-width: 400px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: max(15px, 1em);
            -webkit-appearance: none;
            appearance: none;
        }
        
        .search-box input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        /* Card Search Input - einheitliches Styling */
        .card-search-input {
            width: 100%;
            max-width: 500px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: max(16px, 1em);
            -webkit-appearance: none;
            appearance: none;
            box-sizing: border-box;
        }
        
        .card-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .footer {
            text-align: center;
            color: white;
            padding: 20px;
            margin-top: 30px;
        }

        .analysis-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .analysis-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .analysis-header h1 {
            font-size: clamp(1.5em, 5vw, 2.5em);
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .analysis-header p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 3px solid #667eea;
        }

        .control-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            flex: 1;
            min-width: min(200px, 100%);
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .control-group select,
        .control-group input[type="text"] {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: max(16px, 1em);
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .control-group select:focus,
        .control-group input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .cards-section {
            padding: 30px;
            background: #f8f9fa;
        }

        .cards-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .card-search-input {
            width: 100%;
            max-width: 500px;
            padding: 10px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
        }

        .card-search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .cards-table {
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .city-league-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .city-league-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .city-league-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* Deck Visual Styles */
        .deck-visual {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .deck-visual h3 {
            margin-bottom: 20px;
            color: #333;
            text-align: center;
            font-size: 1.5em;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            padding: 10px;
        }
        
        .card-visual {
            position: relative;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: transform 0.2s, box-shadow 0.2s;
            cursor: pointer;
            background: #f0f0f0;
        }
        
        .card-visual:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        
        .card-visual img {
            width: 90px;
            height: 126px;
            display: block;
            object-fit: cover;
        }
        
        .card-visual .card-count-badge {
            position: absolute;
            top: 3px;
            right: 3px;
            background: #dc3545;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 11px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
            z-index: 2;
        }

        /* Deck Builder Styles */
        .deck-builder {
            padding: 30px;
            background: white;
            border-top: 3px solid #667eea;
        }
        
        .deck-builder h2 {
            margin-bottom: 20px;
            color: #333;
        }
        
        .builder-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .rarity-pref-group {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            padding: 4px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .rarity-pref-btn {
            background: #ffffff;
            color: #333;
            border: 1px solid #d1d5db;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
        }

        .rarity-pref-btn.active {
            background: #ffc107;
            border-color: #e0a800;
            color: #333;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .deck-summary {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .deck-summary h3 {
            margin: 0;
            color: #333;
        }

        .deck-list {
            background: white;
            border-radius: 10px;
            padding: 20px;
            min-height: 200px;
        }

        .cards-table-header {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.3s;
        }

        .cards-table-header:hover {
            background: #e9ecef;
        }

        .cards-header-left {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .cards-toggle {
            display: inline-block;
            width: 24px;
            height: 24px;
            margin-right: 10px;
            cursor: pointer;
            font-size: 20px;
            line-height: 24px;
            transition: transform 0.3s ease;
        }

        /* Pokéball icon - open state */
        .cards-toggle::before {
            content: '⚫';
            color: #667eea;
        }

        /* Pokéball icon - closed state */
        .cards-toggle.collapsed::before {
            content: '⚪';
            color: #667eea;
        }

        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-card .label {
            opacity: 0.9;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .stat-card .value {
            font-size: 2em;
            font-weight: bold;
        }

        /* Matchups */
        .matchups-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        
        /* Deck Visual */
        .deck-visual {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .deck-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .deck-card {
            position: relative;
            width: 100%;
            padding-bottom: 140%;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            cursor: pointer;
            min-width: 150px; /* Increased min width for better button visibility */
        }
        
        .deck-card:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .deck-card img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .card-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
            padding: 5px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }
        
        .card-count {
            background: #667eea;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .card-percentage {
            color: white;
            font-weight: bold;
            font-size: 0.8em;
        }
        
        .card-max-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc3545;
            color: white;
            padding: 2px 6px;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.7em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 2;
        }
        
        .card-in-deck-count {
            position: absolute;
            top: 5px;
            left: 5px;
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.7em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            z-index: 2;
        }
        
        /* Card Database Styles */
        .card-database-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            padding: 10px;
        }
        
        .card-database-item {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        
        .card-database-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
        }
        
        .card-database-item img {
            width: 100%;
            height: auto;
            cursor: pointer;
            display: block;
        }
        
        .card-database-info {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .card-database-name {
            font-weight: 700;
            font-size: 14px;
            color: #2c3e50;
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .card-database-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .card-database-set {
            font-weight: 600;
            background: #ecf0f1;
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .card-database-type {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: #e8f5e9;
            color: #2e7d32;
        }
        
        .card-database-rarity {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 700;
            margin-top: 4px;
        }
        
        .rarity-common { background: #95a5a6; color: white; }
        .rarity-uncommon { background: #16a085; color: white; }
        .rarity-rare { background: #f39c12; color: white; }
        .rarity-holo { background: #9b59b6; color: white; }
        .rarity-double { background: #e74c3c; color: white; }
        .rarity-triple { background: #c0392b; color: white; }
        .rarity-ultra { background: #2c3e50; color: white; }
        .rarity-secret { background: linear-gradient(45deg, #f39c12, #e74c3c); color: white; }
        .rarity-rainbow { background: linear-gradient(90deg, red, orange, yellow, green, blue, indigo, violet); color: white; }
        .rarity-art { background: #8e44ad; color: white; }
        .rarity-special-art { background: #c0392b; color: white; }
        .rarity-char-holo { background: #3498db; color: white; }
        .rarity-char-super { background: #2980b9; color: white; }
        .rarity-radiant { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; }
        .rarity-shiny { background: linear-gradient(135deg, #ffd700 0%, #ffed4e 100%); color: #2c3e50; }
        .rarity-shiny-ultra { background: linear-gradient(135deg, #bdc3c7 0%, #2c3e50 100%); color: white; }
        .rarity-promo { background: #e67e22; color: white; }
        
        .card-database-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .card-database-btn {
            flex: 1;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            text-decoration: none;
            display: inline-block;
        }
        
        .card-database-btn-rarity {
            background: #667eea;
            color: white;
        }
        
        .card-database-btn-rarity:hover {
            background: #5568d3;
        }
        
        .card-database-btn-market {
            background: #f39c12;
            color: white;
        }
        
        .card-database-btn-market:hover {
            background: #e67e22;
        }

        
        /* .card-deck-count removed as per user request */

        @media (max-width: 768px) {
            .matchups-grid {
                grid-template-columns: 1fr !important;
            }
            
            .deck-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
            }
            
            .card-database-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
                gap: 15px;
            }
            
            .filter-section > div:first-child {
                grid-template-columns: 1fr !important;
            }
        }

        /* Image View Modal */
        .image-view-modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            overflow: auto;
        }

        .image-view-modal.show {
            display: block;
        }

        .image-view-content {
            background-color: #fff;
            margin: 2% auto;
            padding: 30px;
            width: 95%;
            max-width: 1400px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .image-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .image-view-header h3 {
            margin: 0;
            color: #333;
            font-size: 1.8em;
        }

        .image-view-close {
            background: #e74c3c;
            color: white;
            border: none;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .image-view-close:hover {
            background: #c0392b;
            transform: rotate(90deg);
        }

        .compact-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 12px;
            padding: 20px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 10px;
        }

        .compact-card {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            aspect-ratio: 245/342;
        }

        .compact-card:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .compact-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .compact-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-weight: bold;
            font-size: 14px;
            padding: 4px 8px;
            border-radius: 50%;
            min-width: 24px;
            text-align: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .image-view-content {
                width: 98%;
                padding: 15px;
                margin: 5% auto;
            }

            .compact-card-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
                padding: 10px;
            }

            /* Mobile Compact Grid - für Screenshot ohne Scrollen */
            .mobile-compact-grid {
                grid-template-columns: repeat(10, 1fr) !important;
                gap: 3px !important;
                padding: 5px !important;
            }

            .mobile-compact-grid .compact-card {
                aspect-ratio: 245/342;
                border-radius: 3px;
            }

            .mobile-compact-grid .compact-badge {
                font-size: 8px !important;
                padding: 1px 3px !important;
                min-width: 14px !important;
                top: 2px;
                right: 2px;
            }

            .compact-badge {
                font-size: 11px;
                padding: 2px 6px;
                min-width: 20px;
            }
        }

        /* Single Card View Modal */
        .single-card-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            overflow: auto;
            animation: fadeIn 0.3s ease;
        }

        .single-card-modal.show {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .single-card-modal-content {
            position: relative;
            max-width: 90%;
            max-height: 90vh;
            animation: zoomIn 0.3s ease;
        }

        .single-card-modal-content img {
            width: auto;
            height: auto;
            max-width: 100%;
            max-height: 90vh;
            border-radius: 15px;
            box-shadow: 0 10px 50px rgba(0, 0, 0, 0.5);
        }

        .single-card-close {
            position: absolute;
            top: -40px;
            right: 0;
            background: #e74c3c;
            color: white;
            border: none;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .single-card-close:hover {
            background: #c0392b;
            transform: rotate(90deg) scale(1.1);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes zoomIn {
            from {
                transform: scale(0.7);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .single-card-modal-content {
                max-width: 95%;
            }

            .single-card-close {
                top: 10px;
                right: 10px;
                width: 40px;
                height: 40px;
                font-size: 24px;
            }
        }

        /* Rarity Switcher Modal Styles */
        .rarity-switcher-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            animation: fadeIn 0.3s ease-in-out;
        }

        .rarity-switcher-modal.show {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .rarity-switcher-modal-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 90%;
            max-height: 85vh;
            overflow-y: auto;
            animation: slideUp 0.3s ease-in-out;
        }

        .rarity-switcher-modal h2 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #333;
            font-size: 24px;
            text-align: center;
        }

        .rarity-options-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .rarity-option-card {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            background-color: #f9f9f9;
        }

        .rarity-option-card:hover {
            border-color: #4CAF50;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
            transform: translateY(-2px);
        }

        .rarity-option-card.selected {
            border-color: #4CAF50;
            background-color: #e8f5e9;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .rarity-option-card img {
            width: 100%;
            max-width: 150px;
            height: auto;
            margin-bottom: 8px;
            border-radius: 4px;
        }


        .rarity-option-info {
            font-size: 12px;
            color: #666;
            margin: 5px 0;
            line-height: 1.4;
        }

        .rarity-badge {
            display: inline-block;
            background-color: #FDB927;
            color: #333;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            margin-top: 5px;
        }

        .rarity-switcher-modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .rarity-switcher-modal-buttons button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }

        .rarity-switcher-modal-buttons .mixed-rarity-btn {
            background-color: #ffc107;
            color: #333;
        }

        .rarity-switcher-modal-buttons .reset-rarity-btn {
            background-color: #6c757d;
        }

        .rarity-switcher-modal-buttons button:hover {
            background-color: #45a049;
        }

        .rarity-switcher-modal-buttons button:active {
            transform: scale(0.98);
        }

        .rarity-switcher-close {
            position: absolute;
            right: 15px;
            top: 15px;
            font-size: 28px;
            font-weight: bold;
            color: #aaa;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .rarity-switcher-close:hover {
            color: #000;
        }

        .rarity-switcher-modal-content {
            position: relative;
        }

        @media (max-width: 768px) {
            .rarity-switcher-modal-content {
                max-width: 95%;
                max-height: 90vh;
                padding: 20px;
            }

            .rarity-options-list {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
            }

            .rarity-switcher-modal-buttons {
                flex-direction: column;
            }

            .rarity-switcher-modal-buttons button {
                width: 100%;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Cardmarket Button Styles */
        .btn-cardmarket {
            background: linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            text-decoration: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .btn-cardmarket:hover {
            transform: scale(1.05);
            box-shadow: 0 2px 8px rgba(255, 107, 53, 0.4);
        }

        .btn-cardmarket:active {
            transform: scale(0.95);
        }

        .btn-cardmarket.no-price {
            background: linear-gradient(135deg, #777 0%, #999 100%);
            cursor: not-allowed;
            opacity: 0.9;
        }

        .compact-card-price {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .rarity-option-cardmarket {
            margin-top: 8px;
            width: 100%;
            font-size: 10px;
            padding: 6px 8px;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        /* =========================
           MOBILE OPTIMIZATIONS
           ========================= */
        
        /* Medium Mobile Devices (Tablets & Large Phones) */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .header p {
                font-size: 1em;
            }

            .tab-content {
                padding: 15px;
            }

            .stat-card .value {
                font-size: 2em;
            }

            table {
                font-size: 0.9em;
            }

            table th, table td {
                padding: 8px 5px;
            }
        }

        /* Small Mobile Devices (Most Smartphones) */
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            .container {
                max-width: 100%;
            }

            .header {
                padding: 20px 10px;
                margin-bottom: 15px;
            }

            .header h1 {
                font-size: 1.5em;
                margin-bottom: 5px;
            }

            .header p {
                font-size: 0.9em;
            }

            .tabs-container {
                border-radius: 10px;
            }

            .tab-navigation {
                padding: 10px;
                gap: 8px;
            }

            .tab-btn {
                padding: 10px 12px;
                font-size: 12px;
                min-height: 44px; /* Touch-Target Mindestgröße */
            }

            .tab-content {
                padding: 10px;
                min-height: 300px;
            }

            .stat-card {
                padding: 15px;
            }

            .stat-card .value {
                font-size: 1.8em;
            }

            /* Controls auf Mobile optimieren */
            .controls {
                padding: 15px;
            }

            /* Control-Row: Vertical Stacking auf Mobile */
            .control-row {
                flex-direction: column;
                gap: 15px;
            }

            /* Control-Group: Volle Breite auf Mobile */
            .control-group {
                min-width: 100%;
                width: 100%;
            }

            /* Datum-Filter für Mobile optimieren */
            .controls input[type="date"],
            .controls input[type="text"],
            .controls select,
            .controls button {
                min-height: 44px; /* Touch-Target Mindestgröße */
                font-size: 14px; /* Kompakter für Mobile */
                padding: 10px;
                width: 100%;
            }
            
            .control-group label {
                font-size: 12px;
                margin-bottom: 4px;
            }

            /* Grid-Layout für Datum-Filter auf Mobile: Stacked */
            .control-group > div[style*="grid-template-columns"] {
                display: flex !important;
                flex-direction: column !important;
                gap: 10px !important;
            }

            /* Tabellen horizontal scrollbar */
            .tab-content table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
                font-size: 0.85em;
            }

            .tab-content table th,
            .tab-content table td {
                padding: 6px 4px;
                font-size: 0.85em;
            }

            /* Buttons größer für Touch */
            button {
                min-width: 44px;
                min-height: 44px;
            }

            /* Karten-Grid optimieren */
            .card-grid {
                grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)) !important;
                gap: 5px;
            }

            /* Deck-Overview Cards */
            #cityLeagueDeckOverview,
            #cityLeagueDeckSearchResults {
                grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)) !important;
                gap: 10px;
            }

            /* Dein Deck Grid - Kleinere Karten auf Mobile */
            #cityLeagueMyDeckGrid {
                grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)) !important;
                gap: 10px;
            }

            /* Deck-Karten Buttons kleiner auf Mobile */
            #cityLeagueMyDeckGrid .deck-card button {
                font-size: 10px !important;
                min-width: 16px !important;
                min-height: 16px !important;
            }

            #cityLeagueMyDeckGrid .deck-card > div[style*="grid-template-columns"] {
                grid-template-columns: 16px 1fr 16px !important;
                gap: 2px !important;
                bottom: 3px !important;
            }

            #cityLeagueMyDeckGrid .deck-card .card-max-count {
                font-size: 14px !important;
                width: 24px !important;
                height: 24px !important;
            }

            /* Stats über Buttons kompakter */
            #cityLeagueMyDeckGrid .deck-card div[style*="bottom: 30px"] {
                font-size: 7px !important;
                padding: 1px 2px !important;
                bottom: 22px !important;
            }

            /* Metadata und Stats kompakter */
            .metadata {
                padding: 10px;
                font-size: 0.9em;
            }

            .stat-card h3 {
                font-size: 1em;
            }

            /* Modal Content auf Mobile */
            .image-view-content,
            .rarity-switcher-modal-content {
                padding: 10px;
                width: 98%;
            }

            .rarity-option-card {
                padding: 8px;
            }

            .rarity-option-card img {
                max-width: 100px;
            }
        }

        /* Very Small Mobile Devices (Small Phones) */
        @media (max-width: 375px) {
            .header h1 {
                font-size: 1.3em;
            }

            .tab-btn {
                padding: 8px 10px;
                font-size: 11px;
            }

            .stat-card .value {
                font-size: 1.5em;
            }

            .tab-content table th,
            .tab-content table td {
                padding: 4px 2px;
                font-size: 0.75em;
            }

            #cityLeagueDeckOverview,
            #cityLeagueDeckSearchResults {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)) !important;
            }

            /* Noch kleinere Deck-Karten auf kleinen Phones */
            #cityLeagueMyDeckGrid {
                grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)) !important;
                gap: 5px;
            }
        }

        /* Grid-Ansicht: Kompakte Darstellung für Screenshots */
        @media (max-width: 768px) {
            .grid-view-active #cityLeagueDeckOverview {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)) !important;
                gap: 5px;
            }

            .grid-view-active #cityLeagueDeckOverview .deck-card img {
                max-height: 84px;
            }

            .grid-view-active #cityLeagueDeckOverview .deck-card {
                font-size: 8px;
            }

            .grid-view-active #cityLeagueDeckOverview .card-max-count,
            .grid-view-active #cityLeagueDeckOverview .card-in-deck-count {
                font-size: 10px !important;
                width: 20px !important;
                height: 20px !important;
            }

            .grid-view-active #cityLeagueDeckOverview button {
                font-size: 8px !important;
                padding: 2px 4px !important;
                min-width: 14px !important;
                min-height: 14px !important;
            }
        }
        
        /* Opponent dropdown styles */
        .opponent-option:hover {
            background: #e8f4f8 !important;
        }

        /* =========================
           ERWEITERTE MOBILE OPTIMIERUNGEN FÜR IPHONE
           ========================= */
        
        /* iPhone 17 Pro Max & ähnliche große Smartphones (390px - 430px) */
        @media (max-width: 430px) {
            /* Overview Grid - optimal für iPhone */
            .overview-grid {
                grid-template-columns: 1fr !important;
                gap: 15px;
            }

            /* Inline Styles mit festen Breiten überschreiben */
            [style*="min-width: 300px"],
            [style*="min-width: 350px"] {
                min-width: 100% !important;
            }

            /* Tab-Navigation horizontal scroll optimiert */
            .tab-navigation {
                gap: 8px;
                padding: 12px;
                -webkit-overflow-scrolling: touch; /* Smooth scrolling iOS */
            }

            .tab-btn {
                flex-shrink: 0;
                padding: 12px 16px;
                font-size: 14px;
                min-width: auto;
                white-space: nowrap;
            }

            /* Suchfelder volle Breite auf mobile */
            .search-box input,
            .card-search-input {
                max-width: 100% !important;
                width: 100% !important;
                font-size: 16px; /* Verhindert Auto-Zoom auf iOS */
            }

            /* Control Groups Stack */
            .control-group {
                min-width: 100% !important;
                width: 100%;
            }

            .control-row {
                flex-direction: column;
                gap: 12px;
            }

            /* Tabellen: Besseres Overflow Handling */
            .tab-content table {
                display: block;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                white-space: nowrap;
                font-size: 13px;
            }

            table th, table td {
                padding: 10px 6px;
                font-size: 13px;
            }

            /* Stat Cards responsiv */
            .stat-card {
                padding: 15px;
                margin-bottom: 15px;
            }

            .stat-card .value {
                font-size: 2em;
            }

            /* Header optimiert */
            .header h1 {
                font-size: 1.8em;
                line-height: 1.2;
            }

            .header p {
                font-size: 1em;
            }

            /* Tab Content Padding reduziert */
            .tab-content {
                padding: 12px;
            }

            .tab-content h1 {
                font-size: 1.6em;
                margin-bottom: 20px;
            }

            .tab-content h2 {
                font-size: 1.3em;
                margin-top: 20px;
                margin-bottom: 15px;
            }

            /* Controls kompakter */
            .controls {
                padding: 15px;
            }

            .control-group select,
            .control-group input {
                font-size: 16px !important; /* Verhindert Auto-Zoom */
                padding: 12px;
            }

            /* Metadata kompakter */
            .metadata {
                padding: 12px;
                margin-bottom: 20px;
                font-size: 0.95em;
            }

            /* Footer */
            .footer {
                padding: 15px;
                font-size: 0.9em;
            }

            /* Grid-Layouts optimiert */
            .card-grid,
            .compact-card-grid {
                grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)) !important;
                gap: 8px;
            }

            .deck-grid {
                grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)) !important;
                gap: 10px;
            }

            .card-database-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)) !important;
                gap: 12px;
            }

            /* Modals für mobile optimiert */
            .image-view-content,
            .rarity-switcher-modal-content {
                width: 95% !important;
                max-width: 95% !important;
                margin: 10px auto !important;
                padding: 15px !important;
            }

            .image-view-header h3 {
                font-size: 1.3em;
            }

            .image-view-close,
            .single-card-close {
                width: 44px;
                height: 44px;
                font-size: 24px;
            }

            /* Buttons touch-friendly */
            button,
            .btn {
                min-height: 44px;
                min-width: 44px;
                padding: 10px 15px;
                font-size: 15px;
            }

            /* Karten-Badges optimiert */
            .compact-badge,
            [style*="border-radius: 50%"] {
                font-size: 12px !important;
                min-width: 22px !important;
                min-height: 22px !important;
            }
        }

        /* Extra Optimierungen für kleinere iPhones (< 390px) */
        @media (max-width: 390px) {
            /* Header noch kompakter */
            .header {
                padding: 15px 8px;
                margin-bottom: 10px;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .header p {
                font-size: 0.9em;
            }

            /* Tabs kompakter */
            .tab-navigation {
                padding: 10px;
                gap: 6px;
            }

            .tab-btn {
                padding: 10px 14px;
                font-size: 13px;
            }

            /* Content Padding minimal */
            .tab-content {
                padding: 10px;
            }

            /* Tables noch kompakter */
            table th, table td {
                padding: 8px 4px;
                font-size: 12px;
            }

            /* Stat Cards */
            .stat-card .value {
                font-size: 1.6em;
            }

            /* Grids noch enger */
            .card-grid,
            .compact-card-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)) !important;
                gap: 6px;
            }

            /* Controls */
            .controls {
                padding: 12px;
            }

            .control-group select,
            .control-group input {
                padding: 10px;
                font-size: 15px;
            }
        }

        /* Landscape Mode optimiert */
        @media (max-width: 932px) and (orientation: landscape) {
            body {
                padding: 8px;
            }

            .header {
                padding: 15px;
                margin-bottom: 15px;
            }

            .header h1 {
                font-size: 1.6em;
            }

            .tab-content {
                padding: 15px;
                min-height: 200px;
            }

            /* Grids optimiert für landscape */
            .overview-grid {
                grid-template-columns: repeat(2, 1fr) !important;
                gap: 15px;
            }

            .card-grid,
            .compact-card-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)) !important;
            }

            /* Tabellen kompakter in landscape */
            table {
                font-size: 12px;
            }

            table th, table td {
                padding: 6px 4px;
            }
        }

        /* Touch-Optimierungen für alle iOS-Geräte */
        @media (hover: none) and (pointer: coarse) {
            /* Alle interaktiven Elemente touch-friendly */
            button,
            .tab-btn,
            select,
            input,
            a {
                -webkit-tap-highlight-color: rgba(102, 126, 234, 0.2);
                touch-action: manipulation;
            }

            /* Prevent double-tap zoom */
            * {
                touch-action: manipulation;
            }

            /* Smooth scrolling für iOS */
            * {
                -webkit-overflow-scrolling: touch;
            }

            /* Größere Touch-Targets */
            .tab-btn,
            button,
            select {
                min-height: 44px;
                min-width: 44px;
            }

            /* Hover-States deaktivieren auf Touch */
            .tab-btn:hover,
            button:hover,
            table tbody tr:hover {
                background: inherit;
            }

            /* Active States für Touch-Feedback */
            .tab-btn:active {
                background: rgba(255,255,255,0.4);
                transform: scale(0.98);
            }

            button:active {
                transform: scale(0.98);
                opacity: 0.9;
            }
        }

        /* Spezielle Fixes für Safari iOS */
        @supports (-webkit-touch-callout: none) {
            /* Fix für iOS Input-Zoom */
            input,
            select,
            textarea {
                font-size: 16px !important;
            }

            /* Fix für iOS 100vh Problem */
            .tabs-container {
                min-height: -webkit-fill-available;
            }

            /* Verhindere Bounce-Scrolling am Rand */
            body {
                overscroll-behavior-y: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎴 Pokemon TCG Analyse</h1>
            <p>Dein Portal für Meta-Analysen und Deckbuilding</p>
        </div>
        
        <div class="tabs-container">
            <div class="tab-navigation">
                <button class="tab-btn active" onclick="switchTab('city-league')">🇯🇵 City League Meta</button>
                <button class="tab-btn" onclick="switchTab('city-league-analysis')">📊 City League Deck Analysis</button>
                <button class="tab-btn" onclick="switchTab('current-meta')">🎮 Current Meta</button>
                <button class="tab-btn" onclick="switchTab('current-analysis')">📈 Current Meta Deck Analysis</button>
                <button class="tab-btn" onclick="switchTab('past-meta')">🏆 Past Meta</button>
                <button class="tab-btn" onclick="switchTab('cards')">🧰 Cards</button>
            </div>
            
            <!-- Tab 1: City League Meta -->
            <div id="city-league" class="tab-content active">
                <div class="city-league-container">
                    <div class="city-league-header">
                        <h1>🇯🇵 City League Development</h1>
                    </div>
                    <div id="cityLeagueContent" style="padding: 30px; background: #ffffff;">
                        <div style="text-align: center; padding: 40px; color: #999;">Lädt...</div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 2: City League Deck Analysis -->
            <div id="city-league-analysis" class="tab-content">
                <div class="container">
                    <div class="header">
                        <h1>🦅 City League Deck Analysis</h1>
                        <p>Analyze and Build Decks</p>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group" style="margin-bottom: 20px;">
                            <label>📅 Turnier-Zeitraum Filter:</label>
                            <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 15px; align-items: end;">
                                <div>
                                    <label for="cityLeagueDateFrom" style="font-size: 0.9em; color: #666; display: block; margin-bottom: 5px;">Von:</label>
                                    <input type="date" id="cityLeagueDateFrom" onchange="applyCityLeagueDateFilter()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                </div>
                                <div>
                                    <label for="cityLeagueDateTo" style="font-size: 0.9em; color: #666; display: block; margin-bottom: 5px;">Bis:</label>
                                    <input type="date" id="cityLeagueDateTo" onchange="applyCityLeagueDateFilter()" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                </div>
                                <div>
                                    <button onclick="resetCityLeagueDateFilter()" style="padding: 12px 20px; font-size: 0.95em; background: #f0f0f0; color: #333; border: 1px solid #ccc; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s;" onmouseover="this.style.background='#e0e0e0'" onmouseout="this.style.background='#f0f0f0'">🔄 Alle Daten</button>
                                </div>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-group">
                                <label for="cityLeagueDeckSearch">🔍 Deck suchen:</label>
                                <input type="text" id="cityLeagueDeckSearch" placeholder="Deck-Name eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                            </div>
                            <div class="control-group">
                                <label for="cityLeagueDeckSelect">🎯 Deck Archetype wählen:</label>
                                <select id="cityLeagueDeckSelect" autocomplete="off" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                    <option value="">-- Bitte Deck auswählen --</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="cityLeagueFilterSelect">🦂 Karten Filter:</label>
                                <select id="cityLeagueFilterSelect">
                                    <option value="all">Alle Karten</option>
                                    <option value="90">Karten in >90% der Decks (Core)</option>
                                    <option value="70">Karten in >70% der Decks</option>
                                    <option value="50">Karten in >50% der Decks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stats-section" id="cityLeagueStatsSection" style="display: none;">
                        <h2>📊 Deck Statistiken</h2>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="label">Cards in Deck (Unique / Total)</div>
                                <div class="value" id="cityLeagueStatCards">-</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Decks Used</div>
                                <div class="value" id="cityLeagueStatDecksUsed">-</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Avg Placement</div>
                                <div class="value" id="cityLeagueStatAvgPlacement">-</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="cards-section">
                        <div class="cards-header">
                            <h2>🃏 Karten Übersicht (sortiert)</h2>
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 1.1em; color: #333;"><span id="cityLeagueCardCount">0 Karten</span><span id="cityLeagueCardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
                                <div style="display: flex; gap: 5px;">
                                    <button class="btn btn-success" onclick="setOverviewRarityMode('min')" id="overviewRarityMin" style="padding: 6px 12px; font-size: 0.85em; background: #28a745;">⬇️ Low Rarity</button>
                                    <button class="btn btn-danger" onclick="setOverviewRarityMode('max')" id="overviewRarityMax" style="padding: 6px 12px; font-size: 0.85em; background: #dc3545;">⬆️ Max Rarity</button>
                                    <button class="btn btn-info" onclick="setOverviewRarityMode('all')" id="overviewRarityAll" style="padding: 6px 12px; font-size: 0.85em; background: #17a2b8;">🌍 Alle Prints</button>
                                </div>
                                <button class="btn btn-primary" onclick="copyDeckOverview()" style="padding: 8px 16px; font-size: 0.9em;">📋 Copy</button>
                                <button class="btn btn-warning" onclick="toggleDeckGridView()" style="padding: 8px 16px; font-size: 0.9em;">🖼️ Grid View</button>
                            </div>
                        </div>
                        
                        <!-- Suchfeld für Karten -->
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 10px; margin-bottom: 15px;">
                            <input type="text" id="cityLeagueOverviewSearch" placeholder="🔍 Karten suchen..." class="card-search-input" oninput="filterOverviewCards()" style="width: 100%; max-width: 500px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;">
                        </div>
                        
                        <!-- Karten Tabellen-Ansicht (Standard) -->
                        <div class="deck-table-view" id="cityLeagueDeckTableView" style="display: none;">
                            <div id="cityLeagueDeckTable"></div>
                        </div>
                        
                        <!-- Karten Grid-Ansicht (Kompakt) -->
                        <div class="deck-visual" id="cityLeagueDeckVisual" style="display: none;">
                            <div class="deck-grid" id="cityLeagueDeckGrid"></div>
                        </div>
                    </div>
                    
                    <!-- Deck Builder -->
                    <div class="deck-builder">
                        <h2>🛠️ Deck Builder (60 Karten)</h2>
                        <div class="builder-controls">
                            <button class="btn btn-secondary" onclick="clearDeck('cityLeague')">🗑️ Clear</button>
                            <button class="btn btn-success" onclick="autoComplete('cityLeague', 'min')" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">⬇️ Generate Low Rarity Deck</button>
                            <button class="btn btn-success" onclick="autoComplete('cityLeague', 'max')" style="background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);">⬆️ Generate Max Rarity Deck</button>
                        </div>
                        
                        <div class="deck-summary">
                            <h3>Aktuell: <span id="cityLeagueDeckCount">0</span> / 60 Karten <span id="cityLeagueDeckCountUnique" style="font-weight: normal; font-size: 0.9em; color: #666;">(0 Unique)</span></h3>
                        </div>
                        
                        <!-- Mein Deck Übersicht -->
                        <div id="cityLeagueMyDeckVisual" style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                                <h3 style="margin: 0;">🎴 Dein Deck</h3>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-primary" onclick="copyDeck('cityLeague')">📋 Copy Deck</button>
                                    <button class="btn btn-warning" onclick="generateDeckGrid('cityLeague')">🖼️ Grid View</button>
                                </div>
                            </div>
                            <input type="text" id="cityLeagueDeckGridSearch" placeholder="🔍 Karten im Deck suchen..." class="card-search-input" oninput="filterDeckGrid('cityLeague')" style="margin-bottom: 15px; width: 100%; max-width: 500px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;">
                            <div class="deck-grid" id="cityLeagueMyDeckGrid">
                                <p style="text-align: center; color: #666; padding: 40px;">Erstelle ein Deck mit den Buttons oben oder füge Karten manuell hinzu...</p>
                            </div>
                        </div>
                        
                        <!-- Karten hinzufügen Bereich -->
                        <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                            <h3 style="margin-top: 0;">➕ Karte hinzufügen</h3>
                            <input type="text" id="cityLeagueDeckCardSearch" placeholder="🔍 Kartennamen suchen..." class="card-search-input" style="margin-bottom: 15px; width: 100%; max-width: 500px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;">
                            <div id="cityLeagueDeckSearchResults" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 3: Current Meta -->
            <div id="current-meta" class="tab-content">
                <div class="container">
                    <div class="header">
                        <h1>🎮 Limitless Online Comparison</h1>
                    </div>
                    <div id="currentMetaContent" style="padding: 30px; background: #ffffff;">
                        <div style="text-align: center; padding: 40px; color: #999;">Lädt...</div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 4: Current Analysis -->
            <div id="current-analysis" class="tab-content">
                <div class="container">
                    <div class="header">
                        <h1>📈 Current Meta Deck Analysis</h1>
                        <p>Analyze and Build Decks from Current Meta</p>
                    </div>
                    
                    <div class="controls">
                        <div class="control-group" style="margin-bottom: 20px;">
                            <label>🎮 Turnier-Format Filter:</label>
                            <div style="display: flex; gap: 15px; align-items: center;">
                                <button onclick="setCurrentMetaFormatFilter('all')" id="currentMetaFilterAll" class="btn btn-primary" style="padding: 12px 20px; font-size: 0.95em;">📊 All</button>
                                <button onclick="setCurrentMetaFormatFilter('live')" id="currentMetaFilterLive" class="btn btn-secondary" style="padding: 12px 20px; font-size: 0.95em;">� Limitless Decks</button>
                                <button onclick="setCurrentMetaFormatFilter('play')" id="currentMetaFilterPlay" class="btn btn-secondary" style="padding: 12px 20px; font-size: 0.95em;">🏆 Major Tournament Decks</button>
                                <span id="currentMetaFilterStatus" style="margin-left: 15px; color: #666; font-weight: 500;"></span>
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-group">
                                <label for="currentMetaDeckSearch">🔍 Deck suchen:</label>
                                <input type="text" id="currentMetaDeckSearch" placeholder="Deck-Name eingeben..." style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                            </div>
                            <div class="control-group">
                                <label for="currentMetaDeckSelect">🎯 Deck Archetype wählen:</label>
                                <select id="currentMetaDeckSelect" autocomplete="off" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px;">
                                    <option value="">-- Bitte Deck auswählen --</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="currentMetaFilterSelect">🦂 Karten Filter:</label>
                                <select id="currentMetaFilterSelect">
                                    <option value="all">Alle Karten</option>
                                    <option value="90">Karten in >90% der Decks (Core)</option>
                                    <option value="70">Karten in >70% der Decks</option>
                                    <option value="50">Karten in >50% der Decks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="stats-section" id="currentMetaStatsSection" style="display: none;">
                        <h2>📊 Deck Statistiken</h2>
                        <div class="stats-grid">
                            <div class="stat-card">
                                <div class="label">Cards in Deck (Unique / Total)</div>
                                <div class="value" id="currentMetaStatCards">-</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Total Winrate</div>
                                <div class="value" id="currentMetaStatWinrate">-</div>
                            </div>
                            <div class="stat-card">
                                <div class="label">Matchup vs Top 20</div>
                                <div class="value" id="currentMetaStatMatchup">-</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Best/Worst Matchups Section -->
                    <div id="currentMetaMatchupsSection" style="display: none; margin-bottom: 40px; background: #f8f9fa; padding: 20px; border-radius: 8px;">
                        <h3 id="currentMetaMatchupsTitle" style="color: #2c3e50; margin-top: 0;">Deck Matchups</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <h4 style="color: #27ae60; margin-bottom: 10px;">✅ Best Matchups</h4>
                                <table style="box-shadow: none; width: 100%;">
                                    <thead>
                                        <tr style="background: #d4edda;">
                                            <th style="background: #27ae60;">Opponent</th>
                                            <th style="background: #27ae60;">Win Rate</th>
                                            <th style="background: #27ae60;">Record</th>
                                        </tr>
                                    </thead>
                                    <tbody id="currentMetaBestMatchups">
                                        <tr><td colspan="3" style="text-align: center; padding: 20px;">Keine Daten verfügbar</td></tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            <div>
                                <h4 style="color: #e74c3c; margin-bottom: 10px;">❌ Worst Matchups</h4>
                                <table style="box-shadow: none; width: 100%;">
                                    <thead>
                                        <tr style="background: #f8d7da;">
                                            <th style="background: #e74c3c;">Opponent</th>
                                            <th style="background: #e74c3c;">Win Rate</th>
                                            <th style="background: #e74c3c;">Record</th>
                                        </tr>
                                    </thead>
                                    <tbody id="currentMetaWorstMatchups">
                                        <tr><td colspan="3" style="text-align: center; padding: 20px;">Keine Daten verfügbar</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <div style="background: white; padding: 15px; border-radius: 5px; border: 2px solid #3498db; margin-top: 20px;">
                            <h4 style="margin-top: 0; color: #3498db;">🔍 Select & Analyze Opponent Matchup</h4>
                            <label for="currentMetaOpponentSearch" style="display: block; margin-bottom: 8px; font-weight: bold;">Search Opponent:</label>
                            <div style="position: relative;">
                                <input type="text" id="currentMetaOpponentSearch" placeholder="Type to search deck..." 
                                    style="width: 100%; padding: 10px; border: 2px solid #bbb; border-radius: 4px; font-size: 1em;" 
                                    oninput="filterCurrentMetaOpponents(this)" 
                                    onfocus="document.getElementById('currentMetaOpponentDropdown').style.display = 'block';"
                                    autocomplete="off">
                                <div id="currentMetaOpponentDropdown" 
                                    style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid #bbb; border-top: none; border-radius: 0 0 4px 4px; max-height: 250px; overflow-y: auto; display: none; z-index: 1000;">
                                </div>
                            </div>
                            <input type="hidden" id="currentMetaOpponentSelected" value="">
                            <div id="currentMetaMatchupDetails" style="margin-top: 15px; display: none; background: #ecf0f1; padding: 15px; border-radius: 4px;"></div>
                        </div>
                    </div>
                    
                    <div class="cards-section">
                        <div class="cards-header">
                            <h2>🃏 Karten Übersicht (sortiert)</h2>
                            <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 1.1em; color: #333;"><span id="currentMetaCardCount">0 Karten</span><span id="currentMetaCardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
                                <div style="display: flex; gap: 5px;">
                                    <button class="btn btn-success" onclick="setCurrentMetaOverviewRarityMode('min')" id="currentMetaOverviewRarityMin" style="padding: 6px 12px; font-size: 0.85em; background: #28a745;">⬇️ Low Rarity</button>
                                    <button class="btn btn-danger" onclick="setCurrentMetaOverviewRarityMode('max')" id="currentMetaOverviewRarityMax" style="padding: 6px 12px; font-size: 0.85em; background: #dc3545;">⬆️ Max Rarity</button>
                                    <button class="btn btn-info" onclick="setCurrentMetaOverviewRarityMode('all')" id="currentMetaOverviewRarityAll" style="padding: 6px 12px; font-size: 0.85em; background: #17a2b8;">🌍 Alle Prints</button>
                                </div>
                                <button class="btn btn-primary" onclick="copyCurrentMetaDeckOverview()" style="padding: 8px 16px; font-size: 0.9em;">📋 Copy</button>
                                <button class="btn btn-warning" onclick="toggleCurrentMetaDeckGridView()" style="padding: 8px 16px; font-size: 0.9em;">🖼️ Grid View</button>
                            </div>
                        </div>
                        
                        <!-- Suchfeld für Karten -->
                        <div style="padding: 15px; background: #f8f9fa; border-radius: 10px; margin-bottom: 15px;">
                            <input type="text" id="currentMetaOverviewSearch" placeholder="🔍 Karten suchen..." class="card-search-input" oninput="filterCurrentMetaOverviewCards()" style="width: 100%; max-width: 500px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;">
                        </div>
                        
                        <!-- Karten Tabellen-Ansicht (Standard) -->
                        <div class="deck-table-view" id="currentMetaDeckTableView" style="display: none;">
                            <div id="currentMetaDeckTable"></div>
                        </div>
                        
                        <!-- Karten Grid-Ansicht (Kompakt) -->
                        <div class="deck-visual" id="currentMetaDeckVisual" style="display: none;">
                            <div class="deck-grid" id="currentMetaDeckGrid"></div>
                        </div>
                    </div>
                    
                    <!-- Deck Builder -->
                    <div class="deck-builder">
                        <h2>🛠️ Deck Builder (60 Karten)</h2>
                        <div class="builder-controls">
                            <button class="btn btn-secondary" onclick="clearDeck('currentMeta')">🗑️ Clear</button>
                            <button class="btn btn-success" onclick="autoComplete('currentMeta', 'min')" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">⬇️ Generate Low Rarity Deck</button>
                            <button class="btn btn-success" onclick="autoComplete('currentMeta', 'max')" style="background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);">⬆️ Generate Max Rarity Deck</button>
                        </div>
                        
                        <div class="deck-summary">
                            <h3>Aktuell: <span id="currentMetaDeckCount">0</span> / 60 Karten <span id="currentMetaDeckCountUnique" style="font-weight: normal; font-size: 0.9em; color: #666;">(0 Unique)</span></h3>
                        </div>
                        
                        <!-- Mein Deck Übersicht -->
                        <div id="currentMetaMyDeckVisual" style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;">
                                <h3 style="margin: 0;">🎴 Dein Deck</h3>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-primary" onclick="copyDeck('currentMeta')">📋 Copy Deck</button>
                                    <button class="btn btn-warning" onclick="generateDeckGrid('currentMeta')">🖼️ Grid View</button>
                                </div>
                            </div>
                            <input type="text" id="currentMetaDeckGridSearch" placeholder="🔍 Karten im Deck suchen..." class="card-search-input" oninput="filterDeckGrid('currentMeta')" style="margin-bottom: 15px; width: 100%; max-width: 500px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;">
                            <div class="deck-grid" id="currentMetaMyDeckGrid">
                                <p style="text-align: center; color: #666; padding: 40px;">Erstelle ein Deck mit den Buttons oben oder füge Karten manuell hinzu...</p>
                            </div>
                        </div>
                        
                        <!-- Karten hinzufügen Bereich -->
                        <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                            <h3 style="margin-top: 0;">➕ Karte hinzufügen</h3>
                            <input type="text" id="currentMetaDeckCardSearch" placeholder="🔍 Kartennamen suchen..." class="card-search-input" style="margin-bottom: 15px; width: 100%; max-width: 500px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;">
                            <div id="currentMetaDeckSearchResults" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px;"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 5: Past Meta -->
            <div id="past-meta" class="tab-content">
                <div class="analysis-container">
                    <div class="analysis-header">
                        <h1>🏆 Past Tournament Meta</h1>
                        <p>Analyze and Build Decks</p>
                    </div>
                    <div class="controls">
                        <div class="control-row">
                            <div class="control-group">
                                <label for="pastDeckSearch">🔍 Deck suchen:</label>
                                <input type="text" id="pastDeckSearch" placeholder="Deck-Name eingeben...">
                            </div>
                            <div class="control-group">
                                <label for="pastDeckSelect">🎯 Deck Archetype wählen:</label>
                                <select id="pastDeckSelect">
                                    <option value="">-- Bitte Deck auswählen --</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label for="pastFilterSelect">🦂 Karten Filter:</label>
                                <select id="pastFilterSelect">
                                    <option value="all">Alle Karten</option>
                                    <option value="90">Karten in >90% der Decks (Core)</option>
                                    <option value="70">Karten in >70% der Decks</option>
                                    <option value="50">Karten in >50% der Decks</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    <div class="cards-section">
                        <div class="cards-header">
                            <h2>🃏 Karten Liste</h2>
                            <span style="font-size: 1.1em; color: #333;"><span id="pastCardCount">0 Karten</span><span id="pastCardCountSummary" style="margin-left: 10px; font-weight: normal; color: #666;">/ 0 Total</span></span>
                        </div>
                        
                        <!-- Deck Übersicht -->
                        <div class="deck-visual" id="pastDeckVisual" style="display: none;">
                            <h3>🎨 Deck Übersicht</h3>
                            <div class="deck-grid" id="pastDeckGrid"></div>
                        </div>
                        
                        <!-- Toggle für Einzelne Karten -->
                        <div class="cards-table-header" onclick="togglePastCards()">
                            <div class="cards-header-left">
                                <span class="cards-toggle collapsed" id="pastCardsToggle"></span>
                                <h3>📋 Einzelne Karten</h3>
                            </div>
                        </div>
                        
                        <div id="pastCardsContent" style="display: none;">
                            <input type="text" id="pastCardSearchInput" placeholder="🔍 Karte suchen..." class="card-search-input" oninput="filterPastMetaCards()" style="margin-bottom: 15px;">
                            <div class="cards-table" id="pastMetaTable"></div>
                        </div>
                    </div>
                    
                    <!-- Deck Builder -->
                    <div class="deck-builder">
                        <h2>🛠️ Deck Builder (60 Karten)</h2>
                        <div class="builder-controls">
                            <button class="btn btn-primary" onclick="copyDeck('past')">📋 Copy</button>
                            <button class="btn btn-warning" onclick="generateDeckGrid('past')">🖼️ Grid</button>
                            <button class="btn btn-secondary" onclick="clearDeck('past')">🗑️ Clear</button>
                            <button class="btn btn-success" onclick="autoComplete('past')">⚡ Generate Deck</button>
                        </div>
                        
                        <div class="deck-summary">
                            <h3>Aktuell: <span id="pastDeckCount">0</span> / 60 Karten <span id="pastDeckCountUnique" style="font-weight: normal; font-size: 0.9em; color: #666;">(0 Unique)</span></h3>
                        </div>
                        
                        <div id="pastMyDeckVisual" style="display: none;">
                            <h3>🎴 Dein Deck Übersicht</h3>
                            <div class="deck-grid" id="pastMyDeckGrid"></div>
                        </div>
                        
                        <div class="deck-list" id="pastDeckList">
                            <p style="text-align: center; color: #666;">Füge Karten von oben hinzu...</p>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Tab 6: Cards -->
            <div id="cards" class="tab-content">
                <h1>🧰 Card Database</h1>
                
                <!-- Filter Section -->
                <div class="filter-section" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 15px;">
                        <!-- Search -->
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">🔍 Kartenname suchen</label>
                            <input type="text" id="cardSearch" placeholder="z.B. Charizard, Pikachu..." style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                        </div>
                        
                        <!-- Set Filter -->
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">📦 Set</label>
                            <select id="cardSetFilter" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="">Alle Sets</option>
                            </select>
                        </div>
                        
                        <!-- Category Filter -->
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">🎴 Kategorie</label>
                            <select id="cardCategoryFilter" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="">Alle Kategorien</option>
                                <option value="pokemon">Pokémon</option>
                                <option value="trainer">Trainer</option>
                                <option value="energy">Energy</option>
                            </select>
                        </div>
                        
                        <!-- Element Type Filter -->
                        <div id="elementFilterContainer">
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">⚡ Element Typ</label>
                            <select id="cardElementFilter" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="">Alle Elemente</option>
                                <option value="G">🌿 Grass (G)</option>
                                <option value="R">🔥 Fire (R)</option>
                                <option value="W">💧 Water (W)</option>
                                <option value="L">⚡ Lightning (L)</option>
                                <option value="P">🔮 Psychic (P)</option>
                                <option value="F">👊 Fighting (F)</option>
                                <option value="D">🌙 Darkness (D)</option>
                                <option value="M">⚙️ Metal (M)</option>
                                <option value="N">🐉 Dragon (N)</option>
                                <option value="C">⭐ Colorless (C)</option>
                                <option value="Y">🧚 Fairy (Y)</option>
                            </select>
                        </div>
                        
                        <!-- Rarity Filter -->
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600;">💎 Rarity</label>
                            <select id="cardRarityFilter" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <option value="">Alle Rarities</option>
                                <option value="Common">Common</option>
                                <option value="Uncommon">Uncommon</option>
                                <option value="Rare">Rare</option>
                                <option value="Holo Rare">Holo Rare</option>
                                <option value="Double Rare">Double Rare</option>
                                <option value="Triple Rare">Triple Rare</option>
                                <option value="Ultra Rare">Ultra Rare</option>
                                <option value="Secret Rare">Secret Rare</option>
                                <option value="Rainbow Rare">Rainbow Rare</option>
                                <option value="Art Rare">Art Rare</option>
                                <option value="Special Art Rare">Special Art Rare</option>
                                <option value="Character Holo Rare">Character Holo Rare</option>
                                <option value="Character Super Rare">Character Super Rare</option>
                                <option value="Radiant Rare">Radiant Rare</option>
                                <option value="Shiny Rare">Shiny Rare</option>
                                <option value="Shiny Ultra Rare">Shiny Ultra Rare</option>
                                <option value="Promo">Promo</option>
                            </select>
                        </div>
                        
                        <!-- Reset Button -->
                        <div style="display: flex; align-items: flex-end;">
                            <button onclick="resetCardFilters()" style="width: 100%; padding: 8px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">
                                🔄 Filter zurücksetzen
                            </button>
                        </div>
                    </div>
                    
                    <!-- Results Info -->
                    <div id="cardResultsInfo" style="padding: 10px; background: #ecf0f1; border-radius: 4px; text-align: center; font-weight: 600;">
                        Lädt Karten...
                    </div>
                </div>
                
                <!-- Cards Grid -->
                <div id="cardsContent" class="loading">Lädt Karten...</div>
            </div>
        </div>
        
        <div class="footer">
            <p>📅 Letzte Aktualisierung: <span id="last-update">Loading...</span></p>
        </div>
    </div>
    
    <script>
        const BASE_PATH = './data/';
        
        // Tab switching
        function switchTab(tabName) {
            const tabs = document.querySelectorAll('.tab-content');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            const selectedTab = document.getElementById(tabName);
            if (selectedTab) {
                selectedTab.classList.add('active');
                
                // Load data for the tab
                switch(tabName) {
                    case 'city-league':
                        if (!window.cityLeagueLoaded) loadCityLeagueData();
                        break;
                    case 'city-league-analysis':
                        if (!window.cityLeagueAnalysisLoaded) loadCityLeagueAnalysis();
                        break;
                    case 'current-meta':
                        if (!window.currentMetaLoaded) loadCurrentMeta();
                        break;
                    case 'current-analysis':
                        if (!window.currentAnalysisLoaded) loadCurrentAnalysis();
                        break;
                    case 'past-meta':
                        if (!window.pastMetaLoaded) loadPastMeta();
                        break;
                    case 'cards':
                        if (!window.cardsLoaded) loadCards();
                        break;
                }
            }
            
            // Set active button
            const activeBtn = Array.from(buttons).find(btn => 
                btn.getAttribute('onclick')?.includes(tabName)
            );
            if (activeBtn) {
                activeBtn.classList.add('active');
            }
        }
        
        // Navigate to City League Analysis with pre-selected deck
        function navigateToAnalysisWithDeck(archetypeName) {
            console.log('🎯 Navigating to analysis with deck:', archetypeName);
            
            // Switch to City League Analysis tab
            switchTab('city-league-analysis');
            
            // Wait for dropdown to be populated with data
            let attempts = 0;
            const maxAttempts = 50; // Max 5 seconds (50 * 100ms)
            
            const checkAndSelect = () => {
                attempts++;
                const select = document.getElementById('cityLeagueDeckSelect');
                
                if (select && select.options.length > 1) { // More than just placeholder
                    // Find matching option (case-insensitive)
                    const options = Array.from(select.options);
                    const matchingOption = options.find(opt => 
                        opt.value.toLowerCase() === archetypeName.toLowerCase()
                    );
                    
                    if (matchingOption) {
                        select.value = matchingOption.value;
                        // Trigger change event to load the deck
                        const event = new Event('change', { bubbles: true });
                        select.dispatchEvent(event);
                        console.log('✅ Deck selected:', matchingOption.value);
                    } else {
                        console.warn('⚠️ Deck not found in dropdown:', archetypeName);
                    }
                } else if (attempts < maxAttempts) {
                    // Retry after 100ms
                    setTimeout(checkAndSelect, 100);
                } else {
                    console.error('❌ Timeout: Dropdown not populated after 5 seconds');
                }
            };
            
            // Start checking after initial delay
            setTimeout(checkAndSelect, 100);
        }
        
        // CSV loading and parsing
        async function loadCSV(filename) {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`${BASE_PATH}${filename}?t=${timestamp}`);
                if (response.ok) {
                    const text = await response.text();
                    return parseCSV(text);
                }
                return null;
            } catch (e) {
                console.error(`Error loading ${filename}:`, e);
                return null;
            }
        }
        
        function parseCSV(text) {
            return parseCSVWithDelimiter(text, ';');
        }

        function parseCSVWithDelimiter(text, delimiter) {
            // Remove BOM if present
            if (text.charCodeAt(0) === 0xFEFF) {
                text = text.slice(1);
            }
            
            const lines = text.trim().split('\n').filter(line => line.trim());
            if (lines.length < 2) return [];
            
            const headers = lines[0].split(delimiter).map(h => h.trim());
            const data = [];
            
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue;
                const values = lines[i].split(delimiter);
                const row = {};
                headers.forEach((header, index) => {
                    row[header] = (values[index] || '').trim();
                });
                if (Object.values(row).some(v => v)) {
                    data.push(row);
                }
            }
            
            return data;
        }
        
        // Load all cards database for deck builder
        let allCardsDatabase = [];
        let cardsByNameMap = {};
        let englishSetCodes = null;
        let rarityPreferences = {};
        let globalRarityPreference = 'min'; // Default: Show lowest rarity from newest set
        let overviewRarityMode = 'min'; // Current rarity mode for overview section (min, max, or all)
        async function loadAllCardsDatabase() {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`./data/all_cards_merged.json?t=${timestamp}`);
                if (response.ok) {
                    const jsonData = await response.json();
                    // Extract cards array from JSON structure
                    allCardsDatabase = jsonData.cards || jsonData;
                    window.allCardsDatabase = allCardsDatabase;
                    cardsByNameMap = buildCardsByNameMap(allCardsDatabase);
                    window.cardsByNameMap = cardsByNameMap;
                    console.log(`✅ Loaded ${allCardsDatabase.length} cards from all_cards_merged.json (with prices)`);
                    console.log(`📊 Karten mit mehreren Versionen:`, Object.keys(cardsByNameMap).filter(k => cardsByNameMap[k].length > 1).length);
                    
                    // Count cards with prices
                    const cardsWithPrices = allCardsDatabase.filter(c => c.eur_price).length;
                    console.log(`💶 Karten mit Preisen: ${cardsWithPrices} (${Math.round(100*cardsWithPrices/allCardsDatabase.length)}%)`);
                    
                    // Initialisiere Suche wenn sie existiert
                    const searchInput = document.getElementById('cityLeagueDeckCardSearch');
                    if (searchInput && searchInput.value.trim()) {
                        searchDeckCards();
                    }
                } else {
                    console.error('❌ Failed to load all_cards_merged.json');
                }
            } catch (error) {
                console.error('Error loading all cards database:', error);
            }
        }

        async function loadSetMapping() {
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`./pokemon_sets_mapping.csv?t=${timestamp}`);
                if (!response.ok) return;
                const text = await response.text();
                const rows = parseCSVWithDelimiter(text, ',');
                englishSetCodes = new Set(rows.map(row => row.set_code).filter(Boolean));
                window.englishSetCodes = englishSetCodes;
            } catch (error) {
                console.error('Error loading pokemon_sets_mapping.csv:', error);
            }
        }

        function buildCardsByNameMap(cards) {
            const map = {};
            cards.forEach(card => {
                if (!card.name) return;
                if (!map[card.name]) {
                    map[card.name] = [];
                }
                map[card.name].push(card);
            });
            return map;
        }

        function getCardVersionsByName(cardName) {
            return (cardsByNameMap[cardName] || []).slice();
        }

        function getEnglishCardVersions(cardName) {
            const versions = getCardVersionsByName(cardName);
            if (!englishSetCodes || englishSetCodes.size === 0) {
                return versions;
            }
            return versions.filter(version => englishSetCodes.has(version.set));
        }

        function loadRarityPreferences() {
            try {
                const raw = localStorage.getItem('rarityPreferences');
                rarityPreferences = raw ? JSON.parse(raw) : {};
            } catch (error) {
                rarityPreferences = {};
            }
            window.rarityPreferences = rarityPreferences;
            loadGlobalRarityPreference();
        }

        function saveRarityPreferences() {
            localStorage.setItem('rarityPreferences', JSON.stringify(rarityPreferences));
        }

        function loadGlobalRarityPreference() {
            globalRarityPreference = 'min'; // Default: Lowest rarity from newest set
        }

        function getGlobalRarityPreference() {
            return globalRarityPreference || 'min'; // Default to 'min' if not set
        }

        function setRarityPreference(cardName, pref) {
            if (!cardName) return;
            rarityPreferences[cardName] = pref;
            saveRarityPreferences();
        }

        function getRarityPreference(cardName) {
            return rarityPreferences[cardName] || null;
        }

        function clearRarityPreference(cardName) {
            if (!cardName || !rarityPreferences[cardName]) return;
            delete rarityPreferences[cardName];
            saveRarityPreferences();
        }

        // Get international prints for a specific card (set + number)
        function getInternationalPrintsForCard(set, number) {
            const allCardsDb = window.allCardsDatabase || [];
            if (allCardsDb.length === 0) {
                console.warn('[getInternationalPrintsForCard] Database not loaded yet');
                return [];
            }
            
            // Find the base card
            const baseCard = allCardsDb.find(c => c.set === set && c.number === number);
            if (!baseCard) {
                console.warn(`[getInternationalPrintsForCard] Card not found: ${set} ${number}`);
                return [];
            }
            
            if (!baseCard.international_prints) {
                console.log(`[getInternationalPrintsForCard] No international prints for ${set} ${number}, returning base card only`);
                return [baseCard];
            }
            
            // Parse "ASC-112,MEG-76,MEP-10" -> [{set: "ASC", number: "112"}, ...]
            const printRefs = baseCard.international_prints.split(',').map(p => {
                const [s, n] = p.trim().split('-');
                return {set: s, number: n};
            });
            
            // Find all these cards in database
            const intPrintCards = printRefs.map(ref => 
                allCardsDb.find(c => c.set === ref.set && c.number === ref.number)
            ).filter(c => c); // Remove nulls
            
            console.log(`[getInternationalPrintsForCard] Found ${intPrintCards.length} international prints for ${baseCard.name} (${set} ${number}):`, 
                intPrintCards.map(c => `${c.set} ${c.number} (${c.rarity || 'NO RARITY'})`).join(', ')
            );
            
            return intPrintCards;
        }

        function getPreferredVersionForCard(cardName, originalSet = null, originalNumber = null) {
            const pref = getRarityPreference(cardName);
            const globalPref = getGlobalRarityPreference();
            
            // If originalSet and originalNumber provided, try international prints first
            let versions;
            if (originalSet && originalNumber) {
                versions = getInternationalPrintsForCard(originalSet, originalNumber);
                
                // DEBUG: Log international prints for troubleshooting
                console.log(`[getPreferredVersionForCard] International prints for ${cardName} (${originalSet} ${originalNumber}):`, 
                    versions.map(v => `${v.set_code}-${v.number} (rarity: "${v.rarity || 'NONE'}")`));
                
                // Intelligent fallback: If no international prints OR if international prints has NO rarity data,
                // fall back to all versions (fixes Judge DRI 222 issue while preserving Promo cards)
                const hasSufficientRarity = versions.length > 0 && 
                    versions.some(v => v.rarity && v.rarity.trim() !== '');
                
                console.log(`[getPreferredVersionForCard] hasSufficientRarity for ${cardName}: ${hasSufficientRarity}`);
                
                if (versions.length === 0 || !hasSufficientRarity) {
                    const fallbackReason = versions.length === 0 ? 'no international prints' : 
                        'international prints has no rarity data';
                    versions = getEnglishCardVersions(cardName);
                    console.log(`[getPreferredVersionForCard] ${fallbackReason} for ${cardName} (${originalSet} ${originalNumber}), using ALL ${versions.length} versions`);
                } else {
                    console.log(`[getPreferredVersionForCard] Using international prints for ${cardName} (${originalSet} ${originalNumber})`);
                }
            } else {
                versions = getEnglishCardVersions(cardName);
            }
            
            // DEBUG: Log when versions are not found
            if (versions.length === 0) {
                console.log(`[getPreferredVersionForCard] No versions found for: "${cardName}"`);
                console.log(`[getPreferredVersionForCard] cardsByNameMap has:`, Object.keys(cardsByNameMap).filter(k => k.toLowerCase().includes(cardName.toLowerCase().substring(0, 5))).slice(0, 5));
            }
            
            if (versions.length === 0) return null;

            if (globalPref && (globalPref === 'max' || globalPref === 'min')) {
                // Set order (higher = newer): ASC=106 > MEG=105 > MEP=104, etc.
                const SET_ORDER = {
                    'PRE': 108, 'SFA': 107, 'ASC': 106,
                    'MEG': 105, 'MEP': 104, 'SP': 103, 'SVE': 102,
                    'SCR': 101, 'TWM': 100, 'TEF': 99, 'PAR': 98, 'PAF': 97, 'PAL': 96, 'OBF': 95,
                    'MEW': 94, 'SVI': 93, 'CRZ': 92, 'SIT': 91, 'LOR': 90, 'PGO': 89,
                    'BLK': 99, 'WHT': 98, 'SSP': 94,
                    'ASR': 88, 'BRS': 87, 'FST': 86, 'CEL': 85, 'EVS': 84, 'CRE': 83,
                    'BST': 82, 'SHF': 81, 'VIV': 80, 'CPA': 79, 'DAA': 78,
                    'RCL': 77, 'SSH': 76, 'CEC': 75
                };
                
                const sorted = versions.slice().sort((a, b) => {
                    const priorityA = getRarityPriority(a.rarity, a.set);
                    const priorityB = getRarityPriority(b.rarity, b.set);
                    
                    // Primary sort: by priority (rarity)
                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }
                    
                    // Secondary sort (same priority): by SET ORDER (newer sets first)
                    const setOrderA = SET_ORDER[a.set] || 0;
                    const setOrderB = SET_ORDER[b.set] || 0;
                    if (setOrderA !== setOrderB) {
                        return setOrderB - setOrderA; // Higher number = newer = preferred
                    }
                    
                    // Tertiary sort (same set): by set number (lower number first)
                    const numA = parseInt((a.number || '0').toString().replace(/[^\d]/g, '')) || 0;
                    const numB = parseInt((b.number || '0').toString().replace(/[^\d]/g, '')) || 0;
                    return numA - numB;
                });
                const selected = globalPref === 'max' ? sorted[sorted.length - 1] : sorted[0];
                
                // DEBUG: Log all versions and their priorities
                console.log(`[getPreferredVersionForCard] All versions for "${cardName}":`, 
                    versions.map((v, idx) => `${v.set} ${v.number} (${v.rarity || 'NO RARITY'}, priority: ${getRarityPriority(v.rarity, v.set)}, index: ${idx})`).join(', ')
                );
                console.log(`[getPreferredVersionForCard] Sorted order:`, 
                    sorted.map(v => `${v.set} ${v.number} (priority: ${getRarityPriority(v.rarity, v.set)})`).join(', ')
                );
                console.log(`[getPreferredVersionForCard] ${globalPref} rarity for "${cardName}": ${selected.set} ${selected.number} (${selected.rarity}, priority: ${getRarityPriority(selected.rarity, selected.set)})`);
                return selected;
            }

            // If no global preference (shouldn't happen as default is 'min'), return null
            if (!pref) {
                return null;
            }

            if (pref.mode === 'specific' && pref.set && pref.number) {
                return versions.find(v => v.set === pref.set && v.number === pref.number) || null;
            }

            if (pref.mode === 'max' || pref.mode === 'min') {
                const sorted = versions.slice().sort((a, b) => {
                    const priorityA = getRarityPriority(a.rarity, a.set);
                    const priorityB = getRarityPriority(b.rarity, b.set);
                    return priorityA - priorityB;
                });
                return pref.mode === 'max' ? sorted[sorted.length - 1] : sorted[0];
            }

            return null;
        }

        function getRarityPriority(rarity, setCode = '') {
            if (!rarity) {
                // Special handling: Promo sets without rarity should be treated between Low and Mid tier
                // Priority: Low Rarity (1-3) < Mid Rarity (5-9) < Promo (8) < High Rarity (10-16)
                const promoSets = ['MEP', 'SVP', 'SP', 'SMP', 'XYP', 'BWP', 'HSP', 'DPP', 'NP', 'WP'];
                if (setCode && promoSets.includes(setCode)) {
                    return 8; // Between Double Rare (6) and Amazing Rare (9) - Promos are collectible/valuable
                }
                return 0;
            }
            const r = rarity.toLowerCase();

            // Low Tier (1-3)
            if (r.includes('common')) return 1;
            if (r.includes('uncommon')) return 2;

            // High-end & secret rarities (check BEFORE plain rare to avoid matching "rare" in all)
            if (r.includes('secret rare')) return 16;
            if (r.includes('rainbow rare')) return 15;
            // SAR is most valuable in modern sets (MEG, TEF, TWM, etc.) - priority 14
            if (r.includes('special art rare') || r.includes('special illustration rare')) return 14;
            if (r.includes('ultra rare')) return 13;

            // Art rarities
            if (r.includes('shiny rare')) return 12; // Shiny Vault cards - below Ultra Rare
            if (r.includes('character super rare')) return 11;
            if (r.includes('character holo rare') || r.includes('art rare') || r.includes('illustration rare')) return 10;

            // Gameplay & Mid rarities
            if (r.includes('amazing rare')) return 9;
            if (r.includes('radiant rare')) return 8;
            if (r.includes('triple rare')) return 7;
            if (r.includes('double rare')) return 6;

            // Mid tier
            if (r.includes('holo rare')) return 5;
            
            // Plain rare (check BEFORE promo as catch-all for rare variants)
            if (r === 'rare' || r.includes('rare')) return 3;
            
            // Promo cards (MEP, SVP, etc.) - treated as collectible/valuable (priority 8)
            // This ensures normal Double Rares (6) are preferred over Promos in "min" mode
            if (r.includes('promo') || r === 'promo') return 8;

            return 0;
        }
        
        // Helper function to convert rarity to abbreviation for image URLs
        function getRarityAbbreviation(rarity) {
            if (!rarity) return 'C'; // Default to Common
            
            const rarityMap = {
                'Common': 'C',
                'Uncommon': 'U',
                'Rare': 'R',
                'Holo Rare': 'R',
                'Double Rare': 'R',
                'Ultra Rare': 'UR',
                'Special Art Rare': 'SAR',
                'Rainbow Rare': 'RR',
                'Secret Rare': 'SR',
                'Shiny Rare': 'SHR',
                'Art Rare': 'AR',
                'Promo': 'P'
            };
            
            return rarityMap[rarity] || 'R'; // Default to Rare if unknown
        }
        
        // Render generic table
        function renderTable(data, containerId, title) {
            const content = document.getElementById(containerId);
            if (!data || data.length === 0) return;
            
            const headers = Object.keys(data[0]);
            let html = `<h2>${title}</h2><table><thead><tr>`;
            
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            data.forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    html += `<td>${row[header]}</td>`;
                });
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            content.innerHTML = html;
        }
        
        // Load City League data from CSV (with cache-busting)
        let cityLeagueData = [];
        async function loadCityLeagueData() {
            const content = document.getElementById('cityLeagueContent');
            try {
                const timestamp = new Date().getTime();
                const response = await fetch(`${BASE_PATH}city_league_archetypes_comparison.csv?t=${timestamp}`);
                if (response.ok) {
                    const text = await response.text();
                    cityLeagueData = parseCSV(text);
                    
                    // Load tournament count and date range from main archetype CSV
                    let tournamentCount = 0;
                    let dateRange = '';
                    try {
                        const tournamentsResponse = await fetch(`${BASE_PATH}city_league_archetypes.csv?t=${timestamp}`);
                        if (tournamentsResponse.ok) {
                            const tournamentsText = await tournamentsResponse.text();
                            const tournamentsData = parseCSV(tournamentsText);
                            const uniqueTournaments = new Set(tournamentsData.map(d => d.tournament_id));
                            tournamentCount = uniqueTournaments.size;
                            
                            // Extract date range with proper date parsing
                            if (tournamentsData.length > 0) {
                                const dates = tournamentsData.map(d => d.date).filter(d => d);
                                if (dates.length > 0) {
                                    const parsedDates = dates.map(d => {
                                        const parts = d.split(' ');
                                        if (parts.length >= 3) {
                                            const day = parts[0];
                                            const month = parts[1];
                                            const year = parts[2];
                                            const monthMap = {'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'};
                                            const monthNum = monthMap[month] || '01';
                                            const fullYear = '20' + year;
                                            return {original: d, comparable: fullYear + monthNum + day.padStart(2, '0')};
                                        }
                                        return {original: d, comparable: '99999999'};
                                    });
                                    
                                    const minDateObj = parsedDates.reduce((a, b) => a.comparable < b.comparable ? a : b);
                                    const maxDateObj = parsedDates.reduce((a, b) => a.comparable > b.comparable ? a : b);
                                    dateRange = `${minDateObj.original} - ${maxDateObj.original}`;
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Could not load tournament data:', e);
                    }
                    
                    renderCityLeagueTable(tournamentCount, dateRange);
                    window.cityLeagueLoaded = true;
                } else {
                    content.innerHTML = '<div class="error">Fehler beim Laden der City League Meta Daten</div>';
                }
            } catch (error) {
                console.error('Error loading City League data:', error);
                content.innerHTML = '<div class="error">Fehler beim Laden der City League Meta Daten</div>';
            }
        }
        
        // Render City League table with full structure matching original HTML
        function renderCityLeagueTable(tournamentCount = 0, dateRange = '') {
            const content = document.getElementById('cityLeagueContent');
            if (!content || !cityLeagueData || cityLeagueData.length === 0) return;
            
            // Separate data by status and trend
            const newArchetypes = cityLeagueData.filter(d => d.status === 'NEU');
            const disappeared = cityLeagueData.filter(d => d.status === 'VERSCHWUNDEN');
            const increased = cityLeagueData.filter(d => d.status !== 'NEU' && parseInt(d.count_change || 0) > 0)
                .sort((a, b) => parseInt(b.count_change) - parseInt(a.count_change));
            const decreased = cityLeagueData.filter(d => parseInt(d.count_change || 0) < 0)
                .sort((a, b) => parseInt(a.count_change) - parseInt(b.count_change));
            
            // Get max count for threshold filtering
            const maxCountForThreshold = Math.max(...cityLeagueData.map(d => parseInt(d.new_count || 0)));
            const countThreshold = maxCountForThreshold * 0.1;
            
            // Performance improvers/decliners
            const improvers = cityLeagueData
                .filter(d => parseFloat((d.avg_placement_change || '0').replace(',', '.')) < 0 && parseInt(d.new_count || 0) >= countThreshold)
                .sort((a, b) => parseFloat((a.avg_placement_change || '0').replace(',', '.')) - parseFloat((b.avg_placement_change || '0').replace(',', '.')))
                .slice(0, 10);
            
            const decliners = cityLeagueData
                .filter(d => parseFloat((d.avg_placement_change || '0').replace(',', '.')) > 0 && parseInt(d.new_count || 0) >= countThreshold)
                .sort((a, b) => parseFloat((b.avg_placement_change || '0').replace(',', '.')) - parseFloat((a.avg_placement_change || '0').replace(',', '.')))
                .slice(0, 10);
            
            const sorted = [...cityLeagueData].sort((a, b) => parseInt(b.new_count || 0) - parseInt(a.new_count || 0));
            const totalArchetypes = cityLeagueData.length;
            
            // Generate timestamp
            const now = new Date();
            const generatedDate = now.toLocaleString('de-DE', { 
                year: 'numeric', month: '2-digit', day: '2-digit', 
                hour: '2-digit', minute: '2-digit', second: '2-digit' 
            });
            
            // Get top 3 by count and placement
            const topByCount = [...cityLeagueData]
                .sort((a, b) => parseInt(b.new_count || 0) - parseInt(a.new_count || 0))
                .slice(0, 3);
            
            const maxCount = parseInt(topByCount[0]?.new_count || 0);
            const minCountThreshold = maxCount * 0.1;
            const topByPlacement = [...cityLeagueData]
                .filter(d => parseInt(d.new_count || 0) >= minCountThreshold)
                .sort((a, b) => parseFloat((a.new_avg_placement || '0').replace(',', '.')) - parseFloat((b.new_avg_placement || '0').replace(',', '.')))
                .slice(0, 3);
            
            const top10New = [...cityLeagueData]
                .sort((a, b) => parseInt(b.new_count || 0) - parseInt(a.new_count || 0))
                .slice(0, 10)
                .map(d => d.archetype);
            const top10Old = [...cityLeagueData]
                .sort((a, b) => parseInt(b.old_count || 0) - parseInt(a.old_count || 0))
                .slice(0, 10)
                .map(d => d.archetype);
            
            const entries = top10New.filter(arch => !top10Old.includes(arch));
            const exits = top10Old.filter(arch => !top10New.includes(arch));
            
            let html = `
                <div style="background: #ecf0f1; padding: 15px; border-radius: 5px; margin-bottom: 30px; text-align: center;">
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">📅 Generated: ${generatedDate}</span>
                    <span style="display: inline-block; margin: 0 15px; font-weight: bold;">📊 Total Archetypes Tracked: ${totalArchetypes}</span>
                </div>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">📊 Archetype Overview</h3>
                        <div style="font-size: 2.5em; font-weight: bold; margin: 10px 0;">${totalArchetypes}</div>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 15px; text-align: left;">
                            <strong>Top 3 by Count:</strong><br>
                            ${topByCount.map(d => `${d.archetype}: ${d.new_count}x`).join('<br>')}
                            <br><br>
                            <strong>Top 3 by Avg Placement:</strong><br>
                            ${topByPlacement.map(d => `${d.archetype}: ${d.new_avg_placement}`).join('<br>')}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">🔄 Top 10 Changes</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px; text-align: left;">
                            ${entries.length > 0 ? `<strong style="color: #7fff7f;">⬆ Entries:</strong><br>${entries.map(arch => `${arch}`).join('<br>')}<br><br>` : ''}
                            ${exits.length > 0 ? `<strong style="color: #ff6b6b;">⬇ Exits:</strong><br>${exits.map(arch => `${arch}`).join('<br>')}<br>` : ''}
                            ${entries.length === 0 && exits.length === 0 ? 'No changes in top 10' : ''}
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);">
                        <h3 style="margin: 0 0 10px 0; font-size: 1.1em; opacity: 0.9;">📍 Datenquelle</h3>
                        <div style="font-size: 0.85em; opacity: 0.9; margin-top: 10px;">
                            <strong>Zeitraum:</strong><br>${dateRange || 'N/A'}<br><br>
                            <strong>Turniere:</strong><br>${tournamentCount || 0}
                        </div>
                    </div>
                </div>`;
            
            // Add conditional tables
            if (decreased.length > 0) {
                html += `
                    <div style="margin-bottom: 40px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">📉 Popularity Decreases</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Old Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">New Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Change</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Avg Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decreased.slice(0, 10).forEach(d => {
                    const change = parseInt(d.count_change || 0);
                    const placement_change = parseFloat((d.avg_placement_change || '0').replace(',', '.'));
                    const placement_color = placement_change < 0 ? '#27ae60' : '#e74c3c';
                    const archetypeEscaped = d.archetype.replace(/'/g, "\\'");
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f0f8ff'; this.style.cursor='pointer'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;" onclick="navigateToAnalysisWithDeck('${archetypeEscaped}')" title="Zur Analyse von ${d.archetype}">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.old_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count}</td>
                            <td style="padding: 12px; text-align: center; color: #e74c3c; font-weight: bold;">${change}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: ${placement_color}; font-weight: bold;">(${placement_change > 0 ? '+' : ''}${placement_change.toFixed(2)})</span></td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }
            
            if (improvers.length > 0 || decliners.length > 0) {
                // Container for side-by-side layout (Desktop) / stacked (Mobile)
                html += `<div style="display: flex; gap: 20px; margin-bottom: 40px; flex-wrap: wrap;">`;
            }
            
            if (improvers.length > 0) {
                // Performance Improvers
                html += `
                    <div style="flex: 1; min-width: 300px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">⭐ Performance Improvers (Better Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Avg. Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                improvers.slice(0, 10).forEach(d => {
                    const improvement = Math.abs(parseFloat((d.avg_placement_change || '0').replace(',', '.')));
                    const countChange = parseInt(d.new_count) - parseInt(d.old_count);
                    const countChangeText = countChange > 0 ? `+${countChange}` : `${countChange}`;
                    const archetypeEscaped = d.archetype.replace(/'/g, "\\'");
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f0f8ff'; this.style.cursor='pointer'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;" onclick="navigateToAnalysisWithDeck('${archetypeEscaped}')" title="Zur Analyse von ${d.archetype}">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count} <span style="color: #7f8c8d; font-size: 0.9em;">(${countChangeText})</span></td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: #27ae60; font-weight: bold;">(−${improvement.toFixed(2)})</span></td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }
            
            if (decliners.length > 0) {
                // Performance Decliners
                html += `
                    <div style="flex: 1; min-width: 300px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">📉 Performance Decliners (Worse Avg Placement)</h2>
                        <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <thead>
                                <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                    <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600;">Avg. Placement</th>
                                </tr>
                            </thead>
                            <tbody>`;
                decliners.slice(0, 10).forEach(d => {
                    const decline = parseFloat((d.avg_placement_change || '0').replace(',', '.'));
                    const countChange = parseInt(d.new_count) - parseInt(d.old_count);
                    const countChangeText = countChange > 0 ? `+${countChange}` : `${countChange}`;
                    const archetypeEscaped = d.archetype.replace(/'/g, "\\'");
                    html += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f0f8ff'; this.style.cursor='pointer'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;" onclick="navigateToAnalysisWithDeck('${archetypeEscaped}')" title="Zur Analyse von ${d.archetype}">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count} <span style="color: #7f8c8d; font-size: 0.9em;">(${countChangeText})</span></td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: #e74c3c; font-weight: bold;">(+${decline.toFixed(2)})</span></td>
                        </tr>`;
                });
                html += `</tbody></table></div>`;
            }
            
            // Close flex container if it was opened
            if (improvers.length > 0 || decliners.length > 0) {
                html += `</div>`; // Close flex container
            }
            
            // Full comparison tables - side by side on Desktop
            html += `
                <div style="display: flex; gap: 20px; margin-bottom: 40px; flex-wrap: wrap;">
                    <!-- Full Comparison Table (Detailed) -->
                    <div style="flex: 1; min-width: 350px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">📋 Full Comparison Table (Top 30)</h2>
                        <div style="margin-bottom: 15px;">
                            <input type="text" id="cityLeagueSearchFilter" placeholder="Suche z.B.: draga, luca" 
                                style="width: 100%; padding: 12px; font-size: 16px; border: 2px solid #3498db; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);"
                                oninput="filterCityLeagueTable()">
                            <div id="cityLeagueSearchResults" style="margin-top: 8px; font-size: 14px; color: #7f8c8d;"></div>
                        </div>
                        <div id="cityLeagueFullTable"></div>
                    </div>
                    
                    <!-- Grouped by Main Pokemon -->
                    <div style="flex: 1; min-width: 350px;">
                        <h2 style="color: #34495e; border-bottom: 3px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">🎯 Archetype Combined (Top 20)</h2>
                        <div style="margin-bottom: 15px; padding: 12px; background: #ecf0f1; border-radius: 5px; font-size: 0.9em; color: #7f8c8d;">
                            Kumulierte Zahlen aller Varianten eines Haupt-Pokemons (z.B. alle "dragapult *" Decks)
                        </div>
                        <div id="cityLeagueCombinedTable"></div>
                    </div>
                </div>`;
            
            content.innerHTML = html;
            
            // Store sorted data globally for filtering
            window.cityLeagueSortedData = sorted;
            
            // Group data by main Pokemon (first word)
            const groupedData = groupByMainPokemon(cityLeagueData);
            
            // Initial render
            renderFullComparisonTable(sorted.slice(0, 30));
            renderCombinedTable(groupedData.slice(0, 20));
        }
        
        // Group archetypes by main Pokemon (first word/words before space)
        function groupByMainPokemon(data) {
            const grouped = {};
            
            data.forEach(d => {
                // Extract main Pokemon name (everything before first space or whole name)
                // Handle multi-word Pokemon like "mega lucario", "mega froslass", "alolan exeggutor"
                let mainPokemon = d.archetype.toLowerCase();
                
                // Special handling for multi-word Pokemon
                if (mainPokemon.startsWith('mega ')) {
                    const parts = mainPokemon.split(' ');
                    mainPokemon = parts.slice(0, 2).join(' '); // "mega lucario"
                } else if (mainPokemon.startsWith('alolan ') || mainPokemon.startsWith('galarian ') || mainPokemon.startsWith('hisuian ')) {
                    const parts = mainPokemon.split(' ');
                    mainPokemon = parts.slice(0, 2).join(' '); // "alolan exeggutor"
                } else {
                    mainPokemon = mainPokemon.split(' ')[0]; // First word
                }
                
                if (!grouped[mainPokemon]) {
                    grouped[mainPokemon] = {
                        main: mainPokemon,
                        new_count: 0,
                        old_count: 0,
                        new_placement_sum: 0,
                        old_placement_sum: 0,
                        variants: []
                    };
                }
                
                grouped[mainPokemon].new_count += parseInt(d.new_count || 0);
                grouped[mainPokemon].old_count += parseInt(d.old_count || 0);
                grouped[mainPokemon].new_placement_sum += parseFloat((d.new_avg_placement || '0').replace(',', '.')) * parseInt(d.new_count || 0);
                grouped[mainPokemon].old_placement_sum += parseFloat((d.old_avg_placement || '0').replace(',', '.')) * parseInt(d.old_count || 0);
                grouped[mainPokemon].variants.push(d.archetype);
            });
            
            // Calculate weighted averages and format
            const result = Object.values(grouped).map(g => {
                const new_avg = g.new_count > 0 ? (g.new_placement_sum / g.new_count).toFixed(2) : '0.00';
                const old_avg = g.old_count > 0 ? (g.old_placement_sum / g.old_count).toFixed(2) : '0.00';
                const count_change = g.new_count - g.old_count;
                const avg_change = parseFloat(new_avg) - parseFloat(old_avg);
                
                return {
                    main: g.main,
                    new_count: g.new_count,
                    old_count: g.old_count,
                    count_change: count_change,
                    new_avg_placement: new_avg,
                    old_avg_placement: old_avg,
                    avg_placement_change: avg_change.toFixed(2),
                    variant_count: g.variants.length,
                    variants: g.variants
                };
            });
            
            // Sort by new_count descending
            return result.sort((a, b) => b.new_count - a.new_count);
        }
        
        // Render Combined Table
        function renderCombinedTable(data) {
            const container = document.getElementById('cityLeagueCombinedTable');
            if (!container) return;
            
            const isMobile = window.innerWidth <= 768;
            let tableHTML = '';
            
            if (isMobile) {
                // Mobile: Kompakte Version
                tableHTML = `
                <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 0.85em;">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 8px 4px; text-align: left; font-weight: 600;">Pokemon</th>
                            <th style="padding: 8px 4px; text-align: center; font-weight: 600;">Var.</th>
                            <th style="padding: 8px 4px; text-align: center; font-weight: 600;">Count</th>
                            <th style="padding: 8px 4px; text-align: center; font-weight: 600;">Avg.</th>
                        </tr>
                    </thead>
                    <tbody>`;
                
                data.forEach(d => {
                    const changeValue = parseInt(d.count_change || 0);
                    const changeColor = changeValue > 0 ? '#27ae60' : changeValue < 0 ? '#e74c3c' : '#95a5a6';
                    const placementChange = parseFloat(d.avg_placement_change || '0');
                    const placementColor = placementChange < 0 ? '#27ae60' : placementChange > 0 ? '#e74c3c' : '#95a5a6';
                    const displayName = d.main.charAt(0).toUpperCase() + d.main.slice(1);
                    
                    tableHTML += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" title="${d.variants.join(', ')}">
                            <td style="padding: 8px 4px; font-weight: bold; font-size: 0.9em;">${displayName}</td>
                            <td style="padding: 8px 4px; text-align: center; color: #7f8c8d; font-size: 0.85em;">${d.variant_count}</td>
                            <td style="padding: 8px 4px; text-align: center;">${d.new_count} <span style="color: ${changeColor}; font-weight: bold; font-size: 0.8em;">(${changeValue > 0 ? '+' : ''}${changeValue})</span></td>
                            <td style="padding: 8px 4px; text-align: center;">${d.new_avg_placement} <span style="color: ${placementColor}; font-weight: bold; font-size: 0.8em;">(${placementChange > 0 ? '+' : ''}${placementChange.toFixed(2)})</span></td>
                        </tr>`;
                });
                
                tableHTML += `</tbody></table>`;
            } else {
                // Desktop: Full Version
                tableHTML = `
                <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Main Pokemon</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Variants</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Avg. Placement</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
                data.forEach(d => {
                    const changeValue = parseInt(d.count_change || 0);
                    const changeColor = changeValue > 0 ? '#27ae60' : changeValue < 0 ? '#e74c3c' : '#95a5a6';
                    const changeText = changeValue > 0 ? `+${changeValue}` : `${changeValue}`;
                    
                    const placementChange = parseFloat(d.avg_placement_change || '0');
                    const placementColor = placementChange < 0 ? '#27ae60' : placementChange > 0 ? '#e74c3c' : '#95a5a6';
                    const placementText = placementChange > 0 ? `+${placementChange.toFixed(2)}` : placementChange.toFixed(2);
                    
                    // Capitalize first letter
                    const displayName = d.main.charAt(0).toUpperCase() + d.main.slice(1);
                    
                    tableHTML += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f8f9fa'" onmouseout="this.style.background=''" title="${d.variants.join(', ')}">
                            <td style="padding: 12px; font-weight: bold;">${displayName}</td>
                            <td style="padding: 12px; text-align: center; color: #7f8c8d;">${d.variant_count}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count} <span style="color: ${changeColor}; font-size: 0.9em;">(${changeText})</span></td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: ${placementColor}; font-weight: bold; font-size: 0.9em;">(${placementText})</span></td>
                        </tr>`;
                });
                
                tableHTML += `</tbody></table>`;
            }
            
            container.innerHTML = tableHTML;
        }
        
        // Render Full Comparison Table
        function renderFullComparisonTable(data) {
            const container = document.getElementById('cityLeagueFullTable');
            if (!container) return;
            
            const isMobile = window.innerWidth <= 768;
            let tableHTML = '';
            
            if (isMobile) {
                // Mobile: Kompakte Version
                tableHTML = `
                <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1); font-size: 0.85em;">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 8px 4px; text-align: left; font-weight: 600;">Deck</th>
                            <th style="padding: 8px 4px; text-align: center; font-weight: 600;">Count</th>
                            <th style="padding: 8px 4px; text-align: center; font-weight: 600;">Avg. Placement</th>
                        </tr>
                    </thead>
                    <tbody>`;
                
                data.forEach(d => {
                    const changeValue = parseInt(d.count_change || 0);
                    const changeColor = changeValue > 0 ? '#27ae60' : changeValue < 0 ? '#e74c3c' : '#95a5a6';
                    const placementChange = parseFloat((d.avg_placement_change || '0').replace(',', '.'));
                    const placementColor = placementChange < 0 ? '#27ae60' : placementChange > 0 ? '#e74c3c' : '#95a5a6';
                    const archetypeEscaped = d.archetype.replace(/'/g, "\\'");
                    
                    tableHTML += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f0f8ff'; this.style.cursor='pointer'" onmouseout="this.style.background=''">
                            <td style="padding: 8px 4px; font-weight: bold; font-size: 0.9em;" onclick="navigateToAnalysisWithDeck('${archetypeEscaped}')" title="Zur Analyse von ${d.archetype}">${d.archetype}</td>
                            <td style="padding: 8px 4px; text-align: center;">${d.new_count} <span style="color: ${changeColor}; font-weight: bold; font-size: 0.85em;">(${changeValue > 0 ? '+' : ''}${changeValue})</span></td>
                            <td style="padding: 8px 4px; text-align: center;">${d.new_avg_placement} <span style="color: ${placementColor}; font-weight: bold; font-size: 0.85em;">(${placementChange > 0 ? '+' : ''}${placementChange.toFixed(2)})</span></td>
                        </tr>`;
                });
                
                tableHTML += `</tbody></table>`;
            } else {
                // Desktop: Kompakte Version mit Änderungen in Klammern
                tableHTML = `
                <table style="width: 100%; border-collapse: collapse; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Archetype</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Count</th>
                            <th style="padding: 12px; text-align: center; font-weight: 600;">Avg. Placement</th>
                        </tr>
                    </thead>
                    <tbody>`;
            
                data.forEach(d => {
                    const changeValue = parseInt(d.count_change || 0);
                    const changeColor = changeValue > 0 ? '#27ae60' : changeValue < 0 ? '#e74c3c' : '#95a5a6';
                    const changeText = changeValue > 0 ? `+${changeValue}` : `${changeValue}`;
                    
                    const placementChange = parseFloat((d.avg_placement_change || '0').replace(',', '.'));
                    const placementColor = placementChange < 0 ? '#27ae60' : placementChange > 0 ? '#e74c3c' : '#95a5a6';
                    const placementText = placementChange > 0 ? `+${placementChange.toFixed(2)}` : placementChange.toFixed(2);
                    const archetypeEscaped = d.archetype.replace(/'/g, "\\'");
                    
                    tableHTML += `
                        <tr style="border-bottom: 1px solid #ecf0f1;" onmouseover="this.style.background='#f0f8ff'; this.style.cursor='pointer'" onmouseout="this.style.background=''">
                            <td style="padding: 12px; font-weight: bold;" onclick="navigateToAnalysisWithDeck('${archetypeEscaped}')" title="Zur Analyse von ${d.archetype}">${d.archetype}</td>
                            <td style="padding: 12px; text-align: center;">${d.new_count} <span style="color: ${changeColor}; font-size: 0.9em;">(${changeText})</span></td>
                            <td style="padding: 12px; text-align: center;">${d.new_avg_placement} <span style="color: ${placementColor}; font-weight: bold; font-size: 0.9em;">(${placementText})</span></td>
                        </tr>`;
                });
                
                tableHTML += `</tbody></table>`;
            }
            
            container.innerHTML = tableHTML;
        }
        
        // Filter City League Table
        function filterCityLeagueTable() {
            const searchInput = document.getElementById('cityLeagueSearchFilter');
            const resultsDiv = document.getElementById('cityLeagueSearchResults');
            if (!searchInput || !window.cityLeagueSortedData) return;
            
            const searchText = searchInput.value.trim();
            
            // If empty, show top 30
            if (!searchText) {
                renderFullComparisonTable(window.cityLeagueSortedData.slice(0, 30));
                resultsDiv.textContent = '';
                return;
            }
            
            // Split by comma and trim
            const searchTerms = searchText.split(',').map(term => term.trim().toLowerCase()).filter(term => term);
            
            // Filter: show decks that contain ANY of the search terms
            const filtered = window.cityLeagueSortedData.filter(d => {
                const archetype = d.archetype.toLowerCase();
                return searchTerms.some(term => archetype.includes(term));
            });
            
            // Render filtered results
            renderFullComparisonTable(filtered);
            
            // Update results info
            if (filtered.length === 0) {
                resultsDiv.textContent = 'Keine Ergebnisse gefunden';
                resultsDiv.style.color = '#e74c3c';
            } else {
                resultsDiv.textContent = `${filtered.length} Ergebnis${filtered.length !== 1 ? 'se' : ''} gefunden`;
                resultsDiv.style.color = '#27ae60';
            }
        }
        
        // Load City League Analysis
        async function loadCityLeagueAnalysis() {
            console.log('Loading City League Analysis...');
            const data = await loadCSV('city_league_analysis.csv');
            console.log('Loaded data:', data ? `${data.length} rows` : 'null');
            
            // Also load archetypes data for placement statistics
            const archetypesData = await loadCSV('city_league_archetypes.csv');
            console.log('Loaded archetypes data:', archetypesData ? `${archetypesData.length} rows` : 'null');
            
            // Load comparison data for current deck counts (new_count)
            const comparisonData = await loadCSV('city_league_archetypes_comparison.csv');
            console.log('Loaded comparison data:', comparisonData ? `${comparisonData.length} rows` : 'null');

            if (data && data.length > 0) {
                console.log('Processing archetypes...');
                window.cityLeagueAnalysisData = data;
                window.cityLeagueArchetypesData = archetypesData;
                window.cityLeagueComparisonData = comparisonData;
                populateCityLeagueDeckSelect(data, comparisonData);
                window.cityLeagueAnalysisLoaded = true;
            } else {
                const tableContainer = document.getElementById('cityLeagueAnalysisTable');
                if (tableContainer) {
                    const errorMsg = data === null ? 'Fehler beim Laden der City League Analysis Daten' : 'Keine Daten gefunden';
                    console.error(errorMsg);
                    tableContainer.innerHTML = `<div class="error">${errorMsg}</div>`;
                }
            }
        }
        
        function populateCityLeagueDeckSelect(data, comparisonData) {
            // Create a map of archetype names to their current deck counts from comparison data
            const comparisonMap = new Map();
            if (comparisonData && comparisonData.length > 0) {
                comparisonData.forEach(row => {
                    if (row.archetype && row.new_count) {
                        comparisonMap.set(row.archetype.toLowerCase(), parseInt(row.new_count || 0));
                    }
                });
                console.log('Loaded comparison counts for', comparisonMap.size, 'archetypes');
            }
            
            // Extract unique archetypes with their deck counts
            const archetypeMap = new Map();
            data.forEach(row => {
                if (row.archetype && !archetypeMap.has(row.archetype)) {
                    // Use new_count from comparison data if available, otherwise fall back to total_decks_in_archetype
                    const deckCount = comparisonMap.get(row.archetype.toLowerCase()) || parseInt(row.total_decks_in_archetype || 0);
                    archetypeMap.set(row.archetype, {
                        name: row.archetype,
                        deckCount: deckCount
                    });
                }
            });
            
            const archetypeList = Array.from(archetypeMap.values());
            console.log('Found archetypes:', archetypeList.length);
            
            // Sort by deck count descending to get top meta decks
            const sortedByMeta = [...archetypeList].sort((a, b) => b.deckCount - a.deckCount);
            const top10 = sortedByMeta.slice(0, 10);
            const rest = sortedByMeta.slice(10).sort((a, b) => a.name.localeCompare(b.name));
            
            console.log('Top 10 meta decks:', top10.map(d => `${d.name} (${d.deckCount})`));
            
            const select = document.getElementById('cityLeagueDeckSelect');
            if (!select) return;
            
            // Clear and repopulate
            select.innerHTML = '<option value="">-- Bitte Deck auswählen --</option>';
            
            // Add top 10 meta decks
            if (top10.length > 0) {
                const topGroup = document.createElement('optgroup');
                topGroup.label = '🔥 Top 10 Meta Decks';
                top10.forEach(archetype => {
                    const option = document.createElement('option');
                    option.value = archetype.name;
                    option.textContent = `${archetype.name} (${archetype.deckCount} Decks)`;
                    topGroup.appendChild(option);
                });
                select.appendChild(topGroup);
            }
            
            // Add remaining decks alphabetically
            if (rest.length > 0) {
                const restGroup = document.createElement('optgroup');
                restGroup.label = '📋 Weitere Decks (A-Z)';
                rest.forEach(archetype => {
                    const option = document.createElement('option');
                    option.value = archetype.name;
                    option.textContent = `${archetype.name} (${archetype.deckCount} Decks)`;
                    restGroup.appendChild(option);
                });
                select.appendChild(restGroup);
            }
            
            // Add change event listener
            select.onchange = function() {
                if (this.value) {
                    loadCityLeagueDeckData(this.value);
                    // Display the deck after loading archetype data
                    if (window.cityLeagueDeck && Object.keys(window.cityLeagueDeck).length > 0) {
                        updateDeckDisplay('cityLeague');
                        console.log('[Dropdown] Displaying saved deck for selected archetype');
                    }
                } else {
                    clearCityLeagueDeckView();
                }
            };
            
            // Enable search functionality
            const searchInput = document.getElementById('cityLeagueDeckSearch');
            if (searchInput) {
                searchInput.oninput = function() {
                    const searchTerm = this.value.toLowerCase();
                    // Search through all options in all optgroups
                    Array.from(select.querySelectorAll('option')).forEach(option => {
                        if (option.value) {
                            option.style.display = option.textContent.toLowerCase().includes(searchTerm) ? '' : 'none';
                        }
                    });
                    // Hide optgroups if all options are hidden
                    Array.from(select.querySelectorAll('optgroup')).forEach(group => {
                        const hasVisibleOptions = Array.from(group.querySelectorAll('option')).some(opt => opt.style.display !== 'none');
                        group.style.display = hasVisibleOptions ? '' : 'none';
                    });
                };
            }
        }
        
        // Date filter functions for City League
        function resetCityLeagueDateFilter() {
            const dateFromEl = document.getElementById('cityLeagueDateFrom');
            const dateToEl = document.getElementById('cityLeagueDateTo');
            
            if (dateFromEl) dateFromEl.value = '';
            if (dateToEl) dateToEl.value = '';
            
            window.cityLeagueDateFilterActive = false;
            updateCityLeagueDateFilterStatus();
            
            // Reload current deck if one is selected
            const cityLeagueDeckSelect = document.getElementById('cityLeagueDeckSelect');
            const selectedArchetype = cityLeagueDeckSelect ? cityLeagueDeckSelect.value : null;
            if (selectedArchetype) {
                loadCityLeagueDeckData(selectedArchetype);
            }
        }
        
        function applyCityLeagueDateFilter() {
            const dateFrom = document.getElementById('cityLeagueDateFrom').value;
            const dateTo = document.getElementById('cityLeagueDateTo').value;
            
            // Set filter active if at least one date is set
            if (dateFrom || dateTo) {
                window.cityLeagueDateFilterActive = true;
                window.cityLeagueDateFrom = dateFrom || '1900-01-01';
                window.cityLeagueDateTo = dateTo || '2099-12-31';
            } else {
                // If both dates are cleared, disable filter
                window.cityLeagueDateFilterActive = false;
            }
            
            updateCityLeagueDateFilterStatus();
            
            // Reload current deck if one is selected
            const selectedArchetype = document.getElementById('cityLeagueDeckSelect')?.value;
            if (selectedArchetype) {
                loadCityLeagueDeckData(selectedArchetype);
            }
        }
        
        function updateCityLeagueDateFilterStatus() {
            const statusEl = document.getElementById('cityLeagueDateFilterStatus');
            if (!statusEl) return;
            
            const dateFrom = document.getElementById('cityLeagueDateFrom').value;
            const dateTo = document.getElementById('cityLeagueDateTo').value;
            
            if (dateFrom && dateTo) {
                statusEl.textContent = `Gefiltert: ${formatDate(dateFrom)} bis ${formatDate(dateTo)}`;
                statusEl.style.color = 'rgba(255,255,255,1)';
            } else if (dateFrom) {
                statusEl.textContent = `Gefiltert: Ab ${formatDate(dateFrom)}`;
                statusEl.style.color = 'rgba(255,255,255,1)';
            } else if (dateTo) {
                statusEl.textContent = `Gefiltert: Bis ${formatDate(dateTo)}`;
                statusEl.style.color = 'rgba(255,255,255,1)';
            } else {
                statusEl.textContent = 'Alle Turniere werden angezeigt';
                statusEl.style.color = 'rgba(255,255,255,0.8)';
            }
        }
        
        function formatDate(dateStr) {
            if (!dateStr) return '';
            const date = new Date(dateStr + 'T00:00:00');
            const day = date.getDate();
            const month = date.getMonth() + 1;
            const year = date.getFullYear();
            return `${day.toString().padStart(2, '0')}.${month.toString().padStart(2, '0')}.${year}`;
        }
        
        // Parse Japanese date format (e.g., "01 Feb 26") to YYYY-MM-DD
        function parseJapaneseDate(dateStr) {
            if (!dateStr || dateStr.trim() === '') return '';
            
            const parts = dateStr.trim().split(/[.\s]+/);
            if (parts.length < 3) return '';
            
            const day = parts[0].padStart(2, '0');
            const monthStr = parts[1];
            const year = parts[2].length === 2 ? '20' + parts[2] : parts[2];
            
            const monthMap = {
                'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04', 'May': '05', 'Jun': '06',
                'Jul': '07', 'Aug': '08', 'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',
                'Januar': '01', 'Februar': '02', 'März': '03', 'April': '04', 'Mai': '05', 'Juni': '06',
                'Juli': '07', 'August': '08', 'September': '09', 'Oktober': '10', 'November': '11', 'Dezember': '12'
            };
            
            const month = monthMap[monthStr] || '01';
            return `${year}-${month}-${day}`;
        }
        
        // Recalculate card statistics based on filtered tournament data
        function recalculateCardStatsForFilteredData(filteredCards, archetype) {
            // Count unique tournaments/decks in filtered data
            const uniqueTournamentIds = new Set();
            filteredCards.forEach(card => {
                if (card.tournament_id) {
                    uniqueTournamentIds.add(card.tournament_id);
                }
            });
            const totalDecks = uniqueTournamentIds.size;
            
            // Group cards by card_name and recalculate stats
            const cardStatsMap = new Map();
            
            filteredCards.forEach(row => {
                const cardName = row.card_name;
                if (!cardStatsMap.has(cardName)) {
                    cardStatsMap.set(cardName, {
                        tournaments: new Set(),
                        counts: [],
                        sampleRow: row
                    });
                }
                
                const stats = cardStatsMap.get(cardName);
                if (row.tournament_id) {
                    stats.tournaments.add(row.tournament_id);
                }
                const count = parseInt(row.count || 0);
                if (count > 0) {
                    stats.counts.push(count);
                }
            });
            
            // Create new cards array with recalculated stats
            const recalculatedCards = [];
            cardStatsMap.forEach((stats, cardName) => {
                const row = { ...stats.sampleRow };
                
                // Recalculate deck_count (how many decks contain this card)
                const deck_count = stats.tournaments.size;
                
                // Recalculate max_count (most common count)
                let max_count = 0;
                if (stats.counts.length > 0) {
                    const countFrequency = {};
                    stats.counts.forEach(c => {
                        countFrequency[c] = (countFrequency[c] || 0) + 1;
                    });
                    max_count = parseInt(Object.keys(countFrequency).reduce((a, b) => 
                        countFrequency[a] > countFrequency[b] ? a : b
                    ));
                }
                
                // Recalculate percentage
                const percentage = totalDecks > 0 ? (deck_count / totalDecks * 100) : 0;
                
                // Recalculate average count
                const avg_count = stats.counts.length > 0 
                    ? (stats.counts.reduce((a, b) => a + b, 0) / stats.counts.length) 
                    : 0;
                
                // Update row with recalculated values
                row.deck_count_in_selected = deck_count;
                row.max_count = max_count;
                row.percentage_in_archetype = percentage.toFixed(1);
                row.avg_count = avg_count.toFixed(2);
                row.total_decks_in_archetype = totalDecks;
                
                recalculatedCards.push(row);
            });
            
            console.log(`Recalculated stats for ${recalculatedCards.length} unique cards based on ${totalDecks} filtered tournaments`);
            return recalculatedCards;
        }
        
        // Aggregate card statistics from filtered tournament data
        function aggregateCardStatsByDate(filteredCards) {
            // Group by card_name
            const cardMap = new Map();
            
            // Calculate total decks across all tournaments
            // For each unique tournament date, get the total_decks_in_archetype value
            const tournamentDecksMap = new Map();
            filteredCards.forEach(row => {
                if (row.tournament_date) {
                    const date = row.tournament_date;
                    const decksInTournament = parseInt(row.total_decks_in_archetype || 0);
                    tournamentDecksMap.set(date, decksInTournament);
                }
            });
            
            // Sum up decks across all tournaments
            let totalDecks = 0;
            tournamentDecksMap.forEach(decks => {
                totalDecks += decks;
            });
            
            console.log('DEBUG: Tournament deck counts:', Array.from(tournamentDecksMap.entries()));
            console.log('DEBUG: Total decks across all tournaments:', totalDecks);
            
            filteredCards.forEach(row => {
      const cardName = row.card_name;
                
                if (!cardMap.has(cardName)) {
                    cardMap.set(cardName, {
                        sampleRow: row,
                        totalCount: 0,
                        maxCountValues: [],
                        deckCounts: 0,
                        tournamentsWithCard: new Set(),
                        tournamentDeckCountsWithCard: new Map()
                    });
                } else {
                    const cardData = cardMap.get(cardName);
                    // Update sample row if current row has more complete data
                    if (!cardData.sampleRow.image_url && row.image_url) {
                        cardData.sampleRow = row;
                    } else if (!cardData.sampleRow.set_code && row.set_code) {
                        cardData.sampleRow = row;
                    }
                }
                
                const cardData = cardMap.get(cardName);
                
                // Aggregate counts
                cardData.totalCount += parseInt(row.total_count || 0);
                const maxCount = parseInt(row.max_count || 0);
                if (maxCount > 0) {
                    cardData.maxCountValues.push(maxCount);
                }
                cardData.deckCounts += parseInt(row.deck_count || 0);
                
                if (row.tournament_date) {
                    cardData.tournamentsWithCard.add(row.tournament_date);
                    // Track deck count for each tournament where this card appeared
                    const decksInTournament = parseInt(row.total_decks_in_archetype || 0);
                    cardData.tournamentDeckCountsWithCard.set(row.tournament_date, decksInTournament);
                }
            });
            
            // Create aggregated result
            const result = [];
            
            cardMap.forEach((data, cardName) => {
                const row = { ...data.sampleRow };
                
                // Calculate aggregated max_count (most common value)
                let max_count = 0;
                if (data.maxCountValues.length > 0) {
                    const countFreq = {};
                    data.maxCountValues.forEach(val => {
                        countFreq[val] = (countFreq[val] || 0) + 1;
                    });
                    max_count = parseInt(Object.keys(countFreq).reduce((a, b) => 
                        countFreq[a] > countFreq[b] ? a : b
                    ));
                }
                
                // Calculate percentage based on actual deck counts
                // data.deckCounts is the sum of deck_count values (number of decks containing this card)
                // totalDecks is the sum of total_decks_in_archetype values (total number of decks in all tournaments)
                const percentage = totalDecks > 0 ? (data.deckCounts / totalDecks * 100) : 0;
                
                // Calculate average count
                const tournamentsWithCard = data.tournamentsWithCard.size;
                const avgCount = tournamentsWithCard > 0 ? (data.totalCount / tournamentsWithCard) : 0;
                
                // Update row and preserve important fields from sampleRow
                row.total_count = data.totalCount;
                row.max_count = max_count;
                row.deck_count = data.deckCounts;
                row.deck_count_in_selected = data.deckCounts; // Number of decks containing this card
                row.total_decks_in_archetype = totalDecks;
                row.percentage_in_archetype = percentage.toFixed(1);
                row.avg_count = avgCount.toFixed(2);
                // Explicitly preserve these fields from sampleRow
                row.set_code = data.sampleRow.set_code || '';
                row.image_url = data.sampleRow.image_url || '';
                row.rarity = data.sampleRow.rarity || '';
                row.set_number = data.sampleRow.set_number || '';
                
                // Debug: Log M3 cards
                if (row.set_code === 'M3' || (row.image_url && row.image_url.includes('/M3/'))) {
                    console.log(`M3 card aggregated: ${row.card_name}, set_code: ${row.set_code}, url: ${row.image_url}`);
                }
                
                result.push(row);
            });
            
            console.log(`Aggregated ${result.length} unique cards from ${totalDecks} decks across ${tournamentDecksMap.size} tournaments`);
            return result;
        }
        
        function loadCityLeagueDeckData(archetype) {
            console.log('Loading deck data for:', archetype);
            const data = window.cityLeagueAnalysisData;
            if (!data) return;
            
            // Store current archetype
            window.currentCityLeagueArchetype = archetype;
            
            // Check if we have a saved deck for this archetype
            const savedDeck = localStorage.getItem('cityLeagueDeck');
            if (savedDeck) {
                try {
                    const parsed = JSON.parse(savedDeck);
                    if (parsed.archetype === archetype) {
                        // Deck matches current archetype - already loaded
                        console.log('[loadCityLeagueDeckData] Deck already loaded for this archetype');
                    } else {
                        // Different archetype - CLEAR old deck
                        console.log('[loadCityLeagueDeckData] Clearing old deck from different archetype:', parsed.archetype);
                        window.cityLeagueDeck = {};
                        window.cityLeagueDeckOrder = [];
                        saveCityLeagueDeck();
                    }
                } catch (e) {
                    console.error('[loadCityLeagueDeckData] Error reading saved deck:', e);
                }
            }
            
            // Filter cards for this archetype
            let deckCards = data.filter(row => row.archetype === archetype);
            console.log('Found cards (before date filter):', deckCards.length);
            
            // Apply date filter if active
            if (window.cityLeagueDateFilterActive) {
                const dateFrom = window.cityLeagueDateFrom;
                const dateTo = window.cityLeagueDateTo;
                
                console.log('DEBUG: Filtering by date range:', dateFrom, 'to', dateTo);
                
                const dateDebugSample = [];
                deckCards = deckCards.filter(row => {
                    const tournamentDate = parseJapaneseDate(row.tournament_date);
                    
                    // Collect first 5 examples for debugging
                    if (dateDebugSample.length < 5) {
                        dateDebugSample.push({
                            raw: row.tournament_date,
                            parsed: tournamentDate,
                            passes: tournamentDate && tournamentDate >= dateFrom && tournamentDate <= dateTo
                        });
                    }
                    
                   if (!tournamentDate) return false; // Exclude cards without valid date when filter is active
                    return tournamentDate >= dateFrom && tournamentDate <= dateTo;
                });
                
                console.log('DEBUG: Date filter examples:', dateDebugSample);
                console.log(`Date filter applied (${dateFrom} to ${dateTo}):`, deckCards.length, 'cards');
            }
            
            console.log('Found cards (before deduplication):', deckCards.length);
            
            // Aggregate cards stats if date filter is active
            if (window.cityLeagueDateFilterActive && deckCards.length > 0) {
                deckCards = aggregateCardStatsByDate(deckCards);
                console.log('After aggregating by date:', deckCards.length, 'unique cards');
            }
            
            // Dedupliziere: Nur neueste low-rarity Version pro Karte
            deckCards = deduplicateCards(deckCards);
            console.log('Found cards (after deduplication):', deckCards.length);
            
            // Store unfiltered deck cards for filter function
            window.currentCityLeagueDeckCards = deckCards;
            
            // Calculate stats - use max_count which represents typical deck composition
            const totalCardsInDeck = deckCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            const uniqueCards = deckCards.length;
            
            // Get current deck count - depends on whether date filter is active
            let decksCount = '-';
            
            if (window.cityLeagueDateFilterActive) {
                // When date filter is active, use the aggregated total_decks_in_archetype
                // This value was already calculated correctly in aggregateCardStatsByDate()
                decksCount = deckCards[0]?.total_decks_in_archetype || '-';
                console.log(`Using deck count from filtered/aggregated data: ${decksCount} decks`);
            } else {
                // No date filter - use total count from comparison data
                const comparisonData = window.cityLeagueComparisonData || [];
                const comparisonMatch = comparisonData.find(row => 
                    row.archetype && row.archetype.toLowerCase() === archetype.toLowerCase()
                );
                if (comparisonMatch && comparisonMatch.new_count) {
                    decksCount = comparisonMatch.new_count;
                    console.log(`Using current deck count from comparison data: ${decksCount}`);
                } else {
                    // Fallback to analysis data if comparison not available
                    decksCount = deckCards[0]?.total_decks_in_archetype || '-';
                    console.log(`Fallback to analysis data deck count: ${decksCount}`);
                }
            }
            
            // Calculate average placement from archetypes data
            const archetypesData = window.cityLeagueArchetypesData || [];
            const archetypeMatches = archetypesData.filter(row => 
                row.archetype && row.archetype.toLowerCase() === archetype.toLowerCase()
            );
            const avgPlacement = archetypeMatches.length > 0
                ? (archetypeMatches.reduce((sum, row) => sum + parseInt(row.placement || 0), 0) / archetypeMatches.length).toFixed(2)
                : '-';
            
            // Update stats
            document.getElementById('cityLeagueStatCards').textContent = `${uniqueCards} / ${totalCardsInDeck}`;
            document.getElementById('cityLeagueStatDecksUsed').textContent = decksCount;
            document.getElementById('cityLeagueStatAvgPlacement').textContent = avgPlacement !== '-' ? avgPlacement : '-';
            document.getElementById('cityLeagueStatsSection').style.display = 'block';
            
            // Show deck visual (default: grid view)
            renderCityLeagueDeckGrid(deckCards);
            
            // Reset button text to show list view option
            const gridButtons = document.querySelectorAll('button[onclick="toggleDeckGridView()"]');
            gridButtons.forEach(btn => btn.textContent = '📋 List View');
            
            // Apply current filter (this will update counts and re-filter if needed)
            applyCityLeagueFilter();
            
            // DON'T auto-display deck here - let the caller decide
            // (only display when user actively selects archetype from dropdown)
        }
        
        function clearCityLeagueDeckView() {
            document.getElementById('cityLeagueStatsSection').style.display = 'none';
            document.getElementById('cityLeagueDeckVisual').style.display = 'none';
            document.getElementById('cityLeagueDeckTableView').style.display = 'none';
            document.getElementById('cityLeagueCardCount').textContent = '0 Karten';
            document.getElementById('cityLeagueCardCountSummary').textContent = '/ 0 Total';
            
            // Reset button text
            const gridButtons = document.querySelectorAll('button[onclick="toggleDeckGridView()"]');
            gridButtons.forEach(btn => btn.textContent = '📋 List View');
        }
        
        // Helper function to fix Japanese card image URLs
        function fixJapaneseCardImageUrl(url, setCode) {
            if (!url) return url;
            
            // M3 set cards need URL correction for Japanese versions
            // English: tpci/M3/M3_046_R_EN_LG.png (with leading zero)
            // Japanese: tpc/M3/M3_46_R_JP_LG.png (without leading zero)
            const isM3Set = setCode === 'M3' || url.includes('/M3/');
            const hasEnInUrl = url.includes('_EN_');
            
            if (isM3Set && hasEnInUrl) {
                const originalUrl = url;
                
                // Replace tpci with tpc
                url = url.replace('/tpci/', '/tpc/');
                
                // Replace EN with JP
                url = url.replace(/_EN_/g, '_JP_');
                
                // Remove leading zeros from card number (M3_046 → M3_46)
                url = url.replace(/\/M3_0+(\d+)_/g, '/M3_$1_');
                
                console.log(`M3 URL corrected: ${originalUrl} → ${url}`);
            }
            
            return url;
        }
        
        // Render function for table view (default, detailed view)
        function renderCityLeagueDeckTable(cards) {
            const tableContainer = document.getElementById('cityLeagueDeckTable');
            const tableViewContainer = document.getElementById('cityLeagueDeckTableView');
            if (!tableContainer) return;
            
            // Use the same sorting logic
            const sortedCards = sortCardsByType([...cards]);
            
            // Get current deck to show deck counts
            const currentDeck = window.cityLeagueDeck || {};
            
            let html = '<div style="display: flex; flex-direction: column; gap: 15px;">';
            sortedCards.forEach(card => {
                const cardName = card.card_name;
                
                // CRITICAL: Use same version selection logic as Grid View
                // This ensures List View shows the same version (e.g., ASC instead of MEG)
                let displayCard = card;
                const allCards = window.allCardsDatabase || [];
                const allVersions = allCards.filter(c => c.name === cardName && c.set && c.number);
                
                if (overviewRarityMode !== 'all' && allVersions.length > 0) {
                    // Set order (higher = newer): ASC=106 > MEG=105, etc.
                    const SET_ORDER = {
                        'PRE': 108, 'SFA': 107, 'ASC': 106,
                        'MEG': 105, 'MEP': 104, 'SP': 103, 'SVE': 102,
                        'SCR': 101, 'TWM': 100, 'TEF': 99, 'PAR': 98, 'PAF': 97, 'PAL': 96, 'OBF': 95,
                        'MEW': 94, 'SVI': 93, 'CRZ': 92, 'SIT': 91, 'LOR': 90, 'PGO': 89,
                        'BLK': 99, 'WHT': 98, 'SSP': 94,
                        'ASR': 88, 'BRS': 87, 'FST': 86, 'CEL': 85, 'EVS': 84, 'CRE': 83,
                        'BST': 82, 'SHF': 81, 'VIV': 80, 'CPA': 79, 'DAA': 78,
                        'RCL': 77, 'SSH': 76, 'CEC': 75
                    };
                    
                    const getRarityValue = (card) => {
                        const r = (card.rarity || card.card_rarity || '').toLowerCase();
                        if (!r || r === '' || r === 'none' || r === 'no rarity') return 0;
                        if (r.includes('common')) return 1;
                        if (r.includes('uncommon')) return 2;
                        if (r.includes('rare') && !r.includes('ultra') && !r.includes('secret') && !r.includes('hyper')) return 3;
                        if (r.includes('promo')) return 4;
                        if (r.includes('double rare')) return 5;
                        if (r.includes('ultra rare')) return 6;
                        if (r.includes('special art rare') || r.includes('special illustration rare')) return 7;
                        if (r.includes('secret rare')) return 8;
                        if (r.includes('hyper rare')) return 9;
                        return -1;
                    };
                    
                    allVersions.sort((a, b) => {
                        const rarityA = getRarityValue(a);
                        const rarityB = getRarityValue(b);
                        
                        // Primary sort: by rarity value
                        const rarityDiff = overviewRarityMode === 'min' ? rarityA - rarityB : rarityB - rarityA;
                        if (rarityDiff !== 0) {
                            return rarityDiff;
                        }
                        
                        // Secondary sort (same rarity): prefer NEWER sets (ASC > MEG)
                        const setOrderA = SET_ORDER[a.set] || 0;
                        const setOrderB = SET_ORDER[b.set] || 0;
                        return setOrderB - setOrderA;
                    });
                    
                    const preferredVersion = allVersions[0];
                    displayCard = {
                        ...card,
                        set_code: preferredVersion.set,
                        set_number: preferredVersion.number,
                        image_url: preferredVersion.image_url || card.image_url
                    };
                }
                
                const imageUrl = fixJapaneseCardImageUrl(displayCard.image_url || '', displayCard.set_code);
                const percentage = parseFloat(card.percentage_in_archetype || 0).toFixed(1);
                const maxCount = card.max_count || '?';
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                const setCode = displayCard.set_code || '';
                const setNumber = displayCard.set_number || '';
                
                // CRITICAL: Match by SET CODE + SET NUMBER only (not card name)
                let deckCount = 0;
                if (setCode && setNumber) {
                    for (const deckKey in currentDeck) {
                        const match = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                        if (match) {
                            const deckSetCode = match[1];
                            const deckSetNumber = match[2];
                            if (deckSetCode === setCode && deckSetNumber === setNumber) {
                                deckCount = currentDeck[deckKey] || 0;
                                break;
                            }
                        }
                    }
                } else {
                    deckCount = currentDeck[cardName] || 0;
                }
                
                // Get deck statistics
                const decksWithCard = parseInt(card.deck_count || 0);
                const totalDecksInArchetype = parseInt(card.total_decks_in_archetype || 1);
                const totalCount = parseInt(card.total_count || 0);
                const avgCountOverall = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0.00';
                const avgCountInUsedDecks = decksWithCard > 0 ? (totalCount / decksWithCard).toFixed(2) : '0.00';
                
                html += `
                    <div class="card-table-row" data-card-name="${cardName.toLowerCase()}" style="display: flex; align-items: center; background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); gap: 20px;">
                        <!-- Card Image -->
                        <div style="flex-shrink: 0; position: relative; width: 120px;">
                            <img src="${imageUrl}" alt="${cardName}" referrerpolicy="no-referrer" style="width: 100%; border-radius: 6px; cursor: zoom-in; aspect-ratio: 2.5/3.5; object-fit: cover;" onerror="this.style.opacity='0.3'" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped}');">
                            ${deckCount > 0 ? `<div style="position: absolute; top: 5px; left: 5px; background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.85em; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${deckCount}</div>` : ''}
                        </div>
                        
                        <!-- Card Info -->
                        <div style="flex-grow: 1; min-width: 0;">
                            <h3 style="margin: 0 0 8px 0; font-size: 1.2em; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${cardName}</h3>
                            <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">${setCode} ${setNumber}</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 10px;">
                                <div>
                                    <span style="color: #999; font-size: 0.85em;">Nutzungs Share:</span>
                                    <span style="font-weight: 600; color: #333; margin-left: 5px; font-size: 0.95em;">${percentage}%</span>
                                </div>
                                <div>
                                    <span style="color: #999; font-size: 0.85em;">Ø in genutzten Decks:</span>
                                    <span style="font-weight: 600; color: #333; margin-left: 5px; font-size: 0.95em;">${avgCountInUsedDecks}x</span>
                                </div>
                                <div>
                                    <span style="color: #999; font-size: 0.85em;">Ø durch alle Decks:</span>
                                    <span style="font-weight: 600; color: #333; margin-left: 5px; font-size: 0.95em;">${avgCountOverall}x</span>
                                </div>
                                <div>
                                    <span style="color: #999; font-size: 0.85em;">Deck Count:</span>
                                    <span style="font-weight: 600; color: #333; margin-left: 5px; font-size: 0.95em;">${decksWithCard} / ${totalDecksInArchetype} Decks</span>
                                </div>
                                <div>
                                    <span style="color: #999; font-size: 0.85em;">Max Count:</span>
                                    <span style="font-weight: 600; color: #dc3545; margin-left: 5px; font-size: 0.95em;">${maxCount}</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Add Button -->
                        <div style="flex-shrink: 0;">
                            <button class="btn btn-success" style="padding: 10px 20px; font-size: 0.95em; white-space: nowrap;" onclick="addCardToDeck('cityLeague', '${cardNameEscaped}', '${setCode}', '${setNumber}')" title="Add to deck">Add to Deck</button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            tableContainer.innerHTML = html;
            tableViewContainer.style.display = 'block';
        }
        
        // Get all versions of a card from allCardsDatabase
        function getAllVersionsOfCard(cardName) {
            const allCards = window.allCardsDatabase || [];
            return allCards.filter(c => c.name === cardName);
        }
        
        // Set overview rarity mode and refresh display
        function setOverviewRarityMode(mode) {
            console.log('🔄 Setting overview rarity mode to:', mode);
            overviewRarityMode = mode;
            
            // Synchronize with global rarity preference so deck builder uses same setting
            // For 'all' mode, keep original cards (no preference), otherwise use min/max
            if (mode === 'all') {
                // For "Alle Prints" mode in deck builder, use original card (no rarity swap)
                globalRarityPreference = null;
            } else {
                globalRarityPreference = mode; // 'min' or 'max'
            }
            console.log('🎯 Global rarity preference synced to:', globalRarityPreference || 'none (original cards)');
            
            // Update button styles - make sure elements exist first
            const btnMin = document.getElementById('overviewRarityMin');
            const btnMax = document.getElementById('overviewRarityMax');
            const btnAll = document.getElementById('overviewRarityAll');
            
            if (btnMin) btnMin.style.opacity = mode === 'min' ? '1' : '0.6';
            if (btnMax) btnMax.style.opacity = mode === 'max' ? '1' : '0.6';
            if (btnAll) btnAll.style.opacity = mode === 'all' ? '1' : '0.6';
            
            // Re-render the grid with current cards (preserve percentage filter)
            const cards = window.currentCityLeagueDeckCards;
            console.log('📊 Cards available for re-render:', cards ? cards.length : 'none');
            if (cards && cards.length > 0) {
                console.log('✅ Re-rendering grid with mode:', mode);
                applyCityLeagueFilter();  // Use filter function to preserve percentage filter
            } else {
                console.warn('⚠️ No cards available to render - mode saved for when deck is selected');
            }
            
            // Also update the deck display with new rarity preference
            if (window.cityLeagueDeck && Object.keys(window.cityLeagueDeck).length > 0) {
                console.log('🔄 Re-rendering deck with new rarity preference');
                updateDeckDisplay('cityLeague');
            }
        }
        
        // Render function for grid view (compact view)
        function renderCityLeagueDeckGrid(cards) {
            console.log('🎨 renderCityLeagueDeckGrid called with:', cards.length, 'cards, mode:', overviewRarityMode);
            const visualContainer = document.getElementById('cityLeagueDeckVisual');
            const gridContainer = document.getElementById('cityLeagueDeckGrid');
            if (!gridContainer) return;
            
            // Use the same sorting logic as "Karten Übersicht (sortiert)"
            const sortedCards = sortCardsByType([...cards]);
            
            // Get current deck to show deck counts
            const currentDeck = window.cityLeagueDeck || {};
            
            let html = '';
            sortedCards.forEach(card => {
                const cardName = card.card_name;
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                
                // Get original card's set/number from the City League deck data
                const originalSetCode = card.set_code || '';
                const originalSetNumber = card.set_number || '';
                
                // Apply rarity mode to determine which versions to show
                let versionsToRender = [];
                
                if (overviewRarityMode === 'all') {
                    // Show ALL international prints of this specific card
                    let allVersions = getInternationalPrintsForCard(originalSetCode, originalSetNumber);
                    console.log(`📦 All mode for ${cardName} (${originalSetCode} ${originalSetNumber}): found ${allVersions.length} int prints`);
                    
                    if (allVersions && allVersions.length > 0) {
                        versionsToRender = allVersions.map(v => ({
                            ...card,
                            set_code: v.set,
                            set_number: v.number,
                            image_url: v.image_url,
                            rarity: v.rarity
                        }));
                    } else {
                        // No versions found in database, use original card
                        versionsToRender = [card];
                    }
                } else {
                    // 'min' or 'max' mode: Get preferred version (lowest/highest rarity, prefer NEWER sets)
                    const preferredVersion = getPreferredVersionForCard(cardName, originalSetCode, originalSetNumber);
                    
                    if (preferredVersion) {
                        console.log(`🎯 ${overviewRarityMode} mode for ${cardName}: using PREFERRED version ${preferredVersion.set} ${preferredVersion.number} (${preferredVersion.rarity})`);
                        versionsToRender = [{
                            ...card,
                            set_code: preferredVersion.set,
                            set_number: preferredVersion.number,
                            image_url: preferredVersion.image_url,
                            rarity: preferredVersion.rarity
                        }];
                    } else {
                        // No preferred version found, use original
                        console.log(`⚠️ ${overviewRarityMode} mode for ${cardName}: no preferred version found, using original`);
                        versionsToRender = [card];
                    }
                }
                
                // Render each version
                versionsToRender.forEach(displayCard => {
                    const setCode = displayCard.set_code || '';
                    const setNumber = displayCard.set_number || '';
                
                const imageUrl = fixJapaneseCardImageUrl(displayCard.image_url || '', setCode);
                const percentage = parseFloat(card.percentage_in_archetype || 0).toFixed(1);
                const maxCount = card.max_count || '?';
                
                // CRITICAL: ALWAYS show green marker ONLY on the exact version that is in the deck
                // Match by SET CODE + SET NUMBER only (not by card name, which may differ in different languages)
                let deckCount = 0;
                
                console.log(`🔍 [Grid Badge Match] Checking ${cardName} (${setCode} ${setNumber})`);
                console.log(`   Current deck keys:`, Object.keys(currentDeck));
                
                if (setCode && setNumber) {
                    // Loop through all deck entries and match by set/number only
                    for (const deckKey in currentDeck) {
                        // Extract set and number from deckKey format: "CardName (SET NUM)"
                        const match = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                        if (match) {
                            const deckSetCode = match[1];
                            const deckSetNumber = match[2];
                            
                            console.log(`   Comparing: ${setCode} ${setNumber} vs ${deckSetCode} ${deckSetNumber} (${deckKey})`);
                            
                            // Match by set code and number ONLY (ignore card name)
                            if (deckSetCode === setCode && deckSetNumber === setNumber) {
                                deckCount = currentDeck[deckKey] || 0;
                                console.log(`   ✅ MATCH! deckCount = ${deckCount}`);
                                break;
                            }
                        }
                    }
                } else {
                    // Fallback: If no set/number available, try exact card name match
                    deckCount = currentDeck[cardName] || 0;
                }
                
                if (deckCount === 0) {
                    console.log(`   ❌ No match found for ${cardName} (${setCode} ${setNumber})`);
                } else {
                    console.log(`   ✅ Final deckCount = ${deckCount}`);
                }
                
                // Get deck statistics: how many decks use this card vs total decks in archetype
                const decksWithCard = parseInt(card.deck_count || 0);  // Number of decks that contain this card
                const totalDecksInArchetype = parseInt(card.total_decks_in_archetype || 1);
                
                // Get average count statistics
                const totalCount = parseInt(card.total_count || 0);
                const avgCountOverall = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0.00';  // Average over all decks
                const avgCountInUsedDecks = decksWithCard > 0 ? (totalCount / decksWithCard).toFixed(2) : '0.00';  // Average in decks that use this card
                
                // Get price and Cardmarket URL from allCardsDatabase
                let eurPrice = '';
                let cardmarketUrl = '';
                if (setCode && setNumber && allCardsDatabase) {
                    const priceCard = allCardsDatabase.find(c => 
                        c.set === setCode && c.number === setNumber
                    );
                    if (priceCard) {
                        eurPrice = priceCard.eur_price || '';
                        cardmarketUrl = priceCard.cardmarket_url || '';
                    }
                }
                const priceDisplay = eurPrice || '0,00€';
                const priceBackground = eurPrice ? 'linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%)' : 'linear-gradient(135deg, #777 0%, #999 100%)';
                const cardmarketUrlEscaped = (cardmarketUrl || '').replace(/'/g, "\\'");
                
                html += `
                    <div class="card-item" data-card-name="${cardName.toLowerCase()}" style="position: relative; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; background: white;">
                        <div style="position: relative; width: 100%;">
                            <img src="${imageUrl}" alt="${cardName}" referrerpolicy="no-referrer" style="width: 100%; aspect-ratio: 2.5/3.5; object-fit: cover; cursor: zoom-in;" onerror="this.style.opacity='0.3'" onclick="event.stopPropagation(); showSingleCard('${imageUrl}', '${cardNameEscaped}');">
                            
                            <!-- Red badge: Max Count (top-right) -->
                            <div style="position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">
                                ${maxCount}
                            </div>
                            
                            <!-- Green badge: Deck Count (top-left) - only show if > 0 -->
                            ${deckCount > 0 ? `<div style="position: absolute; top: 5px; left: 5px; background: #28a745; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">${deckCount}</div>` : ''}
                        </div>
                        
                        <!-- Card info section -->
                        <div style="padding: 8px; background: white; font-size: 0.75em; text-align: center; min-height: 60px; display: flex; flex-direction: column; justify-content: space-between;">
                            <div>
                                <div style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 600; margin-bottom: 3px; color: #333; font-size: 0.9em;">
                                    ${cardName}
                                </div>
                                <div style="color: #999; font-size: 0.75em; margin-bottom: 3px;">
                                    ${setCode} ${setNumber}
                                </div>
                                <div style="color: #666; font-size: 0.85em; margin-bottom: 3px;">
                                    ${percentage}% | Ø ${avgCountInUsedDecks}x (${avgCountOverall}x)
                                </div>
                                <div style="font-weight: 600; color: #333; font-size: 0.9em;">
                                    ${decksWithCard} / ${totalDecksInArchetype} Decks
                                </div>
                            </div>
                            
                            <!-- Rarity Switcher & Actions (4 buttons: - ★ € +) -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 3px; margin-top: 8px;">
                                <button onclick="event.stopPropagation(); removeCardFromDeck('cityLeague', '${cardNameEscaped}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; height: 22px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 13px;" title="Remove from deck">−</button>
                                <button onclick="event.stopPropagation(); openRaritySwitcher('${cardNameEscaped}', '${cardNameEscaped}')" style="background: #ffc107; color: #333; border: none; border-radius: 3px; height: 22px; cursor: pointer; font-size: 12px; font-weight: bold; text-align: center; padding: 0; display: flex; align-items: center; justify-content: center;" title="Switch rarity/print">★</button>
                                <button onclick="event.stopPropagation(); openCardmarket('${cardmarketUrlEscaped}', '${cardNameEscaped}')" style="background: ${priceBackground}; color: white; height: 22px; border: none; border-radius: 3px; cursor: ${eurPrice ? 'pointer' : 'not-allowed'}; font-size: 9px; font-weight: bold; padding: 0 2px; display: flex; align-items: center; justify-content: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);" title="${eurPrice ? 'Buy on Cardmarket: ' + eurPrice : 'Price not available'}">${priceDisplay}</button>
                                <button onclick="event.stopPropagation(); addCardToDeck('cityLeague', '${cardNameEscaped}', '${setCode}', '${setNumber}')" style="background: #28a745; color: white; border: none; border-radius: 3px; height: 22px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 13px;" title="Add to deck">+</button>
                            </div>
                        </div>
                    </div>
                `;
                }); // End of versionsToRender.forEach
            }); // End of sortedCards.forEach
            
            gridContainer.innerHTML = html;
            visualContainer.style.display = 'block';
        }
        
        function filterOverviewCards() {
            const searchInput = document.getElementById('cityLeagueOverviewSearch');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const gridContainer = document.getElementById('cityLeagueDeckGrid');
            if (!gridContainer) return;
            
            const cards = gridContainer.querySelectorAll('.card-item');
            cards.forEach(card => {
                const cardName = card.getAttribute('data-card-name') || '';
                if (searchTerm === '' || cardName.includes(searchTerm)) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
        }
        
        function toggleDeckGridView() {
            const gridViewContainer = document.getElementById('cityLeagueDeckVisual');
            const tableViewContainer = document.getElementById('cityLeagueDeckTableView');
            // Get button from DOM instead of event
            const gridButtons = document.querySelectorAll('button[onclick*="toggleDeckGridView"]');
            const button = gridButtons[0];
            
            if (!gridViewContainer || !tableViewContainer) {
                console.warn('⚠️ Grid or table container not found');
                return;
            }
            
            const cards = window.currentCityLeagueDeckCards;
            if (!cards || cards.length === 0) {
                alert('❌ Bitte zuerst ein Deck auswählen!');
                return;
            }
            
            // Check current view mode (grid is default)
            const isGridViewActive = gridViewContainer.style.display !== 'none';
            
            if (isGridViewActive) {
                // Switch to list/table view
                gridViewContainer.style.display = 'none';
                if (button) button.textContent = '🖼️ Grid View';
            } else {
                // Switch back to grid view
                tableViewContainer.style.display = 'none';
                if (button) button.textContent = '📋 List View';
            }
            
            // Re-apply filter to preserve percentage filter and render correct view
            applyCityLeagueFilter();
            
            // Re-apply current search filter
            filterOverviewCards();
        }
        
        function copyDeckOverview() {
            const deck = window.cityLeagueDeck;
            const hasDeck = deck && Object.keys(deck).length > 0;
            
            const allCards = window.currentCityLeagueDeckCards || [];
            const allCardsFromDb = window.allCardsDatabase || [];
            
            // If no deck AND no archetype cards, show error
            if (!hasDeck && allCards.length === 0) {
                alert('❌ Keine Karten zum Kopieren!\n\nBitte wähle zuerst einen Archetyp aus.');
                return;
            }
            
            // Build card data maps
            const cardDataByName = {};
            allCards.forEach(card => {
                cardDataByName[card.card_name] = card;
            });
            allCardsFromDb.forEach(card => {
                if (!cardDataByName[card.name]) {
                    cardDataByName[card.name] = {
                        card_name: card.name,
                        type: card.type || 'Unknown',
                        card_type: card.type || 'Unknown',
                        set_code: card.set,
                        set_number: card.number,
                        rarity: card.rarity
                    };
                }
            });
            
            const deckCards = [];
            const globalPref = getGlobalRarityPreference();
            const currentRarityMode = overviewRarityMode || 'min';
            
            if (hasDeck) {
                // COPY USER'S DECK with displayed versions
                console.log('[copyDeckOverview] Copying user deck with', Object.keys(deck).length, 'card types');
                
                for (const [deckKey, count] of Object.entries(deck)) {
                    if (count <= 0) continue;
                    
                    // Extract base name and original set info
                    const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                    const baseName = baseNameMatch ? baseNameMatch[1] : deckKey;
                    const setMatch = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                    const originalSet = setMatch ? setMatch[1] : null;
                    const originalNumber = setMatch ? setMatch[2] : null;
                    
                    let cardData = cardDataByName[baseName];
                    if (!cardData) continue;
                    
                    // Clone cardData to avoid modifying original
                    cardData = { ...cardData };
                    
                    // Apply rarity preference to get DISPLAYED version
                    const pref = getRarityPreference(baseName);
                    
                    // PRIORITY 1: Specific user preference
                    if (pref && pref.mode === 'specific' && pref.set && pref.number) {
                        const specificCard = allCardsFromDb.find(c => 
                            c.name === baseName && c.set === pref.set && c.number === pref.number
                        );
                        if (specificCard) {
                            cardData.set_code = specificCard.set;
                            cardData.set_number = specificCard.number;
                        }
                    }
                    // PRIORITY 2: Global rarity preference (min/max)
                    else if (globalPref === 'max' || globalPref === 'min') {
                        if (originalSet && originalNumber) {
                            const preferredVersion = getPreferredVersionForCard(baseName, originalSet, originalNumber);
                            if (preferredVersion) {
                                cardData.set_code = preferredVersion.set;
                                cardData.set_number = preferredVersion.number;
                            }
                        }
                    }
                    // PRIORITY 3: Use original version from deck key
                    else if (originalSet && originalNumber) {
                        cardData.set_code = originalSet;
                        cardData.set_number = originalNumber;
                    }
                    
                    deckCards.push({
                        ...cardData,
                        count: count
                    });
                }
            } else {
                // COPY ARCHETYPE CARDS with max_count
                console.log('[copyDeckOverview] Copying archetype cards with max_count, mode:', currentRarityMode);
                
                // Process each card from archetype
                allCards.forEach(card => {
                    const cardName = card.card_name;
                    const maxCount = parseInt(card.max_count) || 0;
                    if (maxCount <= 0) return;
                    
                    const originalSet = card.set_code || '';
                    const originalNumber = card.set_number || '';
                    
                    // Clone card data
                    let cardData = { ...card };
                    
                    // Apply rarity mode to get displayed version
                    if (currentRarityMode === 'min' || currentRarityMode === 'max') {
                        if (originalSet && originalNumber) {
                            const preferredVersion = getPreferredVersionForCard(cardName, originalSet, originalNumber);
                            if (preferredVersion) {
                                cardData.set_code = preferredVersion.set;
                                cardData.set_number = preferredVersion.number;
                            }
                        }
                    }
                    // If 'all' mode, we only copy the first version (can be improved later to include all)
                    
                    deckCards.push({
                        card_name: cardName,
                        type: cardData.type || cardData.card_type || 'Unknown',
                        card_type: cardData.type || cardData.card_type || 'Unknown',
                        set_code: cardData.set_code || '',
                        set_number: cardData.set_number || '',
                        count: maxCount
                    });
                });
            }
            
            // Sort cards using the same logic
            const sortedCards = sortCardsByType(deckCards);
            
            // Group by category
            const pokemon = [];
            const trainer = [];
            const energy = [];
            let pokemonCount = 0;
            let trainerCount = 0;
            let energyCount = 0;
            
            sortedCards.forEach(card => {
                const cardType = card.type || card.card_type || '';
                const category = getCardTypeCategory(cardType);
                const count = card.count;
                const cardName = card.card_name || '';
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                const line = `${count} ${cardName} ${setCode} ${setNumber}`.trim();
                
                if (category === 'Pokemon') {
                    pokemon.push(line);
                    pokemonCount += count;
                } else if (category === 'Energy' || category === 'Special Energy') {
                    energy.push(line);
                    energyCount += count;
                } else {
                    // Supporter, Item, Tool, Stadium all go to Trainer
                    trainer.push(line);
                    trainerCount += count;
                }
            });
            
            // Build output text
            let output = '';
            
            if (pokemon.length > 0) {
                output += `Pokémon: ${pokemonCount}\n`;
                output += pokemon.join('\n') + '\n\n';
            }
            
            if (trainer.length > 0) {
                output += `Trainer: ${trainerCount}\n`;
                output += trainer.join('\n') + '\n\n';
            }
            
            if (energy.length > 0) {
                output += `Energy: ${energyCount}\n`;
                output += energy.join('\n');
            }
            
            // Copy to clipboard
            navigator.clipboard.writeText(output).then(() => {
                alert('✅ Deck wurde in die Zwischenablage kopiert!');
            }).catch(err => {
                console.error('Fehler beim Kopieren:', err);
                alert('❌ Fehler beim Kopieren in die Zwischenablage!');
            });
        }

        function renderCityLeagueAnalysisTable(data) {
            console.log('renderCityLeagueAnalysisTable called with', data ? data.length : 0, 'rows');
            const tableContainer = document.getElementById('cityLeagueAnalysisTable');
            if (!tableContainer) {
                console.error('Table container not found!');
                return;
            }
            if (!data || data.length === 0) {
                console.warn('No data to render');
                tableContainer.innerHTML = '<p style="text-align: center; padding: 20px; color: #666;">Bitte wähle ein Deck aus...</p>';
                return;
            }

            // Use the same sorting logic as "Karten Übersicht (sortiert)"
            const sortedData = sortCardsByType([...data]);
            
            let html = '<table><thead><tr>';
            html += '<th class="col-image">Bild</th>';
            html += '<th>Cards in Deck</th>';
            html += '<th>Kartenname</th>';
            html += '<th>Set</th>';
            html += '<th>Nummer</th>';
            html += '<th>% in Archetype</th>';
            html += '<th>Deck Count</th>';
            html += '<th>Aktion</th>';
            html += '</tr></thead><tbody>';

            sortedData.forEach(row => {
                const imageUrl = row.image_url || '';
                const cardName = row.card_name || '';
                const setCode = row.set_code || '';
                const setNumber = row.set_number || '';
                const maxCount = row.max_count || '?';
                const percentage = parseFloat(row.percentage_in_archetype || 0).toFixed(1);
                const deckCount = row.deck_count || '?';
                const totalDecks = row.total_decks_in_archetype || '?';
                
                // Get current deck count from window.cityLeagueDeck
                const deck = window.cityLeagueDeck || {};
                const currentDeckCount = deck[cardName] || 0;
                
                html += '<tr>';
                // Image with green badge if card is in deck
                html += `<td class="col-image"><div style="position: relative; display: inline-block;">`;
                html += `<img src="${imageUrl}" alt="${cardName}" style="width: 60px; border-radius: 4px; cursor: zoom-in;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2260%22 height=%2284%22%3E%3Crect width=%2260%22 height=%2284%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2210%22%3ENo Image%3C/text%3E%3C/svg%3E'" onclick="showSingleCard('${imageUrl}', '${cardName.replace(/'/g, "\\'")}')">`;
                if (currentDeckCount > 0) {
                    html += `<div style="position: absolute; top: 2px; left: 2px; background: #28a745; color: white; border-radius: 50%; width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.7em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">${currentDeckCount}</div>`;
                }
                html += `</div></td>`;
                html += `<td><strong>${currentDeckCount}/${maxCount}</strong></td>`;
                html += `<td><strong>${cardName}</strong></td>`;
                html += `<td>${setCode}</td>`;
                html += `<td>${setNumber}</td>`;
                html += `<td><strong>${percentage}%</strong></td>`;
                html += `<td>${deckCount} / ${totalDecks}</td>`;
                html += `<td><button class="btn btn-primary" onclick="addCardToDeck('cityLeague', '${cardName.replace(/'/g, "\\'")}')">+ Add</button></td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            tableContainer.innerHTML = html;
            console.log('Table rendered successfully');
        }
        
        function applyCityLeagueFilter() {
            const filterSelect = document.getElementById('cityLeagueFilterSelect');
            const archetype = document.getElementById('cityLeagueDeckSelect')?.value;
            
            if (!filterSelect || !archetype || !window.currentCityLeagueDeckCards) return;
            
            const filterValue = filterSelect.value;
            const allCards = window.currentCityLeagueDeckCards;
            let filteredCards = [...allCards];
            
            if (filterValue !== 'all') {
                const threshold = parseInt(filterValue);
                filteredCards = filteredCards.filter(card => parseFloat(card.percentage_in_archetype || 0) >= threshold);
            }
            
            console.log(`Filter applied: ${filterValue}, showing ${filteredCards.length} of ${allCards.length} cards`);
            
            // Calculate total card counts (sum of max_count)
            const filteredTotal = filteredCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            const allTotal = allCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            
            // Update deck visual - check which view is active
            const tableViewContainer = document.getElementById('cityLeagueDeckTableView');
            const gridViewContainer = document.getElementById('cityLeagueDeckVisual');
            const isTableViewActive = tableViewContainer && tableViewContainer.style.display !== 'none';
            
            if (isTableViewActive) {
                renderCityLeagueDeckTable(filteredCards);
            } else {
                renderCityLeagueDeckGrid(filteredCards);
            }
            
            // Update card counts (unique filtered cards / total cards in deck)
            updateCityLeagueCardCounts(filteredCards.length, filteredTotal, allTotal);
        }
        
        function updateCityLeagueCardCounts(uniqueCount, filteredTotal, allTotal) {
            const countEl = document.getElementById('cityLeagueCardCount');
            const summaryEl = document.getElementById('cityLeagueCardCountSummary');
            
            if (countEl) {
                countEl.textContent = `${uniqueCount} Karten`;
            }
            if (summaryEl) {
                summaryEl.textContent = `/ ${filteredTotal} Total`;
            }
        }
        
        // Add filter change listener
        document.addEventListener('DOMContentLoaded', function() {
            const filterSelect = document.getElementById('cityLeagueFilterSelect');
            if (filterSelect) {
                filterSelect.onchange = applyCityLeagueFilter;
            }
        });

        function filterCityLeagueAnalysisCards() {
            const searchTerm = (document.getElementById('cityLeagueCardSearchInput')?.value || '').toLowerCase();
            const rows = document.querySelectorAll('#cityLeagueAnalysisTable table tbody tr');
            let visibleCount = 0;

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const visible = text.includes(searchTerm);
                row.style.display = visible ? '' : 'none';
                if (visible) visibleCount += 1;
            });

            const countEl = document.getElementById('cityLeagueCardCount');
            if (countEl) {
                countEl.textContent = `${visibleCount} Karten`;
            }
        }

        // Toggle functions for card tables
        function toggleCityLeagueCards() {
            const content = document.getElementById('cityLeagueCardsContent');
            const toggle = document.getElementById('cityLeagueCardsToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }
        
        // Toggle function for deck overview (starts expanded)
        function toggleCityLeagueDeckOverview() {
            const content = document.getElementById('cityLeagueDeckOverviewContent');
            const toggle = document.getElementById('cityLeagueDeckOverviewToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }
        
        // City League Deck Builder Functions - Load from localStorage
        function loadCityLeagueDeck() {
            try {
                const saved = localStorage.getItem('cityLeagueDeck');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    window.cityLeagueDeck = parsed.deck || {};
                    window.cityLeagueDeckOrder = parsed.order || [];
                    window.currentCityLeagueArchetype = parsed.archetype || null;
                    console.log('[loadCityLeagueDeck] Loaded deck from localStorage:', Object.keys(window.cityLeagueDeck).length, 'cards');
                    return true;
                }
            } catch (e) {
                console.error('[loadCityLeagueDeck] Error loading deck:', e);
            }
            window.cityLeagueDeck = {};
            window.cityLeagueDeckOrder = [];
            window.currentCityLeagueArchetype = null;
            return false;
        }
        
        function saveCityLeagueDeck() {
            try {
                const data = {
                    deck: window.cityLeagueDeck || {},
                    order: window.cityLeagueDeckOrder || [],
                    archetype: window.currentCityLeagueArchetype || null,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('cityLeagueDeck', JSON.stringify(data));
                console.log('[saveCityLeagueDeck] Saved deck to localStorage:', Object.keys(data.deck).length, 'cards');
            } catch (e) {
                console.error('[saveCityLeagueDeck] Error saving deck:', e);
            }
        }
        
        // Initialize deck from localStorage
        const deckLoaded = loadCityLeagueDeck();
        if (deckLoaded && Object.keys(window.cityLeagueDeck).length > 0) {
            // Deck was loaded - but DON'T display it yet
            // It will be displayed automatically when user selects the archetype
            console.log('[Init] Deck loaded from localStorage but not displayed (waiting for archetype selection)');
        }
        
        function addCardToDeck(source, cardName, setCode, setNumber) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            const deck = source === 'cityLeague' ? window.cityLeagueDeck : window.currentMetaDeck;
            const deckOrderKey = source === 'cityLeague' ? 'cityLeagueDeckOrder' : 'currentMetaDeckOrder';
            
            // Initialize deck order array if not exists
            if (!window[deckOrderKey]) {
                window[deckOrderKey] = [];
            }

            // CRITICAL FIX: When user manually adds a card with specific version, save it as preference
            // This ensures the exact version shows up in the deck (not auto-swapped to low rarity)
            if (setCode && setNumber) {
                setRarityPreference(cardName, {
                    mode: 'specific',
                    set: setCode,
                    number: setNumber
                });
                console.log(`[addCardToDeck] Saved specific version preference for ${cardName}: ${setCode} ${setNumber}`);
            }
            
            // CRITICAL FIX: Check if card already exists with a different key format
            // If card exists as "CardName" but we're adding "CardName (SET NUM)", update the existing key
            let deckKey = (setCode && setNumber) ? `${cardName} (${setCode} ${setNumber})` : cardName;
            
            // Check if there's already an entry for this card (with or without version info)
            let existingKey = null;
            if (deck[deckKey]) {
                existingKey = deckKey; // Exact match
            } else if (deck[cardName]) {
                existingKey = cardName; // Card exists without version
            } else {
                // Check if any key starts with this card name
                for (const key in deck) {
                    if (key === cardName || key.startsWith(cardName + ' (')) {
                        existingKey = key;
                        break;
                    }
                }
            }
            
            // If we found an existing key and it's different from our new key, migrate it
            if (existingKey && existingKey !== deckKey && setCode && setNumber) {
                console.log(`Migrating deck entry from "${existingKey}" to "${deckKey}"`);
                deck[deckKey] = deck[existingKey];
                delete deck[existingKey];
                
                // Update order array when migrating key
                if (window[deckOrderKey]) {
                    const oldKeyIndex = window[deckOrderKey].indexOf(existingKey);
                    if (oldKeyIndex !== -1) {
                        window[deckOrderKey][oldKeyIndex] = deckKey;
                        console.log(`Updated deck order during migration: ${existingKey} -> ${deckKey} at position ${oldKeyIndex}`);
                    }
                }
            } else if (existingKey) {
                deckKey = existingKey; // Use the existing key
            }
            
            if (!deck[deckKey]) {
                deck[deckKey] = 0;
            }
            
            const currentTotal = Object.values(deck).reduce((sum, count) => sum + count, 0);
            if (currentTotal >= 60) {
                alert('Deck ist voll (60 Karten)!');
                return;
            }
            
            // Check if card is a base energy or Ace Spec (no 4-copy limit for these)
            const cardsKey = source === 'cityLeague' ? 'currentCityLeagueDeckCards' : 'currentCurrentMetaDeckCards';
            const cards = window[cardsKey] || [];
            const allCardsDb = window.allCardsDatabase || [];
            let cardData = cards.find(c => c.card_name === cardName);
            if (!cardData && setCode && setNumber) {
                cardData = allCardsDb.find(c => c.name === cardName && c.set === setCode && c.number === setNumber);
            }
            const isBaseEnergy = cardData && (cardData.type || cardData.card_type || '').toLowerCase() === 'energy' && 
                                (cardName || '').match(/^(Fire|Water|Grass|Lightning|Psychic|Fighting|Darkness|Metal|Fairy|Dragon|Colorless|Neutral)\s+Energy$/i);
            const isAceSpec = cardData && (cardData.is_ace_spec === 'Yes' || cardData.is_ace_spec === true);
            
            // Check if card already has 4 copies (only applies to non-energy, non-ace-spec cards)
            if (!isBaseEnergy && !isAceSpec && deck[deckKey] >= 4) {
                alert('Maximal 4 Kopien pro Karte!');
                return;
            }
            
            // Ace Spec cards can only have 1 copy in deck
            if (isAceSpec && deck[deckKey] >= 1) {
                alert('Ace Spec Karten dürfen nur 1x im Deck sein!');
                return;
            }
            
            deck[deckKey]++;
            
            // Track insertion order
            if (!window[deckOrderKey].includes(deckKey)) {
                window[deckOrderKey].push(deckKey);
            }
            
            console.log(`Added card to deck: ${deckKey} -> ${deck[deckKey]}`);
            
            // Save to localStorage
            if (source === 'cityLeague') {
                saveCityLeagueDeck();
            } else if (source === 'currentMeta') {
                saveCurrentMetaDeck();
            }
            
            updateDeckDisplay(source);
        }
        
        function removeCardFromDeck(source, deckKey) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            const deck = source === 'cityLeague' ? window.cityLeagueDeck : window.currentMetaDeck;
            const deckOrderKey = source === 'cityLeague' ? 'cityLeagueDeckOrder' : 'currentMetaDeckOrder';
            
            if (deck[deckKey] && deck[deckKey] > 0) {
                deck[deckKey]--;
                if (deck[deckKey] === 0) {
                    delete deck[deckKey];
                    // Remove from order tracking
                    if (window[deckOrderKey]) {
                        const idx = window[deckOrderKey].indexOf(deckKey);
                        if (idx !== -1) {
                            window[deckOrderKey].splice(idx, 1);
                        }
                    }
                }
                
                // Save to localStorage
                if (source === 'cityLeague') {
                    saveCityLeagueDeck();
                } else if (source === 'currentMeta') {
                    saveCurrentMetaDeck();
                }
                
                updateDeckDisplay(source);
            }
        }
        
        function clearDeck(source) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            if (confirm('Möchtest du wirklich alle Karten aus dem Deck entfernen?')) {
                if (source === 'cityLeague') {
                    window.cityLeagueDeck = {};
                    window.cityLeagueDeckOrder = [];
                    saveCityLeagueDeck();
                } else if (source === 'currentMeta') {
                    window.currentMetaDeck = {};
                    window.currentMetaDeckOrder = [];
                    saveCurrentMetaDeck();
                }
                
                // CRITICAL: Clear all rarity preferences when clearing deck
                rarityPreferences = {};
                saveRarityPreferences();
                
                updateDeckDisplay(source);
            }
        }
        
        function updateDeckDisplay(source) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            const deck = source === 'cityLeague' ? window.cityLeagueDeck : window.currentMetaDeck;
            const total = Object.values(deck).reduce((sum, count) => sum + count, 0);
            const unique = Object.keys(deck).filter(k => deck[k] > 0).length;
            
            const countElId = source === 'cityLeague' ? 'cityLeagueDeckCount' : 'currentMetaDeckCount';
            const uniqueElId = source === 'cityLeague' ? 'cityLeagueDeckCountUnique' : 'currentMetaDeckCountUnique';
            
            const countEl = document.getElementById(countElId);
            const uniqueEl = document.getElementById(uniqueElId);
            
            if (countEl) countEl.textContent = total;
            if (uniqueEl) uniqueEl.textContent = `(${unique} Unique)`;
            
            // Update the My Deck grid
            renderMyDeckGrid(source);
            
            // CRITICAL: Also refresh the Overview Grid to show updated badges
            // Use the filter functions to preserve active filters (e.g., >90% cards)
            if (source === 'cityLeague') {
                applyCityLeagueFilter();
            } else if (source === 'currentMeta') {
                applyCurrentMetaFilter();
            }
        }
        
        function renderMyDeckGrid(source) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            const deck = source === 'cityLeague' ? window.cityLeagueDeck : window.currentMetaDeck;
            const deckOrderKey = source === 'cityLeague' ? 'cityLeagueDeckOrder' : 'currentMetaDeckOrder';
            const currentCardsKey = source === 'cityLeague' ? 'currentCityLeagueDeckCards' : 'currentCurrentMetaDeckCards';
            const gridContainerId = source === 'cityLeague' ? 'cityLeagueMyDeckGrid' : 'currentMetaMyDeckGrid';
            
            const allCards = window[currentCardsKey] || [];
            const allCardsFromDb = window.allCardsDatabase || [];
            
            // Build card data maps: by name and by name+set+number
            const cardDataByName = {};
            const cardDataByKey = {};
            
            // Initialize deck order array if not exists
            if (!window[deckOrderKey]) {
                window[deckOrderKey] = Object.keys(deck).filter(k => deck[k] > 0);
            }
            
            // First, add cards from current deck cards
            allCards.forEach(card => {
                cardDataByName[card.card_name] = card;
            });
            
            // Then add cards from allCardsDatabase with both keys
            allCardsFromDb.forEach(card => {
                // CRITICAL FIX: Use actual image_url from database, fallback to buildCardImageUrl only if missing
                const imageUrl = card.image_url || buildCardImageUrl(card.set, card.number, card.rarity);
                const cardData = {
                    card_name: card.name,
                    image_url: imageUrl,
                    percentage_in_archetype: 0,
                    type: card.type || 'Unknown',
                    card_type: card.type || 'Unknown',
                    set_code: card.set,
                    set_number: card.number,
                    rarity: card.rarity
                };
                
                // Key by name only
                if (!cardDataByName[card.name]) {
                    cardDataByName[card.name] = cardData;
                }
                
                // Key by "name (SET NUM)" for exact version match
                const versionKey = `${card.name} (${card.set} ${card.number})`;
                cardDataByKey[versionKey] = cardData;
            });
            
            // Convert deck to array with card data
            const deckCards = [];
            for (const [deckKey, count] of Object.entries(deck)) {
                if (count <= 0) continue;
                
                // Try exact match first (with SET NUM), then fallback to name only
                let cardData = cardDataByKey[deckKey] || cardDataByName[deckKey];
                
                // If still not found, extract card name from "CardName (SET NUM)" format
                if (!cardData) {
                    const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                    if (baseNameMatch) {
                        const baseName = baseNameMatch[1];
                        const setMatch = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                        
                        if (setMatch) {
                            const setCode = setMatch[1];
                            const setNumber = setMatch[2];
                            
                            // Try to find exact card in allCardsDatabase
                            const exactCard = allCardsFromDb.find(c => 
                                c.name === baseName && c.set === setCode && c.number === setNumber
                            );
                            
                            if (exactCard) {
                                const imageUrl = exactCard.image_url || buildCardImageUrl(exactCard.set, exactCard.number, exactCard.rarity);
                                cardData = {
                                    card_name: exactCard.name,
                                    image_url: imageUrl,
                                    percentage_in_archetype: 0,
                                    type: exactCard.type || 'Unknown',
                                    card_type: exactCard.type || 'Unknown',
                                    set_code: exactCard.set,
                                    set_number: exactCard.number,
                                    rarity: exactCard.rarity
                                };
                            } else {
                                const baseCardData = cardDataByName[baseName];
                                if (baseCardData) {
                                    console.log(`[renderMyDeckGrid] Using base card data for: ${baseName}, keeping image_url: ${baseCardData.image_url}`);
                                    cardData = {
                                        ...baseCardData,
                                        set_code: setCode,
                                        set_number: setNumber
                                    };
                                } else {
                                    console.warn(`[renderMyDeckGrid] Card not found: ${baseName} (${setCode} ${setNumber})`);
                                }
                            }
                        } else {
                            cardData = cardDataByName[baseName];
                        }
                    }
                }
                
                if (!cardData) continue;

                const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                const baseName = baseNameMatch ? baseNameMatch[1] : (cardData.card_name || deckKey);
                const archetypeData = cardDataByName[baseName];
                if (archetypeData) {
                    cardData = {
                        ...cardData,
                        percentage_in_archetype: archetypeData.percentage_in_archetype || cardData.percentage_in_archetype,
                        card_type: archetypeData.card_type || archetypeData.type || cardData.card_type,
                        type: archetypeData.type || archetypeData.card_type || cardData.type
                    };
                }

                const globalPref = getGlobalRarityPreference();
                const pref = getRarityPreference(baseName);
                
                const setMatch = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                const originalSet = setMatch ? setMatch[1] : cardData.set_code;
                const originalNumber = setMatch ? setMatch[2] : cardData.set_number;
                
                // Handle image URL based on rarity preference
                if (pref && pref.mode === 'specific' && pref.set && pref.number) {
                    const specificCard = allCardsFromDb.find(c => 
                        c.name === baseName && c.set === pref.set && c.number === pref.number
                    );
                    if (specificCard && specificCard.image_url) {
                        console.log(`[renderMyDeckGrid] Using SPECIFIC preference for ${baseName}: ${pref.set} ${pref.number}`);
                        cardData.image_url = specificCard.image_url;
                        cardData.set_code = specificCard.set;
                        cardData.set_number = specificCard.number;
                        cardData.rarity = specificCard.rarity;
                    }
                }
                else if (globalPref === 'max' || globalPref === 'min') {
                    if (originalSet && originalNumber) {
                        const preferredVersion = getPreferredVersionForCard(baseName, originalSet, originalNumber);
                        if (preferredVersion) {
                            const preferredCard = allCardsFromDb.find(c => 
                                c.name === baseName && c.set === preferredVersion.set && c.number === preferredVersion.number
                            );
                            if (preferredCard && preferredCard.image_url) {
                                console.log(`[renderMyDeckGrid] ${globalPref} Rarity swap for ${baseName}: ${originalSet} ${originalNumber} -> ${preferredVersion.set} ${preferredVersion.number}`);
                                cardData.image_url = preferredCard.image_url;
                                cardData.set_code = preferredCard.set;
                                cardData.set_number = preferredCard.number;
                                cardData.rarity = preferredCard.rarity;
                            }
                        }
                    } else {
                        const allVersions = allCardsFromDb.filter(c => c.name === baseName);
                        if (allVersions.length > 0) {
                            allVersions.sort((a, b) => {
                                const priorityA = getRarityPriority(a.rarity, a.set);
                                const priorityB = getRarityPriority(b.rarity, b.set);
                                return globalPref === 'max' ? priorityB - priorityA : priorityA - priorityB;
                            });
                            const preferredCard = allVersions[0];
                            if (preferredCard && preferredCard.image_url) {
                                console.log(`[renderMyDeckGrid] ${globalPref} Rarity for ${baseName}: ${preferredCard.set} ${preferredCard.number} (${preferredCard.rarity})`);
                                cardData.image_url = preferredCard.image_url;
                                cardData.set_code = preferredCard.set;
                                cardData.set_number = preferredCard.number;
                                cardData.rarity = preferredCard.rarity;
                            }
                        }
                    }
                }
                
                deckCards.push({
                    ...cardData, 
                    deck_count_in_selected: count, 
                    deck_key: deckKey,
                    original_set_code: originalSet,
                    original_set_number: originalNumber
                });
            }
            
            const sortedDeckCards = sortCardsByType(deckCards);
            
            // Build grid from deck
            let html = '';
            sortedDeckCards.forEach(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                const percentage = parseFloat(card.percentage_in_archetype || 0).toFixed(1);
                const count = card.deck_count_in_selected || 1;
                const cardNameEscaped = card.card_name.replace(/'/g, "\\'");
                const deckKeyEscaped = (card.deck_key || card.card_name).replace(/'/g, "\\'");
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                let eurPrice = '';
                let cardmarketUrl = '';
                if (setCode && setNumber && allCardsDatabase) {
                    const priceCard = allCardsDatabase.find(c => 
                        c.set === setCode && c.number === setNumber
                    );
                    if (priceCard) {
                        eurPrice = priceCard.eur_price || '';
                        cardmarketUrl = priceCard.cardmarket_url || '';
                    }
                }
                const priceDisplay = eurPrice || '0,00€';
                const priceClass = eurPrice ? 'btn-cardmarket' : 'btn-cardmarket no-price';
                const priceBackground = eurPrice ? 'linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%)' : 'linear-gradient(135deg, #777 0%, #999 100%)';
                const cardmarketUrlEscaped = (cardmarketUrl || '').replace(/'/g, "\\'");
                
                const baseName = card.card_name;
                const baseCardData = cardDataByName[baseName] || card;
                const totalCount = parseInt(baseCardData.total_count || 0);
                const totalDecksInArchetype = parseInt(baseCardData.total_decks_in_archetype || 1);
                const avgCount = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0.00';
                
                html += `
                    <div class="deck-card" style="position: relative;" title="${card.card_name} (${count}x) - ${percentage}%">
                        <img src="${imageUrl}" alt="${card.card_name}" style="cursor: zoom-in; width: 100%; aspect-ratio: 2.5/3.5; object-fit: cover;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect fill=%22%23667eea%22 width=%22245%22 height=%22342%22/%3E%3Ctext fill=%22white%22 x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 font-size=%2220%22%3EKeine Bild%3C/text%3E%3C/svg%3E'" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped}')">
                        
                        <div class="card-max-count">${count}</div>
                        
                        <div style="position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.75); color: white; padding: 3px 10px; border-radius: 4px; font-size: 11px; font-weight: bold; white-space: nowrap; z-index: 2;">
                            ${percentage}% | Ø ${avgCount}x
                        </div>
                        
                        <div style="position: absolute; bottom: 5px; left: 5px; right: 5px; display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 3px; z-index: 3; align-items: stretch;">
                            <button onclick="removeCardFromDeck('${source}', '${deckKeyEscaped}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; height: 20px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 12px;">−</button>
                            <button onclick="openRaritySwitcher('${cardNameEscaped}', '${deckKeyEscaped}')" style="background: #ffc107; color: #333; border: none; border-radius: 3px; height: 20px; cursor: pointer; font-size: 11px; font-weight: bold; text-align: center; padding: 0; display: flex; align-items: center; justify-content: center;">★</button>
                            <button class="${priceClass}" onclick="openCardmarket('${cardmarketUrlEscaped}', '${cardNameEscaped}')" style="background: ${priceBackground}; color: white; height: 20px; border: none; border-radius: 3px; cursor: ${eurPrice ? 'pointer' : 'not-allowed'}; font-size: 8px; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);" title="${eurPrice ? 'Auf Cardmarket kaufen: ' + eurPrice : 'Preis nicht verfügbar'}">${priceDisplay}</button>
                            <button onclick="addCardToDeck('${source}', '${cardNameEscaped}', '${setCode}', '${setNumber}')" style="background: #28a745; color: white; border: none; border-radius: 3px; height: 20px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 12px;">+</button>
                        </div>
                    </div>
                `;
            });
            
            const gridContainer = document.getElementById(gridContainerId);
            if (gridContainer) {
                gridContainer.innerHTML = html || '<p style="text-align: center; color: #666; padding: 40px;">Erstelle ein Deck mit den Buttons oben oder füge Karten manuell hinzu...</p>';
            }
        }
        
        // Filter deck grid based on search input
        function filterDeckGrid(source) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            const searchInputId = source === 'cityLeague' ? 'cityLeagueDeckGridSearch' : 'currentMetaDeckGridSearch';
            const gridContainerId = source === 'cityLeague' ? 'cityLeagueMyDeckGrid' : 'currentMetaMyDeckGrid';
            
            const searchInput = document.getElementById(searchInputId);
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const gridContainer = document.getElementById(gridContainerId);
            if (!gridContainer) return;
            
            const cards = gridContainer.querySelectorAll('.deck-card');
            cards.forEach(card => {
                const cardTitle = (card.getAttribute('title') || '').toLowerCase();
                if (searchTerm === '' || cardTitle.includes(searchTerm)) {
                    card.style.display = '';
                } else {
                    card.style.display = 'none';
                }
            });
        }
        
        // ========== CARD SORTING & ORGANIZATION FUNCTIONS ==========
        
        function getCardTypeCategory(cardType) {
            /**
             * Determines the category of a card based on the type field
             * type format: "GBasic", "WBasic", "PStage1", "PStage2", "Supporter", "Item", "Tool", "Stadium", "Special Energy", "Energy"
             */
            if (!cardType) return 'Pokemon';
            
            // Check if it's a Pokemon (type starts with element letter)
            if (cardType.charAt(0).match(/[GRWLPFDMNC]/)) {
                return 'Pokemon';
            }
            
            // Check exact matches for trainer types
            if (cardType === 'Supporter') return 'Supporter';
            if (cardType === 'Item') return 'Item';
            if (cardType === 'Tool') return 'Tool';
            if (cardType === 'Stadium') return 'Stadium';
            if (cardType === 'Special Energy') return 'Special Energy';
            if (cardType === 'Energy') return 'Energy';
            if (cardType === 'Trainer') return 'Item';
            
            // Fallback to Pokemon
            return 'Pokemon';
        }
        
        function sortCardsByType(cards) {
            /**
             * Sort cards:
             * 1. By Category (Pokemon, Supporter, Item, etc.)
             * 2. By Element (for Pokemon: G, R, W, L, P, F, D, M, N, C)
             * 3. By PERCENTAGE (highest first!)
             * 4. By Evolution Chain (keep together: Basic, Stage1, Stage2)
             * 5. By Set Number
             */
            
            // Pokemon Evolution Chains (from pokemondb.net/evolution)
            const evolutionChains = {
                'Bulbasaur': ['Bulbasaur', 'Ivysaur', 'Venusaur'],
                'Ivysaur': ['Bulbasaur', 'Ivysaur', 'Venusaur'],
                'Venusaur': ['Bulbasaur', 'Ivysaur', 'Venusaur'],
                'Charmander': ['Charmander', 'Charmeleon', 'Charizard'],
                'Charmeleon': ['Charmander', 'Charmeleon', 'Charizard'],
                'Charizard': ['Charmander', 'Charmeleon', 'Charizard'],
                'Squirtle': ['Squirtle', 'Wartortle', 'Blastoise'],
                'Wartortle': ['Squirtle', 'Wartortle', 'Blastoise'],
                'Blastoise': ['Squirtle', 'Wartortle', 'Blastoise'],
                'Pichu': ['Pichu', 'Pikachu', 'Raichu'],
                'Pikachu': ['Pichu', 'Pikachu', 'Raichu'],
                'Raichu': ['Pichu', 'Pikachu', 'Raichu'],
                'Riolu': ['Riolu', 'Lucario', 'Mega Lucario ex'],
                'Lucario': ['Riolu', 'Lucario', 'Mega Lucario ex'],
                'Mega Lucario ex': ['Riolu', 'Lucario', 'Mega Lucario ex'],
                'Eevee': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Vaporeon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Jolteon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Flareon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Espeon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Umbreon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Leafeon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Glaceon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Sylveon': ['Eevee', 'Vaporeon', 'Jolteon', 'Flareon', 'Espeon', 'Umbreon', 'Leafeon', 'Glaceon', 'Sylveon'],
                'Shaymin': ['Shaymin'],
                'Dialga': ['Dialga'],
                'Palkia': ['Palkia'],
                'Kyogre': ['Kyogre'],
                'Groudon': ['Groudon'],
                'Rayquaza': ['Rayquaza'],
                'Jirachi': ['Jirachi'],
                'Deoxys': ['Deoxys'],
                'Budew': ['Budew', 'Roserade'],
                'Roserade': ['Budew', 'Roserade'],
                'Chimecho': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Chimchar': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Monferno': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Infernape': ['Chimecho', 'Chimchar', 'Monferno', 'Infernape'],
                'Piplup': ['Piplup', 'Prinplup', 'Empoleon'],
                'Prinplup': ['Piplup', 'Prinplup', 'Empoleon'],
                'Empoleon': ['Piplup', 'Prinplup', 'Empoleon'],
                'Turtwig': ['Turtwig', 'Grotle', 'Torterra'],
                'Grotle': ['Turtwig', 'Grotle', 'Torterra'],
                'Torterra': ['Turtwig', 'Grotle', 'Torterra'],
                'Makuhita': ['Makuhita', 'Hariyama'],
                'Hariyama': ['Makuhita', 'Hariyama'],
                'Lunatone': ['Lunatone'],
                'Solrock': ['Solrock'],
                'Cornerstone Mask Oger': ['Cornerstone Mask Oger'],
                'Ting-Lu': ['Ting-Lu'],
                'Oricorio': ['Oricorio'],
                'Drilbur': ['Drilbur', 'Excadrill'],
                'Excadrill': ['Drilbur', 'Excadrill'],
                'Hawlucha': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Rowlet': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Dartrix': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Decidueye': ['Rowlet', 'Dartrix', 'Decidueye', 'Hawlucha'],
                'Ethan\'s Sudowoodo': ['Ethan\'s Sudowoodo'],
                'Fezandipiti ex': ['Fezandipiti ex'],
                'Mega Zygarde ex': ['Mega Zygarde ex'],
                'Escadrill': ['Escadrill'],
                'Psyduck': ['Psyduck', 'Golduck'],
                'Golduck': ['Psyduck', 'Golduck'],
                'Flutter Mane': ['Flutter Mane'],
                'Lillie\'s Certainty ex': ['Lillie\'s Certainty ex'],
                'Munkidori': ['Munkidori'],
                'Togepi': ['Togepi', 'Togetic', 'Togekiss'],
                'Togetic': ['Togepi', 'Togetic', 'Togekiss'],
                'Togekiss': ['Togepi', 'Togetic', 'Togekiss']
            };
            
            const elementOrder = {
                'G': 1,  // Grass
                'R': 2,  // Fire
                'W': 3,  // Water
                'L': 4,  // Lightning
                'P': 5,  // Psychic
                'F': 6,  // Fighting
                'D': 7,  // Darkness
                'M': 8,  // Metal
                'N': 9,  // Dragon
                'C': 10  // Colorless
            };
            
            const evolutionOrder = {
                'Basic': 1,
                'Stage1': 2,
                'Stage2': 3
            };
            
            const typeOrder = {
                'Pokemon': 1,
                'Supporter': 2,
                'Item': 3,
                'Tool': 4,
                'Stadium': 5,
                'Special Energy': 6,
                'Energy': 7
            };
            
            return cards.sort((a, b) => {
                const cardTypeA = a.type || a.card_type || '';
                const cardTypeB = b.type || b.card_type || '';
                
                const categoryA = getCardTypeCategory(cardTypeA);
                const categoryB = getCardTypeCategory(cardTypeB);
                
                const orderA = typeOrder[categoryA] || 99;
                const orderB = typeOrder[categoryB] || 99;
                
                // FIRST: Sort by main category (Pokemon, Supporter, etc.)
                if (orderA !== orderB) {
                    return orderA - orderB;
                }
                
                // Parse percentage once for both cards
                const percA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                const percB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.')) || 0;
                
                // For Pokemon: sort by element first, then by percentage
                if (categoryA === 'Pokemon' && categoryB === 'Pokemon') {
                    const elementA = cardTypeA.charAt(0);
                    const elementB = cardTypeB.charAt(0);
                    const evolutionA = cardTypeA.substring(1).replace(/\s+/g, '');
                    const evolutionB = cardTypeB.substring(1).replace(/\s+/g, '');
                    
                    const elemOrderA = elementOrder[elementA] || 99;
                    const elemOrderB = elementOrder[elementB] || 99;
                    
                    // Different element: sort by element order
                    if (elemOrderA !== elemOrderB) {
                        return elemOrderA - elemOrderB;
                    }
                    
                    // SAME ELEMENT: Sort by PERCENTAGE (highest first)
                    if (percA !== percB) {
                        return percB - percA;
                    }
                    
                    // Same percentage: sort by ORIGINAL SET CODE + SET NUMBER (keeps same-set cards together)
                    // Use original_set_code/original_set_number for consistent sorting even when Max Rarity is selected
                    const setCodeA = a.original_set_code || a.set_code || '';
                    const setCodeB = b.original_set_code || b.set_code || '';
                    
                    if (setCodeA !== setCodeB) {
                        return setCodeA.localeCompare(setCodeB);
                    }
                    
                    // Same set code: sort by ORIGINAL SET NUMBER (numerically)
                    const setNumA = parseInt(((a.original_set_number || a.set_number) || '0').toString().replace(/[^\d]/g, '')) || 0;
                    const setNumB = parseInt(((b.original_set_number || b.set_number) || '0').toString().replace(/[^\d]/g, '')) || 0;
                    if (setNumA !== setNumB) {
                        return setNumA - setNumB;
                    }
                    
                    // Same set+number: sort by card name (keeps related Pokemon together)
                    const nameA = a.card_name || a.name || '';
                    const nameB = b.card_name || b.name || '';
                    const nameCompare = nameA.localeCompare(nameB);
                    if (nameCompare !== 0) {
                        return nameCompare;
                    }
                    
                    // Same name: sort by evolution stage (Basic → Stage1 → Stage2)
                    const evolOrderA = evolutionOrder[evolutionA] || 99;
                    const evolOrderB = evolutionOrder[evolutionB] || 99;
                    
                    return evolOrderA - evolOrderB;
                }
                
                // For non-Pokemon cards: Sort by PERCENTAGE (highest first)
                if (percA !== percB) {
                    return percB - percA;
                }
                
                // Same percentage: sort by set number
                const setNumA = parseInt((a.set_number || '0').toString().replace(/[^\d]/g, '')) || 0;
                const setNumB = parseInt((b.set_number || '0').toString().replace(/[^\d]/g, '')) || 0;
                if (setNumA !== setNumB) {
                    return setNumA - setNumB;
                }
                
                // Finally by name
                const nameA = a.card_name || a.name || '';
                const nameB = b.card_name || b.name || '';
                return nameA.localeCompare(nameB);
            });
        }
        
        function deduplicateCards(cards) {
            /**
             * Für jede Karte (gleicher Name) nur die neueste low-rarity Version behalten
             */
            const setOrder = {
                // 2026 Sets
                'PRE': 108, 'SFA': 107, 'ASC': 106,
                // 2025 Sets
                'MEG': 105, 'MEP': 104, 'SP': 103, 'SVE': 102,
                // 2024 Sets
                'SCR': 101, 'TWM': 100, 'TEF': 99, 'PAR': 98, 'PAF': 97, 'PAL': 96, 'OBF': 95,
                // 2023 Sets
                'MEW': 94, 'SVI': 93, 'CRZ': 92, 'SIT': 91, 'LOR': 90, 'PGO': 89,
                // Special/Promo (higher than SSH)
                'BLK': 99, 'WHT': 98, 'SSP': 94,
                // 2022 Sets
                'ASR': 88, 'BRS': 87, 'FST': 86, 'CEL': 85, 'EVS': 84, 'CRE': 83,
                // 2021 Sets
                'BST': 82, 'SHF': 81, 'VIV': 80, 'CPA': 79, 'DAA': 78,
                // 2020 Sets
                'RCL': 77, 'SSH': 76, 'CEC': 75
            };
            
            const rarityOrder = {
                'Common': 1,
                'Uncommon': 2,
                'Rare': 3,
                'Holo Rare': 4,
                'Ultra Rare': 5,
                'Secret Rare': 6,
                'Hyper Rare': 7,
                'Special Rare': 8,
                'Illustration Rare': 9,
                'Promo': 10
            };
            
            const cardMap = new Map();
            
            cards.forEach(card => {
                const cardName = card.card_name;
                
                if (!cardMap.has(cardName)) {
                    cardMap.set(cardName, card);
                } else {
                    const existing = cardMap.get(cardName);
                    const existingSetPriority = setOrder[existing.set_code] || 0;
                    const newSetPriority = setOrder[card.set_code] || 0;
                    const existingRarityPriority = rarityOrder[existing.rarity] || 99;
                    const newRarityPriority = rarityOrder[card.rarity] || 99;
                    
                    // Bevorzuge: 1. Low Rarity (Common/Uncommon), 2. Neuestes Set
                    if (newRarityPriority < existingRarityPriority) {
                        // Niedrigere Rarity gewinnt - aber behalte aggregierte Daten
                        // Nur überschreiben wenn neue Werte nicht leer sind
                        if (card.image_url) existing.image_url = card.image_url;
                        if (card.set_code) existing.set_code = card.set_code;
                        if (card.rarity) existing.rarity = card.rarity;
                        if (card.set_number) existing.set_number = card.set_number;
                    } else if (newRarityPriority === existingRarityPriority && newSetPriority > existingSetPriority) {
                        // Gleiche Rarity, aber neueres Set - behalte aggregierte Daten
                        // Nur überschreiben wenn neue Werte nicht leer sind
                        if (card.image_url) existing.image_url = card.image_url;
                        if (card.set_code) existing.set_code = card.set_code;
                        if (card.rarity) existing.rarity = card.rarity;
                        if (card.set_number) existing.set_number = card.set_number;
                    }
                    // Falls set_code fehlt aber image_url das Set zeigt, extrahiere es
                    if (!existing.set_code && existing.image_url) {
                        if (existing.image_url.includes('/M3/')) {
                            existing.set_code = 'M3';
                            console.log(`Set code M3 extracted from URL for: ${existing.card_name}`);
                        }
                    }
                }
            });
            
            // Debug: Count cards with set_code after deduplication
            const result = Array.from(cardMap.values());
            const m3Cards = result.filter(c => c.set_code === 'M3' || (c.image_url && c.image_url.includes('/M3/')));
            if (m3Cards.length > 0) {
                console.log(`After deduplicateCards: ${m3Cards.length} M3 cards. First 3:`, 
                    m3Cards.slice(0, 3).map(c => ({ name: c.card_name, set_code: c.set_code, url: c.image_url }))
                );
            }
            
            return result;
        }
        
        // ========== DECK OVERVIEW RENDERING FUNCTIONS ==========
        
        function renderOverviewCards(cards) {
            /**
             * Renders deck overview for City League Analysis
             * Shows cards in a responsive grid with:
             * - Card image
             * - Red circle (top-right): max_count
             * - Green circle (top-left): deck_count (how many in selected deck - starts at 0)
             * - Card name
             * - Percentage and average count
             */
            // Karten sind bereits in loadCityLeagueDeckData() dedupliziert
            const sortedCards = sortCardsByType([...cards]);
            
            // Get current deck state
            const deck = window.cityLeagueDeck || {};
            
            // Log for debugging
            console.log('RENDERED OVERVIEW CARDS - Sorted by type:');
            sortedCards.slice(0, 10).forEach((card, idx) => {
                console.log(`${idx + 1}. ${card.card_name} (${card.type || card.card_type || 'UNKNOWN'}) - ${getCardTypeCategory(card.type || card.card_type || '')}`);
            });
            
            const overviewContainer = document.getElementById('cityLeagueDeckOverview');
            if (!overviewContainer) return;
            
            const gridHtml = sortedCards.map(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                // Konvertiere Komma zu Punkt für parseFloat (CSV verwendet Komma als Dezimaltrennzeichen)
                const percentageStr = (card.percentage_in_archetype || '0').toString().replace(',', '.');
                let percentage = parseFloat(percentageStr);
                const maxCount = card.max_count || '-';
                
                // Get actual deck count from window.cityLeagueDeck
                // Try both: card name only AND "CardName (SET NUM)" format
                let deckCount = deck[card.card_name] || 0;
                if (deckCount === 0 && card.set_code && card.set_number) {
                    const versionKey = `${card.card_name} (${card.set_code} ${card.set_number})`;
                    deckCount = deck[versionKey] || 0;
                }
                // Also check all deck keys that start with the card name
                if (deckCount === 0) {
                    for (const key in deck) {
                        if (key.startsWith(card.card_name + ' (')) {
                            deckCount += deck[key];
                        }
                    }
                }
                
                // Calculate average count over all decks (total_count / total_decks_in_archetype)
                const totalCount = parseInt(card.total_count || 0);
                const totalDecksInArchetype = parseInt(card.total_decks_in_archetype || 1);
                const avgCount = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0';
                
                // Card image or placeholder
                let imgHtml = '';
                if (imageUrl && imageUrl.trim() !== '') {
                    imgHtml = `<img src="${imageUrl}" alt="${card.card_name}" referrerpolicy="no-referrer" style="width: 100%; aspect-ratio: 2.5/3.5; object-fit: cover; cursor: zoom-in;" onerror="this.style.opacity='0.3'" onclick="event.stopPropagation(); showSingleCard('${imageUrl}', '${card.card_name.replace(/'/g, "\\'")}');">`;
                } else {
                    imgHtml = `<div style="width: 100%; aspect-ratio: 2.5/3.5; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 2em;">🃏</div>`;
                }
                
                return `
                    <div class="card-item" style="position: relative; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; background: white;">
                        <div style="position: relative; width: 100%;">
                            ${imgHtml}
                            
                            <!-- Red badge: Max Count (top-right) -->
                            <div style="position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">
                                ${maxCount}
                            </div>
                            
                            <!-- Green badge: Deck Count (top-left) - only show if > 0 -->
                            ${deckCount > 0 ? `
                            <div style="position: absolute; top: 5px; left: 5px; background: #28a745; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">
                                ${deckCount}
                            </div>
                            ` : ''}
                        </div>
                        
                        <!-- Card info section -->
                        <div style="padding: 8px; background: white; font-size: 0.75em; text-align: center; min-height: 60px; display: flex; flex-direction: column; justify-content: space-between;">
                            <div>
                                <div style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 600; margin-bottom: 3px; color: #333; font-size: 0.9em;">
                                    ${card.card_name}
                                </div>
                                <div style="color: #999; font-size: 0.75em; margin-bottom: 3px;">
                                    ${card.set_code || ''} ${card.set_number || ''}
                                </div>
                                <div style="color: #666; font-size: 0.85em;">
                                    ${percentage.toFixed(2).replace('.', ',')}% | Ø ${avgCount}x
                                </div>
                            </div>
                            
                            <!-- Add button -->
                            <button class="btn btn-success" style="padding: 4px 8px; font-size: 0.75em; background: #28a745; color: white; border: none; border-radius: 4px; cursor: pointer; transition: all 0.2s; margin-top: 8px; width: 100%;" onclick="addCardToDeck('cityLeague', '${card.card_name.replace(/'/g, "\\'")}', '${card.set_code || ''}', '${card.set_number || ''}')" title="Add to deck">Add to Deck</button>
                        </div>
                    </div>
                `;
            }).join('');
            
            overviewContainer.innerHTML = gridHtml;
        }
        
        function generateDeckGrid(source) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            const deck = source === 'cityLeague' ? window.cityLeagueDeck : window.currentMetaDeck;
            const currentCardsKey = source === 'cityLeague' ? 'currentCityLeagueDeckCards' : 'currentCurrentMetaDeckCards';
            
            if (!deck || Object.keys(deck).length === 0) {
                alert('Dein Deck ist leer!');
                return;
            }
            
            const modal = document.getElementById('imageViewModal');
            const grid = document.getElementById('compactCardGrid');
            const allCards = window[currentCardsKey] || [];
            const allCardsDb = window.allCardsDatabase || [];
            
            // Build a map of card data keyed by name
            const cardDataMap = {};
            allCards.forEach(card => {
                cardDataMap[card.card_name] = card;
            });
            
            // Convert deck to array with card data
            const deckCards = [];
            for (const [deckKey, count] of Object.entries(deck)) {
                if (count <= 0) continue;
                
                // Extract card name from deckKey (handle "CardName (SET NUM)" format)
                const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                const cardName = baseNameMatch ? baseNameMatch[1] : deckKey;
                
                let cardData = cardDataMap[cardName] || cardDataMap[deckKey];
                
                // If not found, try to find in allCardsDatabase
                if (!cardData) {
                    const setMatch = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                    if (setMatch) {
                        const exactCard = allCardsDb.find(c => c.name === cardName);
                        if (exactCard) {
                            const imageUrl = buildCardImageUrl(setMatch[1], setMatch[2], exactCard.rarity || 'Common');
                            cardData = {
                                card_name: exactCard.name,
                                image_url: imageUrl,
                                type: exactCard.type || 'Unknown',
                                set_code: setMatch[1]
                            };
                        }
                    }
                }
                
                if (!cardData) continue;
                
                deckCards.push({...cardData, deck_count_in_selected: count, card_name: cardName});
            }
            
            // Sort cards using the standard sorting function
            const sortedCards = sortCardsByType(deckCards);
            
            // Check if mobile device
            const isMobile = window.innerWidth <= 768;
            
            // Build grid HTML
            grid.innerHTML = sortedCards.map(card => {
                const imageUrl = fixJapaneseCardImageUrl(card.image_url || '', card.set_code);
                const count = card.deck_count_in_selected || 1;
                const cardName = card.card_name || '';
                const cardNameEscaped = (cardName || '').replace(/'/g, "\\'");
                
                if (imageUrl && imageUrl.trim() !== '') {
                    return `
                        <div class="compact-card" title="${cardName} (${count}x)" style="cursor: zoom-in;" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped}')">
                            <img src="${imageUrl}" 
                                 alt="${cardName}" 
                                 loading="lazy"
                                 referrerpolicy="no-referrer"
                                 onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect width=%22245%22 height=%22342%22 fill=%22%23333%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 dominant-baseline=%22middle%22 text-anchor=%22middle%22 fill=%22%23999%22 font-size=%2218%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                            <div class="compact-badge">${count}</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="compact-card" style="display: flex; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <div style="text-align: center;">
                                <div style="font-size: 0.8em; margin-bottom: 5px;">${cardName.substring(0, 15)}</div>
                                <div class="compact-badge" style="position: static;">${count}</div>
                            </div>
                        </div>
                    `;
                }
            }).join('');
            
            // Add mobile-specific class for compact layout
            if (isMobile) {
                grid.classList.add('mobile-compact-grid');
            } else {
                grid.classList.remove('mobile-compact-grid');
            }
            
            modal.classList.add('show');
        }
        
        function copyDeck(source) {
            console.log('[copyDeck] Called with source:', source);
            
            if (source === 'cityLeague') {
                copyDeckOverview();
            } else if (source === 'currentMeta') {
                copyCurrentMetaDeckOverview();
            } else {
                console.log('[copyDeck] Unsupported source:', source);
                alert('❌ Diese Funktion ist für diesen Tab nicht verfügbar!');
            }
        }
        
        function showSingleCard(imageUrl, cardName) {
            const modal = document.getElementById('singleCardModal');
            const img = document.getElementById('singleCardImage');
            const title = document.getElementById('singleCardTitle');
            
            img.src = imageUrl;
            img.alt = cardName;
            if (title) {
                title.textContent = cardName;
            }
            
            modal.classList.add('show');
        }
        
        function closeSingleCard() {
            const modal = document.getElementById('singleCardModal');
            modal.classList.remove('show');
        }
        
        function autoComplete(source, rarityMode) {
            if (source !== 'cityLeague' && source !== 'currentMeta') return;
            
            // CRITICAL: Clear all specific rarity preferences before generating deck
            // This ensures the selected rarity mode (min/max) is applied correctly
            rarityPreferences = {};
            saveRarityPreferences();
            
            // Set global rarity preference based on button clicked
            if (rarityMode) {
                globalRarityPreference = rarityMode;
            }
            
            const cardsKey = source === 'cityLeague' ? 'currentCityLeagueDeckCards' : 'currentCurrentMetaDeckCards';
            const cards = window[cardsKey];
            if (!cards || cards.length === 0) {
                alert('Keine Karten zum Ergänzen!');
                return;
            }
            
            console.log('[autoComplete] Starting autoComplete for', source);
            console.log('[autoComplete] Total available cards:', cards.length);
            
            // Get current archetype
            const currentArchetype = source === 'cityLeague' ? window.currentCityLeagueArchetype : window.currentCurrentMetaArchetype;
            
            // Check if saved deck matches current archetype
            const savedDeckKey = source === 'cityLeague' ? 'cityLeagueDeck' : 'currentMetaDeck';
            const savedDeck = localStorage.getItem(savedDeckKey);
            if (savedDeck) {
                try {
                    const parsed = JSON.parse(savedDeck);
                    if (parsed.archetype && parsed.archetype !== currentArchetype) {
                        console.log('[autoComplete] Clearing old deck from different archetype:', parsed.archetype, '(current:', currentArchetype + ')');
                        // Clear the old deck since it's for a different archetype
                        if (source === 'cityLeague') {
                            window.cityLeagueDeck = {};
                            window.cityLeagueDeckOrder = [];
                            saveCityLeagueDeck();
                        } else {
                            window.currentMetaDeck = {};
                            window.currentMetaDeckOrder = [];
                            saveCurrentMetaDeck();
                        }
                    }
                } catch (e) {
                    console.error('[autoComplete] Error parsing saved deck:', e);
                }
            }
            
            // Get current deck state (after potential clearing)
            const deck = source === 'cityLeague' ? (window.cityLeagueDeck || {}) : (window.currentMetaDeck || {});
            let currentTotal = Object.values(deck).reduce((sum, count) => sum + count, 0);
            
            if (currentTotal >= 60) {
                alert('Deck ist bereits voll (60 Karten)!');
                return;
            }
            
            // Ace Spec Identifikation: erst is_ace_spec Feld nutzen, dann Type fallback
            const isAceSpec = (card) => {
                // Prefer is_ace_spec field if available
                if (card.is_ace_spec !== undefined) {
                    const val = (card.is_ace_spec || '').toString().toLowerCase();
                    return val === 'yes' || val === 'true';
                }
                // Fallback: check type field
                const type = (card.type || card.card_type || '').toLowerCase();
                return type.includes('ace spec');
            };
            
            // Basis Energien Identifikation - dürfen öfter als 4x sein
            const isBaseEnergy = (card) => {
                const type = (card.type || card.card_type || '').toLowerCase();
                return type === 'energy' && (card.card_name || '').match(/^(Fire|Water|Grass|Lightning|Psychic|Fighting|Darkness|Metal|Fairy|Dragon|Colorless|Neutral)\s+Energy$/i);
            };
            
            // Step 1: Deduplicate cards by card_name (keep highest percentage)
            const uniqueCards = {};
            for (const card of cards) {
                const cardName = card.card_name;
                
                if (!uniqueCards[cardName]) {
                    uniqueCards[cardName] = card;
                } else {
                    const newPercentage = parseFloat((card.percentage_in_archetype || '0').toString().replace(',', '.'));
                    const existingPercentage = parseFloat((uniqueCards[cardName].percentage_in_archetype || '0').toString().replace(',', '.'));
                    
                    if (newPercentage > existingPercentage) {
                        uniqueCards[cardName] = card;
                    }
                }
            }
            
            let deckCards = Object.values(uniqueCards);
            console.log('[autoComplete] After deduplication:', deckCards.length, 'unique cards');
            
            // Debug: Log all card types to understand structure
            const typeSet = new Set();
            deckCards.forEach(card => {
                const type = card.type || card.card_type || '';
                typeSet.add(type);
            });
            console.log('[autoComplete] Card types found:', Array.from(typeSet));
            
            // Step 2: Sort by percentage (descending)
            deckCards.sort((a, b) => {
                const percentageA = parseFloat((a.percentage_in_archetype || '0').toString().replace(',', '.'));
                const percentageB = parseFloat((b.percentage_in_archetype || '0').toString().replace(',', '.'));
                return percentageB - percentageA;
            });
            
            let cardsToAdd = [];
            const addedNames = new Set(Object.keys(deck).filter(name => deck[name] > 0));
            
            // Step 3: Find and add best Ace Spec (highest percentage) - only 1x
            let bestAceSpec = null;
            for (const card of deckCards) {
                if (isAceSpec(card)) {
                    bestAceSpec = card;
                    console.log('[autoComplete] Selected Ace Spec:', bestAceSpec.card_name);
                    break;
                }
            }
            
            if (bestAceSpec && !addedNames.has(bestAceSpec.card_name)) {
                cardsToAdd.push({ ...bestAceSpec, addCount: 1 });
                addedNames.add(bestAceSpec.card_name);
                currentTotal += 1;
                console.log('[autoComplete] Added Ace Spec (1x):', bestAceSpec.card_name);
            } else {
                console.log('[autoComplete] WARNING: No Ace Spec found or already in deck');
            }
            
            // Step 4: Add remaining cards from highest percentage downwards with average count
            // Use multiple passes with decreasing thresholds to ensure we fill the deck
            const THRESHOLDS = [5.0, 2.0, 1.0, 0.1];
            
            for (const threshold of THRESHOLDS) {
                if (currentTotal >= 60) break;
                
                console.log(`[autoComplete] Pass with threshold ${threshold}%`);
                
                for (const card of deckCards) {
                    if (currentTotal >= 60) break;
                    
                    const cardName = card.card_name;
                    
                    // Skip if already added
                    if (addedNames.has(cardName)) continue;
                    
                    // Skip Ace Spec cards (except the best one already added)
                    if (isAceSpec(card)) continue;
                    
                    // Check percentage threshold - skip very low-usage cards
                    const percentage = parseFloat((card.percentage_in_archetype || '0').toString().replace(',', '.'));
                    if (percentage < threshold) {
                        continue;
                    }
                    
                    // Calculate AVERAGE count for this card: total_count / total_decks_in_archetype
                    const totalCount = parseFloat(card.total_count) || 1;
                    const totalDecksInArchetype = parseFloat(card.total_decks_in_archetype) || 1;
                    let addCount = Math.round(totalCount / totalDecksInArchetype);
                    
                    // For base energies, no limit. For other cards, max 4
                    if (!isBaseEnergy(card)) {
                        addCount = Math.max(1, Math.min(addCount, 4));
                    } else {
                        addCount = Math.max(1, addCount);
                    }
                    
                    // Don't exceed deck limit (60 total cards)
                    addCount = Math.min(addCount, 60 - currentTotal);
                    
                    if (addCount > 0) {
                        cardsToAdd.push({ ...card, addCount: addCount });
                        addedNames.add(cardName);
                        currentTotal += addCount;
                        console.log('[autoComplete] Adding:', addCount + 'x', cardName, '(' + percentage.toFixed(2) + '%, avg:', (totalCount/totalDecksInArchetype).toFixed(2) + ')');
                    }
                }
            }
            
            console.log('[autoComplete] Total cards to add:', currentTotal, 'in', cardsToAdd.length, 'unique entries');
            
            // Show summary grouped by type
            let summary = `Auto-Complete wird ${currentTotal} Karten hinzufügen:\n\n`;
            let pokemon = [], trainer = [], energy = [];
            
            cardsToAdd.forEach(card => {
                const cardType = card.type || card.card_type || '';
                const category = getCardTypeCategory(cardType);
                const line = `${card.addCount}x ${card.card_name}`;
                
                if (category === 'Pokemon') pokemon.push(line);
                else if (category === 'Energy') energy.push(line);
                else trainer.push(line);
            });
            
            if (pokemon.length > 0) summary += `Pokémon:\n${pokemon.join('\n')}\n\n`;
            if (trainer.length > 0) summary += `Trainer:\n${trainer.join('\n')}\n\n`;
            if (energy.length > 0) summary += `Energy:\n${energy.join('\n')}`;
            
            if (confirm(summary + '\n\nFortsetzung?')) {
                // Add all cards to deck using PREFERRED versions (newest low-rarity)
                cardsToAdd.forEach(card => {
                    // CRITICAL: Get preferred version for this card to match Grid View display
                    const originalSetCode = card.set_code || '';
                    const originalSetNumber = card.set_number || '';
                    const preferredVersion = getPreferredVersionForCard(card.card_name, originalSetCode, originalSetNumber);
                    
                    let setCode, setNumber;
                    if (preferredVersion) {
                        setCode = preferredVersion.set;
                        setNumber = preferredVersion.number;
                        console.log(`[autoComplete] Using PREFERRED version for ${card.card_name}: ${setCode} ${setNumber} (${preferredVersion.rarity})`);
                    } else {
                        // Fallback to original if no preferred version found
                        setCode = originalSetCode;
                        setNumber = originalSetNumber;
                        console.log(`[autoComplete] No preferred version for ${card.card_name}, using original: ${setCode} ${setNumber}`);
                    }
                    
                    for (let i = 0; i < card.addCount; i++) {
                        addCardToDeck(source, card.card_name, setCode, setNumber);
                    }
                });
                console.log('[autoComplete] Deck completed with rarity mode:', globalRarityPreference);
                
                // Show the deck grid with images
                renderMyDeckGrid(source);
                
                // CRITICAL: Also refresh the Overview Grid to show updated badges
                // Use the filter functions to preserve active filters (e.g., >90% cards)
                if (source === 'cityLeague') {
                    applyCityLeagueFilter();
                } else if (source === 'currentMeta') {
                    applyCurrentMetaFilter();
                }
                console.log('[autoComplete] Overview Grid refreshed to show updated deck badges (with active filters preserved)');
                
                // Save deck to localStorage
                if (source === 'cityLeague') {
                    saveCityLeagueDeck();
                } else if (source === 'currentMeta') {
                    saveCurrentMetaDeck();
                }
            }
        }
        
        function searchDeckCards() {
            const searchInput = document.getElementById('cityLeagueDeckCardSearch');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const resultsContainer = document.getElementById('cityLeagueDeckSearchResults');
            if (!resultsContainer) return;
            
            // Clear selection when search changes
            if (searchTerm !== window.lastCardSearch) {
                window.selectedCardName = null;
                window.lastCardSearch = searchTerm;
            }
            
            if (!searchTerm) {
                resultsContainer.innerHTML = '';
                window.selectedCardName = null;
                return;
            }
            
            // Search in ALL cards database
            const allAvailableCards = window.allCardsDatabase || [];
            
            // Debug logging
            if (allAvailableCards.length === 0) {
                console.warn('[searchDeckCards] allCardsDatabase is empty or not loaded yet');
                resultsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Kartendatenbank wird geladen...</div>';
                return;
            }
            
            // If a card name is selected, show all versions
            if (window.selectedCardName) {
                showCardVersions(window.selectedCardName, resultsContainer);
                return;
            }
            
            // STAGE 1: Show unique card names
            const matchingCards = allAvailableCards.filter(card => 
                card.name && card.name.toLowerCase().includes(searchTerm)
            );
            
            // Get unique card names
            const uniqueNames = [...new Set(matchingCards.map(c => c.name))].sort();
            
            console.log(`[searchDeckCards] Search term: "${searchTerm}", found ${uniqueNames.length} unique cards (${matchingCards.length} versions)`);
            
            if (uniqueNames.length === 0) {
                resultsContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #999;">Keine Karten gefunden</div>';
                return;
            }
            
            // Build list of card names (limit to 20)
            const limitedNames = uniqueNames.slice(0, 20);
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 6px;">';
            
            limitedNames.forEach(cardName => {
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                const versionsCount = matchingCards.filter(c => c.name === cardName).length;
                const deck = window.cityLeagueDeck || {};
                const currentCount = deck[cardName] || 0;
                
                // Get first version for thumbnail image
                const firstVersion = matchingCards.find(c => c.name === cardName);
                const imageUrl = firstVersion ? buildCardImageUrl(firstVersion.set, firstVersion.number, firstVersion.rarity) : '';
                
                html += `
                    <div onclick="selectCardName('${cardNameEscaped}')" style="background: white; padding: 8px; border-radius: 4px; cursor: pointer; transition: all 0.2s; border-left: 2px solid #667eea; display: flex; gap: 8px; align-items: center;" onmouseover="this.style.background='#f9f9f9'; this.style.transform='translateX(3px)';" onmouseout="this.style.background='white'; this.style.transform='translateX(0)';">
                        <div style="width: 40px; height: 50px; background: #f5f5f5; border-radius: 3px; overflow: hidden; flex-shrink: 0;">
                            <img src="${imageUrl}" alt="${cardName}" style="width: 100%; height: 100%; object-fit: contain; cursor: zoom-in;" onerror="this.style.display='none';" loading="lazy">
                        </div>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: 600; color: #333; font-size: 0.9em; line-height: 1.2; white-space: normal; word-break: break-word;">${cardName}</div>
                            <div style="font-size: 0.75em; color: #999;">${versionsCount} Version${versionsCount > 1 ? 'en' : ''}</div>
                        </div>
                        ${currentCount > 0 ? `<div style="background: #28a745; color: white; padding: 2px 6px; border-radius: 10px; font-size: 0.75em; font-weight: bold; flex-shrink: 0;">${currentCount}x</div>` : ''}
                    </div>
                `;
            });
            
            html += '</div>';
            resultsContainer.innerHTML = html;
        }
        
        function selectCardName(cardName) {
            window.selectedCardName = cardName;
            searchDeckCards(); // Refresh to show versions
        }
        
        function showCardVersions(cardName, container) {
            const allCards = window.allCardsDatabase || [];
            const versions = allCards.filter(c => c.name === cardName);
            
            const deck = window.cityLeagueDeck || {};
            
            // Calculate total count of all versions of this card in deck
            let totalCount = 0;
            for (const [key, count] of Object.entries(deck)) {
                if (key.startsWith(cardName + ' (') || key === cardName) {
                    totalCount += count;
                }
            }
            
            let html = '<div style="grid-column: 1 / -1; background: #f8f9fa; padding: 10px; border-radius: 8px; margin-bottom: 10px;">';
            html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
            html += `<div style="font-weight: bold; color: #333;">🎴 ${cardName}</div>`;
            html += `<button onclick="window.selectedCardName=null; searchDeckCards();" style="background: #6c757d; color: white; border: none; padding: 5px 15px; border-radius: 5px; cursor: pointer; font-size: 0.85em;">← Zurück</button>`;
            html += '</div>';
            html += `<div style="font-size: 0.85em; color: #666; margin-top: 8px;">${versions.length} Versionen | ${totalCount}x im Deck</div>`;
            html += '</div>';
            
            // Add card versions directly - they will be grid items in the parent grid
            versions.forEach(card => {
                const setCode = card.set || '';
                const setNumber = card.number || '';
                const rarityFull = card.rarity || '';
                
                // Check if THIS specific version is in the deck
                const deckKey = `${cardName} (${setCode} ${setNumber})`;
                const versionCount = deck[deckKey] || 0;
                
                // Try to build image URL - fallback to placeholder
                const imageUrl = buildCardImageUrl(setCode, setNumber, rarityFull);
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                
                html += `
                    <div style="position: relative; text-align: center; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 6px rgba(0,0,0,0.15); transition: transform 0.2s, box-shadow 0.2s;" onmouseover="this.style.transform='scale(1.03)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.25)';" onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='0 2px 6px rgba(0,0,0,0.15)';">
                        <div style="position: relative; cursor: zoom-in; background: #f5f5f5;" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped} (${setCode} ${setNumber})')">
                            <img src="${imageUrl}" alt="${cardName}" style="width: 100%; height: 160px; object-fit: contain;" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex';" loading="lazy">
                            <div style="display: none; width: 100%; height: 160px; align-items: center; justify-content: center; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; flex-direction: column; padding: 8px;">
                                <div style="font-size: 2em; margin-bottom: 5px;">🃏</div>
                                <div style="font-size: 0.7em; text-align: center;">${setCode}<br>${setNumber}</div>
                            </div>
                        </div>
                        ${versionCount > 0 ? `<div style="position: absolute; top: 4px; left: 4px; background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-size: 0.75em; font-weight: bold; z-index: 5; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${versionCount}</div>` : ''}
                        <button onclick="addCardToDeck('cityLeague', '${cardNameEscaped}', '${setCode}', '${setNumber}')" style="position: absolute; top: 4px; right: 4px; background: #28a745; color: white; border: none; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; cursor: pointer; box-shadow: 0 2px 6px rgba(0,0,0,0.3); z-index: 10; transition: all 0.2s;" onmouseover="this.style.transform='scale(1.1)'; this.style.background='#218838';" onmouseout="this.style.transform='scale(1)'; this.style.background='#28a745';" title="Zum Deck hinzufügen">+</button>
                        <div style="padding: 8px; background: white; border-top: 1px solid #f0f0f0;">
                            <div style="font-size: 0.7em; color: #666; font-weight: 600;">${setCode} ${setNumber}</div>
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function buildCardImageUrl(setCode, setNumber, rarity) {
            // Build Limitless CDN URL with fallback patterns
            // Pattern: https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpci/{SET}/{SET}_{NUMBER}_R_EN_LG.png
            
            if (!setCode || !setNumber) {
                return 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22245%22 height=%22342%22%3E%3Crect fill=%22%23667eea%22 width=%22245%22 height=%22342%22/%3E%3Ctext fill=%22white%22 x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 font-size=%2220%22%3EKeine Daten%3C/text%3E%3C/svg%3E';
            }
            
            // Determine rarity code
            let rarityCode = 'R'; // Default to Rare
            if (rarity) {
                const r = rarity.toLowerCase();
                if (r.includes('uncommon')) rarityCode = 'U';
                else if (r.includes('common') && !r.includes('uncommon')) rarityCode = 'C';
                else if (r.includes('holo')) rarityCode = 'R';
            }
            
            // Pad numeric card numbers to 3 digits (86 -> 086, TG24 stays TG24)
            let paddedNumber = setNumber;
            if (/^\d+$/.test(setNumber)) {
                paddedNumber = setNumber.padStart(3, '0');
            }
            
            // Build URL: MEG_086_R_EN_LG.png
            return `https://limitlesstcg.nyc3.cdn.digitaloceanspaces.com/tpci/${setCode}/${setCode}_${paddedNumber}_${rarityCode}_EN_LG.png`;
        }
        
        // Initialize deck card search listener
        document.addEventListener('DOMContentLoaded', function() {
            const searchInput = document.getElementById('cityLeagueDeckCardSearch');
            if (searchInput) {
                searchInput.addEventListener('input', searchDeckCards);
            }
        });

        function toggleCurrentCards() {
            const content = document.getElementById('currentCardsContent');
            const toggle = document.getElementById('currentCardsToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }

        function togglePastCards() {
            const content = document.getElementById('pastCardsContent');
            const toggle = document.getElementById('pastCardsToggle');
            if (content && toggle) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    toggle.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    toggle.classList.add('collapsed');
                }
            }
        }

        // Filter functions
        function filterCurrentAnalysisCards() {
            const searchTerm = (document.getElementById('currentCardSearchInput')?.value || '').toLowerCase();
            const rows = document.querySelectorAll('#currentAnalysisTable table tbody tr');
            let visibleCount = 0;

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const visible = text.includes(searchTerm);
                row.style.display = visible ? '' : 'none';
                if (visible) visibleCount += 1;
            });

            const countEl = document.getElementById('currentCardCount');
            if (countEl) {
                countEl.textContent = `${visibleCount} Karten`;
            }
        }

        function filterPastMetaCards() {
            const searchTerm = (document.getElementById('pastCardSearchInput')?.value || '').toLowerCase();
            const rows = document.querySelectorAll('#pastMetaTable table tbody tr');
            let visibleCount = 0;

            rows.forEach(row => {
                const text = row.textContent.toLowerCase();
                const visible = text.includes(searchTerm);
                row.style.display = visible ? '' : 'none';
                if (visible) visibleCount += 1;
            });

            const countEl = document.getElementById('pastCardCount');
            if (countEl) {
                countEl.textContent = `${visibleCount} Karten`;
            }
        }

        // Deck Builder functions (placeholder implementations)
        const deckBuilders = {
            cityLeague: [],
            current: [],
            past: []
        };

        // Toggle for Current Meta cards
        // Load Current Meta - load HTML and patch the table
        async function loadCurrentMeta() {
            const currentMetaContent = document.getElementById('currentMetaContent');
            
            try {
                // Load the full HTML file
                const response = await fetch(BASE_PATH + 'limitless_online_decks_comparison.html?t=' + Date.now());
                if (!response.ok) throw new Error('HTML nicht gefunden');
                
                const html = await response.text();
                
                // Parse the loaded HTML
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                
                // Extract the container content
                const container = doc.querySelector('.container');
                if (container) {
                    // Insert the full container HTML (includes stats, climbers, matchups, table)
                    currentMetaContent.innerHTML = container.innerHTML;
                    
                    // Now patch ONLY the Full Comparison Table with our improved version
                    patchLimitlessComparisonTable();
                    
                    // Patch the Archetype Overview stat card with current CSV data
                    await patchArchetypeOverview();
                    
                    // Patch the Meta stat card with tournament stats
                    await patchMetaStats();
                    
                    // Execute any scripts for matchup charts
                    const scripts = doc.querySelectorAll('script');
                    scripts.forEach(script => {
                        if (script.textContent && script.textContent.trim()) {
                            try {
                                (0, eval)(script.textContent);
                            } catch (scriptError) {
                                console.warn('Error executing script:', scriptError);
                            }
                        }
                    });
                    
                    console.log('✅ Current Meta data loaded successfully');
                } else {
                    currentMetaContent.innerHTML = '<div style="color: #e74c3c; padding: 20px;">Fehler beim Laden der Vergleichsdaten</div>';
                }
                
                window.currentMetaLoaded = true;
            } catch (error) {
                console.error('Error loading Current Meta:', error);
                currentMetaContent.innerHTML = `
                    <div style="color: #e74c3c; padding: 20px;">
                        <strong>Fehler:</strong> Die Vergleichs-HTML konnte nicht geladen werden.
                        <br><small>${error.message}</small>
                    </div>
                `;
            }
        }
        
        // Patch the Full Comparison Table to use condensed rank format
        function patchLimitlessComparisonTable() {
            // Find all tables in the current meta content
            const tables = document.querySelectorAll('#currentMetaContent table');
            
            // The Full Comparison Table is typically the last table
            tables.forEach(table => {
                const thead = table.querySelector('thead tr');
                if (!thead) return;
                
                const headers = Array.from(thead.querySelectorAll('th')).map(th => th.textContent.trim());
                
                // Check if this is the Full Comparison Table (has Old Rank, New Rank, Rank Δ columns)
                if (headers.includes('Old Rank') && headers.includes('New Rank') && headers.includes('Rank Δ')) {
                    console.log('📋 Patching Full Comparison Table...');
                    
                    // Find column indices
                    const oldRankIdx = headers.indexOf('Old Rank');
                    const newRankIdx = headers.indexOf('New Rank');
                    const rankDeltaIdx = headers.indexOf('Rank Δ');
                    
                    // Remove Old Rank and Rank Δ headers, keep only New Rank and rename it to "Rank"
                    const thOldRank = thead.querySelectorAll('th')[oldRankIdx];
                    const thRankDelta = thead.querySelectorAll('th')[rankDeltaIdx];
                    const thNewRank = thead.querySelectorAll('th')[newRankIdx];
                    
                    thOldRank.remove();
                    thRankDelta.remove();
                    thNewRank.textContent = 'Rank';
                    
                    // Update each data row
                    const rows = table.querySelectorAll('tbody tr');
                    rows.forEach(row => {
                        const cells = row.querySelectorAll('td');
                        if (cells.length < Math.max(oldRankIdx, newRankIdx, rankDeltaIdx) + 1) return;
                        
                        const oldRankCell = cells[oldRankIdx];
                        const newRankCell = cells[newRankIdx];
                        const rankDeltaCell = cells[rankDeltaIdx];
                        
                        // Extract rank change from the delta cell
                        const deltaHtml = rankDeltaCell.innerHTML;
                        let changeText = '';
                        if (deltaHtml.includes('rank-up')) {
                            const match = deltaHtml.match(/▲\s*(\d+)/);
                            if (match) changeText = ` <span style="color: #27ae60; font-size: 0.9em;">(▲${match[1]})</span>`;
                        } else if (deltaHtml.includes('rank-down')) {
                            const match = deltaHtml.match(/▼\s*(\d+)/);
                            if (match) changeText = ` <span style="color: #e74c3c; font-size: 0.9em;">(▼${match[1]})</span>`;
                        } else {
                            changeText = ' <span style="color: #95a5a6; font-size: 0.9em;">(-)</span>';
                        }
                        
                        // Update new rank cell to include change
                        newRankCell.innerHTML = newRankCell.textContent + changeText;
                        
                        // Remove old rank and delta cells
                        oldRankCell.remove();
                        rankDeltaCell.remove();
                    });
                    
                    console.log('✅ Full Comparison Table patched successfully');
                }
            });
        }

        // Patch Archetype Overview stat card with live CSV data
        async function patchArchetypeOverview() {
            try {
                // Load CSV data
                const csvData = await loadCSV('limitless_online_decks_comparison.csv');
                if (!csvData || csvData.length === 0) {
                    console.warn('⚠️ No CSV data available for stat patching');
                    return;
                }
                
                // Calculate total archetypes
                const totalArchetypes = csvData.length;
                
                // Group by main Pokemon (first word before space)
                const mainPokemonGroups = new Set();
                csvData.forEach(row => {
                    if (row.deck_name) {
                        const mainPokemon = row.deck_name.split(' ')[0];
                        mainPokemonGroups.add(mainPokemon);
                    }
                });
                const groupedArchetypes = mainPokemonGroups.size;
                
                // Calculate Top 3 by Count
                const decksByCount = csvData
                    .map(row => ({
                        name: row.deck_name,
                        count: parseInt(row.new_count || '0', 10)
                    }))
                    .sort((a, b) => b.count - a.count)
                    .slice(0, 3);
                
                // Calculate Top 3 by Win Rate (≥10% of #1 deck count)
                const maxCount = Math.max(...csvData.map(row => parseInt(row.new_count || '0', 10)));
                const minCountThreshold = maxCount * 0.1;
                
                const decksByWinRate = csvData
                    .filter(row => parseInt(row.new_count || '0', 10) >= minCountThreshold)
                    .map(row => ({
                        name: row.deck_name,
                        winRate: parseFloat(row.new_winrate || '0'),
                        count: parseInt(row.new_count || '0', 10)
                    }))
                    .sort((a, b) => b.winRate - a.winRate)
                    .slice(0, 3);
                
                // Generate HTML for display
                const top3ByCountHtml = decksByCount
                    .map(d => `<span style="color: #3498db;">${d.name}</span> (${d.count.toLocaleString()})`)
                    .join('<br>');
                
                const top3ByWinRateHtml = decksByWinRate
                    .map(d => `<span style="color: #27ae60;">${d.name}</span> (${d.winRate.toFixed(1)}%)`)
                    .join('<br>');
                
                // Find and update the Archetype Overview stat card
                const statCards = document.querySelectorAll('#currentMetaContent .stat-card');
                statCards.forEach(card => {
                    const h3 = card.querySelector('h3');
                    if (h3 && h3.textContent.includes('Archetype Overview')) {
                        // Update the value
                        const valueDiv = card.querySelector('.value');
                        if (valueDiv) {
                            valueDiv.textContent = `${totalArchetypes} (${groupedArchetypes})`;
                        }
                        
                        // Update Top 3 by Count
                        const paragraphs = card.querySelectorAll('p');
                        paragraphs.forEach(p => {
                            const strong = p.querySelector('strong');
                            if (strong && strong.textContent.includes('Top 3 by Count')) {
                                p.innerHTML = `<strong>Top 3 by Count:</strong><br>${top3ByCountHtml}`;
                            } else if (strong && strong.textContent.includes('Win Rate')) {
                                p.innerHTML = `<strong>Top 3 by Win Rate:</strong><br>${top3ByWinRateHtml}`;
                            }
                        });
                        
                        console.log('✅ Archetype Overview patched:', {
                            totalArchetypes,
                            groupedArchetypes,
                            top3Count: decksByCount.map(d => d.name),
                            top3WR: decksByWinRate.map(d => d.name)
                        });
                    }
                });
            } catch (error) {
                console.error('❌ Error patching Archetype Overview:', error);
            }
        }
        
        // Patch Meta stat card with tournament statistics
        async function patchMetaStats() {
            try {
                // Load Limitless meta statistics from JSON file
                let metaStats = { tournaments: 0, players: 0, matches: 0 };
                try {
                    const metaResponse = await fetch(BASE_PATH + 'limitless_meta_stats.json?t=' + Date.now());
                    if (metaResponse.ok) {
                        metaStats = await metaResponse.json();
                    }
                } catch (e) {
                    console.warn('Could not load limitless_meta_stats.json:', e);
                }
                
                // Load tournament overview data - filter by SVI-PFL format only
                const tournamentData = await loadCSV('tournament_cards_data_overview.csv');
                let majorTournaments = 0;
                let totalPlayers = 0;
                
                if (tournamentData && tournamentData.length > 0) {
                    const svipflTournaments = tournamentData.filter(row => row.format === 'SVI-PFL');
                    majorTournaments = svipflTournaments.length;
                    totalPlayers = svipflTournaments.reduce((sum, row) => {
                        return sum + (parseInt(row.players, 10) || 0);
                    }, 0);
                }
                
                // Find and update the Meta stat card
                const statCards = document.querySelectorAll('#currentMetaContent .stat-card');
                statCards.forEach(card => {
                    const h3 = card.querySelector('h3');
                    if (h3 && h3.textContent.includes('Meta')) {
                        // Add tournament stats below the current format
                        const existingP = card.querySelector('p');
                        if (existingP && existingP.textContent.includes('Current Format')) {
                            // Add new stats
                            const statsHtml = `
                                <p style="font-size: 0.85em; color: #7f8c8d; margin: 15px 0 5px 0; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;">
                                    <strong style="color: #3498db;">📊 Online Meta:</strong><br>
                                    <span style="font-size: 0.95em;">${metaStats.tournaments.toLocaleString()} tournaments · ${metaStats.players.toLocaleString()} players · ${metaStats.matches.toLocaleString()} matches</span>
                                </p>
                                <p style="font-size: 0.85em; color: #7f8c8d; margin: 5px 0 0 0;">
                                    <strong style="color: #27ae60;">🏆 Major Tournaments:</strong><br>
                                    <span style="font-size: 0.95em;">${majorTournaments} tournaments · ${totalPlayers.toLocaleString()} players</span>
                                </p>
                            `;
                            existingP.insertAdjacentHTML('afterend', statsHtml);
                        }
                        
                        console.log('✅ Meta stats patched:', {
                            onlineStats: metaStats,
                            majorTournaments,
                            totalPlayers,
                            format: 'SVI-PFL'
                        });
                    }
                });
            } catch (error) {
                console.error('❌ Error patching Meta stats:', error);
            }
        }



        
        // Load Current Analysis
        async function loadCurrentAnalysis() {
            console.log('🔄 Loading Current Meta Analysis Tab...');
            
            // Load Current Meta Analysis (deck analysis)
            if (!window.currentMetaAnalysisLoaded) {
                await loadCurrentMetaAnalysis();
            }
            
            // Load saved deck from localStorage
            loadCurrentMetaDeck();
            
            window.currentAnalysisLoaded = true;
        }
        
        // LocalStorage functions for Current Meta
        function loadCurrentMetaDeck() {
            const saved = localStorage.getItem('currentMetaDeck');
            if (!saved) {
                console.log('📂 No saved Current Meta deck found');
                return;
            }
            
            try {
                const data = JSON.parse(saved);
                console.log('✅ Loaded Current Meta deck from localStorage:', data);
                
                if (data.deck) {
                    window.currentMetaDeck = data.deck;
                }
                if (data.order) {
                    window.currentMetaDeckOrder = data.order;
                }
                if (data.archetype) {
                    window.currentCurrentMetaArchetype = data.archetype;
                    // Pre-select archetype in dropdown if it exists (but don't display deck yet)
                    console.log('📂 Saved archetype found:', data.archetype, '(waiting for user to select archetype)');
                }
                
                // DON'T automatically display deck - wait for archetype selection
                console.log('📊 Current Meta Deck loaded but not displayed (waiting for archetype selection)');
            } catch (e) {
                console.error('❌ Error loading Current Meta deck:', e);
            }
        }
        
        function saveCurrentMetaDeck() {
            const data = {
                deck: window.currentMetaDeck || {},
                order: window.currentMetaDeckOrder || [],
                archetype: window.currentCurrentMetaArchetype || null,
                timestamp: new Date().toISOString()
            };
            
            try {
                localStorage.setItem('currentMetaDeck', JSON.stringify(data));
                console.log('💾 Current Meta deck saved to localStorage');
            } catch (e) {
                console.error('❌ Error saving Current Meta deck:', e);
            }
        }
        
        // Load Past Meta
        async function loadPastMeta() {
            const tableContainer = document.getElementById('pastMetaTable');
            const data = await loadCSV('tournament_cards_data_cards.csv');
            
            if (data) {
                renderDeckAnalysisTable(data, tableContainer, 'pastCardCount', 'pastCardCountSummary');
                window.pastMetaLoaded = true;
            } else if (tableContainer) {
                tableContainer.innerHTML = '<div class="error">tournament_cards_data_cards.csv nicht gefunden</div>';
            }
        }

        // Generic function to render deck analysis tables
        function renderDeckAnalysisTable(data, container, countElementId, summaryElementId) {
            if (!container || !data || data.length === 0) return;

            const headers = Object.keys(data[0]);
            let html = '<table><thead><tr>';
            headers.forEach(header => {
                html += `<th>${header}</th>`;
            });
            html += '</tr></thead><tbody>';

            data.forEach(row => {
                html += '<tr>';
                headers.forEach(header => {
                    html += `<td>${row[header]}</td>`;
                });
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;

            const countEl = document.getElementById(countElementId);
            const summaryEl = document.getElementById(summaryElementId);
            if (countEl && summaryEl) {
                countEl.textContent = `${data.length} Karten`;
                summaryEl.textContent = `/ ${data.length} Total`;
            }
        }
        
        // Load Cards
        let allCards = [];
        // Card Database Variables
        let allCardsData = [];
        let filteredCardsData = [];
        
        async function loadCards() {
            const content = document.getElementById('cardsContent');
            content.innerHTML = '<div class="loading">Lädt Kartendatenbank...</div>';
            
            try {
                // Load all_cards_database.csv
                const response = await fetch(BASE_PATH + 'all_cards_database.csv');
                const csvText = await response.text();
                const cards = parseCSV(csvText);
                
                // Store globally
                window.allCardsData = cards;
                allCardsData = cards;
                
                console.log(`Loaded ${cards.length} cards from database`);
                
                // Populate Set filter
                populateSetFilter(cards);
                
                // Setup filter event listeners
                setupCardFilters();
                
                // Initial render
                filterAndRenderCards();
                
                window.cardsLoaded = true;
            } catch (error) {
                console.error('Error loading card database:', error);
                content.innerHTML = '<div class="error">❌ Fehler beim Laden der Kartendatenbank</div>';
            }
        }
        
        function populateSetFilter(cards) {
            const setFilter = document.getElementById('cardSetFilter');
            // Filter out invalid cards and get unique sets
            const sets = [...new Set(cards
                .filter(c => c && c.set && c.set !== 'set')
                .map(c => c.set)
            )].sort();
            
            setFilter.innerHTML = '<option value="">Alle Sets</option>';
            sets.forEach(set => {
                const option = document.createElement('option');
                option.value = set;
                option.textContent = set;
                setFilter.appendChild(option);
            });
        }
        
        function setupCardFilters() {
            const searchInput = document.getElementById('cardSearch');
            const setFilter = document.getElementById('cardSetFilter');
            const categoryFilter = document.getElementById('cardCategoryFilter');
            const elementFilter = document.getElementById('cardElementFilter');
            const rarityFilter = document.getElementById('cardRarityFilter');
            
            searchInput.addEventListener('input', filterAndRenderCards);
            setFilter.addEventListener('change', filterAndRenderCards);
            categoryFilter.addEventListener('change', () => {
                filterAndRenderCards();
                // Show/hide element filter based on category
                const elementContainer = document.getElementById('elementFilterContainer');
                elementContainer.style.display = categoryFilter.value === 'pokemon' || !categoryFilter.value ? 'block' : 'none';
            });
            elementFilter.addEventListener('change', filterAndRenderCards);
            rarityFilter.addEventListener('change', filterAndRenderCards);
        }
        
        function resetCardFilters() {
            document.getElementById('cardSearch').value = '';
            document.getElementById('cardSetFilter').value = '';
            document.getElementById('cardCategoryFilter').value = '';
            document.getElementById('cardElementFilter').value = '';
            document.getElementById('cardRarityFilter').value = '';
            document.getElementById('elementFilterContainer').style.display = 'block';
            filterAndRenderCards();
        }
        
        function filterAndRenderCards() {
            const searchTerm = document.getElementById('cardSearch').value.toLowerCase();
            const setFilter = document.getElementById('cardSetFilter').value;
            const categoryFilter = document.getElementById('cardCategoryFilter').value;
            const elementFilter = document.getElementById('cardElementFilter').value;
            const rarityFilter = document.getElementById('cardRarityFilter').value;
            
            filteredCardsData = allCardsData.filter(card => {
                // Skip invalid cards
                if (!card || !card.name || card.name === 'name' || !card.image_url) {
                    return false;
                }
                
                // Search filter
                if (searchTerm && !card.name.toLowerCase().includes(searchTerm)) {
                    return false;
                }
                
                // Set filter
                if (setFilter && card.set !== setFilter) {
                    return false;
                }
                
                // Category filter
                if (categoryFilter) {
                    const type = card.type || '';
                    if (categoryFilter === 'pokemon') {
                        // Pokemon have element prefix (G, R, W, L, P, F, D, M, N, C, Y)
                        const isPokemon = /^[GRWLPFDMNCYDL]/.test(type) && !['Item', 'Supporter', 'Stadium', 'Tool', 'Energy'].some(t => type.includes(t));
                        if (!isPokemon) return false;
                    } else if (categoryFilter === 'trainer') {
                        if (!['Item', 'Supporter', 'Stadium', 'Tool'].some(t => type.includes(t))) return false;
                    } else if (categoryFilter === 'energy') {
                        if (!type.includes('Energy')) return false;
                    }
                }
                
                // Element filter (only for Pokemon)
                if (elementFilter) {
                    const type = card.type || '';
                    if (!type.startsWith(elementFilter)) {
                        return false;
                    }
                }
                
                // Rarity filter
                if (rarityFilter && card.rarity !== rarityFilter) {
                    return false;
                }
                
                return true;
            });
            
            renderCardDatabase(filteredCardsData);
        }
        
        function renderCardDatabase(cards) {
            const content = document.getElementById('cardsContent');
            const resultsInfo = document.getElementById('cardResultsInfo');
            
            if (cards.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 40px; color: #7f8c8d;"><h2>🔍 Keine Karten gefunden</h2><p>Versuche andere Filter-Einstellungen</p></div>';
                resultsInfo.textContent = '0 Karten gefunden';
                return;
            }
            
            resultsInfo.textContent = `${cards.length.toLocaleString()} Karten gefunden`;
            
            const grid = document.createElement('div');
            grid.className = 'card-database-grid';
            
            cards.forEach(card => {
                // Skip cards with missing essential data
                if (!card.name || !card.image_url) {
                    return;
                }
                const cardEl = createCardDatabaseItem(card);
                if (cardEl) {
                    grid.appendChild(cardEl);
                }
            });
            
            content.innerHTML = '';
            content.appendChild(grid);
        }
        
        function createCardDatabaseItem(card) {
            // Validate essential fields
            if (!card.name || !card.image_url) {
                return null;
            }
            
            const item = document.createElement('div');
            item.className = 'card-database-item';
            
            const rarityClass = getRarityClass(card.rarity);
            
            // Escape strings for HTML attributes
            const escapedName = (card.name || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const escapedImageUrl = (card.image_url || '').replace(/'/g, "\\'");
            const displayName = card.name || 'Unknown Card';
            const displaySet = card.set || '???';
            const displayNumber = card.number || '?';
            const displayType = card.type || 'Unknown';
            const displayRarity = card.rarity || 'Unknown';
            const displayCardMarketUrl = card.cardmarket_url || '#';
            
            item.innerHTML = `
                <img src="${escapedImageUrl}" alt="${displayName}" onclick="showImageView('${escapedImageUrl}', '${escapedName}')">
                <div class="card-database-info">
                    <div class="card-database-name">${displayName}</div>
                    <div class="card-database-meta">
                        <span class="card-database-set">${displaySet} ${displayNumber}</span>
                        <span class="card-database-type">${displayType}</span>
                    </div>
                    <span class="card-database-rarity ${rarityClass}">${displayRarity}</span>
                    <div class="card-database-actions">
                        <button class="card-database-btn card-database-btn-rarity" onclick='openRaritySwitcherFromDB("${escapedName}", "${displaySet}", "${displayNumber}")'>
                            🔄 Prints
                        </button>
                        <a href="${displayCardMarketUrl}" target="_blank" class="card-database-btn card-database-btn-market">
                            💰 CardMarket
                        </a>
                    </div>
                </div>
            `;
            
            return item;
        }
        
        function getRarityClass(rarity) {
            if (!rarity) return '';
            const r = rarity.toLowerCase();
            if (r.includes('common')) return 'rarity-common';
            if (r.includes('uncommon')) return 'rarity-uncommon';
            if (r === 'rare') return 'rarity-rare';
            if (r.includes('holo rare')) return 'rarity-holo';
            if (r.includes('double rare')) return 'rarity-double';
            if (r.includes('triple rare')) return 'rarity-triple';
            if (r.includes('ultra rare')) return 'rarity-ultra';
            if (r.includes('secret rare')) return 'rarity-secret';
            if (r.includes('rainbow rare')) return 'rarity-rainbow';
            if (r === 'art rare') return 'rarity-art';
            if (r.includes('special art')) return 'rarity-special-art';
            if (r.includes('character holo')) return 'rarity-char-holo';
            if (r.includes('character super')) return 'rarity-char-super';
            if (r.includes('radiant')) return 'rarity-radiant';
            if (r === 'shiny rare') return 'rarity-shiny';
            if (r.includes('shiny ultra')) return 'rarity-shiny-ultra';
            if (r.includes('promo')) return 'rarity-promo';
            return '';
        }
        
        function openRaritySwitcherFromDB(cardName, set, number) {
            // Create a deckKey format that openRaritySwitcher expects
            const deckKey = `${cardName} (${set} ${number})`;
            openRaritySwitcher(cardName, deckKey);
        }
        
        function filterCards() {
            // This function is called from the old search box, now handled by filterAndRenderCards
            filterAndRenderCards();
        }
        
        // Rarity Switcher Functions
        let currentRaritySwitcherCard = null;

        function openRaritySwitcher(cardName, deckKey) {
            if (!window.allCardsDatabase) {
                alert('Karten-Datenbank noch nicht geladen...');
                return;
            }

            // Extract card name from deckKey if needed (handle "CardName (SET NUM)" format)
            const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
            const actualCardName = baseNameMatch ? baseNameMatch[1] : cardName;
            
            // Extract set and number from deckKey (e.g., "Boss's Orders (RCL 189)" -> set="RCL", number="189")
            const setNumMatch = deckKey.match(/\(([A-Z0-9]+)\s+(\d+[A-Z]*)\)/);
            let currentSet = '';
            let currentNumber = '';
            if (setNumMatch) {
                currentSet = setNumMatch[1];
                currentNumber = setNumMatch[2];
            }
            
            console.log(`[openRaritySwitcher] cardName: ${cardName}, deckKey: ${deckKey}, actualCardName: ${actualCardName}`);

            currentRaritySwitcherCard = { cardName: actualCardName, deckKey };
            
            // Find current card's data
            let currentCard = null;
            if (currentSet && currentNumber) {
                currentCard = window.allCardsDatabase.find(c => 
                    c.name === actualCardName && c.set === currentSet && c.number === currentNumber
                );
            }
            
            // Fallback: If no SET/NUMBER available, find the card with HIGHEST RARITY and MOST international_prints
            // This ensures we get the complete list AND prefer special versions (e.g., MEP Promos over Common prints)
            if (!currentCard && window.allCardsDatabase) {
                const candidateCards = window.allCardsDatabase.filter(c => 
                    c.name === actualCardName && c.type && c.type.trim() !== '' && c.international_prints
                );
                
                if (candidateCards.length > 0) {
                    // Sort by rarity (descending), then by number of international_prints (descending)
                    candidateCards.sort((a, b) => {
                        // First: Compare rarity (higher rarity = better)
                        const rarityDiff = getRarityRank(b.rarity) - getRarityRank(a.rarity);
                        if (rarityDiff !== 0) {
                            return rarityDiff;
                        }
                        
                        // Second: Compare number of international_prints (more prints = more complete data)
                        const aCount = (a.international_prints || '').split(',').length;
                        const bCount = (b.international_prints || '').split(',').length;
                        return bCount - aCount;
                    });
                    
                    currentCard = candidateCards[0];
                    const intPrintCount = (currentCard.international_prints || '').split(',').length;
                    console.log(`[openRaritySwitcher] Using card with HIGHEST RARITY as reference: ${currentCard.set}-${currentCard.number} (${currentCard.rarity}, ${intPrintCount} prints)`);
                } else {
                    // Fallback to any card with this name (for type detection)
                    const fallbackCard = window.allCardsDatabase.find(c => 
                        c.name === actualCardName && c.type && c.type.trim() !== ''
                    );
                    if (fallbackCard) {
                        currentCard = fallbackCard;
                        console.log(`[openRaritySwitcher] Using fallback card for type detection: ${fallbackCard.set}-${fallbackCard.number} (${fallbackCard.type})`);
                    }
                }
            }
            
            // Determine if this is a Pokemon card or Trainer/Energy card
            // Trainer/Energy types: Supporter, Item, Stadium, Tool, Energy, Special Energy, Basic Energy
            const trainerEnergyTypes = ['Supporter', 'Item', 'Stadium', 'Tool', 'Energy', 'Special Energy', 'Basic Energy'];
            const isPokemonCard = currentCard && currentCard.type && !trainerEnergyTypes.includes(currentCard.type);
            
            // Find all versions based on card type
            let versions = [];
            
            if (isPokemonCard) {
                // POKEMON CARDS: Use international_prints from Limitless "Int. Prints" table
                // This is THE definitive source - shows ALL functionally identical cards
                // regardless of artwork, illustrator, or set
                if (currentCard && currentCard.international_prints) {
                    // Parse the comma-separated list of international prints
                    // Format: "ASC-113,MEG-77,MEG-160,MEG-179,MEG-188,MPROMO-12"
                    const intPrintIds = currentCard.international_prints.split(',').map(s => s.trim());
                    const intPrintSet = new Set(intPrintIds);
                    
                    // Find all cards that match any of these set-number combinations
                    versions = window.allCardsDatabase.filter(card => {
                        const cardId = `${card.set}-${card.number}`;
                        return intPrintSet.has(cardId) && card.name === actualCardName;
                    });
                    
                    console.log(`[Pokemon Card] Found ${versions.length} international prints from Limitless data`);
                    console.log(`[Pokemon Card] Int. Print IDs:`, intPrintIds);
                } else {
                    // No international_prints data available - show only current card
                    versions = currentCard ? [currentCard] : [];
                    console.warn(`[Pokemon Card] No international_prints data available, showing only current version`);
                    if (versions.length === 1 && currentCard) {
                        alert(`⚠️ International Print Daten für diese Karte noch nicht verfügbar.\n\nBitte All Cards Scraper neu laufen lassen mit international_prints Support.`);
                    }
                }
            } else {
                // TRAINER/ENERGY CARDS: Use name-based matching
                // All versions with same name are functionally identical (reprints)
                if (window.cardsByNameMap && window.cardsByNameMap[actualCardName]) {
                    versions = window.cardsByNameMap[actualCardName].slice();
                    console.log(`[Trainer/Energy] Found ${versions.length} reprints via name matching`);
                } else if (window.allCardsDatabase) {
                    versions = window.allCardsDatabase.filter(card => card.name === actualCardName);
                    console.log(`[Trainer/Energy] Found ${versions.length} reprints via direct search`);
                } else {
                    versions = currentCard ? [currentCard] : [];
                }
            }
            
            // Filter to English sets only if we have the set mapping
            if (window.englishSetCodes && window.englishSetCodes.size > 0) {
                versions = versions.filter(version => window.englishSetCodes.has(version.set));
                console.log(`[openRaritySwitcher] After English filter: ${versions.length} versions`);
            }
            
            // Filter to only show cards with COMPLETE data
            // Special handling: Pokemon cards found via international_prints are trusted (Limitless data is reliable)
            // For Trainer/Energy (name-based matching), apply strict filter to avoid showing incomplete reprints
            const beforeCompleteFilter = versions.length;
            if (!isPokemonCard) {
                // TRAINER/ENERGY: Strict filter - must have rarity, image_url, and international_prints
                versions = versions.filter(version => {
                    const hasRarity = version.rarity && version.rarity.trim() !== '';
                    const hasImageUrl = version.image_url && version.image_url.trim() !== '';
                    const hasIntPrints = version.international_prints && version.international_prints.trim() !== '';
                    return hasRarity && hasImageUrl && hasIntPrints;
                });
                if (beforeCompleteFilter > versions.length) {
                    console.log(`[Trainer/Energy Filter] Filtered out ${beforeCompleteFilter - versions.length} incomplete cards`);
                    console.log(`[openRaritySwitcher] After complete data filter: ${versions.length} versions`);
                }
            } else {
                // POKEMON: Trust international_prints data from Limitless - show all versions even if rarity/image missing
                // These are functionally identical cards validated by Limitless TCG database
                console.log(`[Pokemon Filter] Showing all ${versions.length} international prints (trusted Limitless data)`);
            }
            
            if (versions.length === 0) {
                alert(`Keine vollständigen Versionen für "${actualCardName}" gefunden.\n\nMögliche Gründe:\n- Karte nicht vollständig in Datenbank (fehlt Rarity/Image URL/Int. Prints)\n- All Cards Scraper muss noch Daten ergänzen\n- Nur japanische Sets verfügbar\n\nGesuchter Name: "${actualCardName}"\n\nTipp: Warte bis All Cards Scraper fertig ist.`);
                console.error(`[openRaritySwitcher] No complete versions found for "${actualCardName}".`);
                return;
            }

            // Build rarity options
            const optionsList = document.getElementById('rarityOptionsList');
            optionsList.innerHTML = '';

            versions.forEach(version => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'rarity-option-card';
                
                // Check if this is the current version
                const versionKey = `${actualCardName} (${version.set} ${version.number})`;
                if (deckKey === versionKey) {
                    optionDiv.classList.add('selected');
                }
                
                optionDiv.onclick = () => selectRarityVersion(version.set, version.number, deckKey, actualCardName);
                
                let imageHtml = '';
                const imageUrl = version.image_url || buildCardImageUrl(version.set, version.number, version.rarity);
                imageHtml = `<img src="${imageUrl}" alt="${actualCardName} - ${version.rarity}" loading="lazy">`;
                
                const rarityBadgeColor = getRarityColor(version.rarity);
                
                // Get price and Cardmarket URL
                const eurPrice = version.eur_price || '';
                const cardmarketUrl = version.cardmarket_url || '';
                const priceDisplay = eurPrice || 'Preis N/A';
                const cardmarketBtnClass = eurPrice ? 'btn-cardmarket rarity-option-cardmarket' : 'btn-cardmarket rarity-option-cardmarket no-price';
                
                optionDiv.innerHTML = `
                    ${imageHtml}
                    <div class="rarity-option-info">
                        <div><strong>${version.set} ${version.number}</strong></div>
                        <div style="font-size: 11px; color: #999;">Rarity: ${version.rarity || 'N/A'}</div>
                    </div>
                    <div class="rarity-badge" style="background-color: ${rarityBadgeColor};">
                        ${version.rarity || 'Unknown'}
                    </div>
                    ${cardmarketUrl ? `
                        <button class="${cardmarketBtnClass}" 
                                onclick="event.stopPropagation(); window.open('${cardmarketUrl}', '_blank');" 
                                title="Auf Cardmarket kaufen: ${priceDisplay}">
                            ${priceDisplay}
                        </button>
                    ` : ''}
                `;
                
                optionsList.appendChild(optionDiv);
            });

            document.getElementById('raritySwitcherTitle').textContent = `${actualCardName} - Rarity Switcher`;
            const modal = document.getElementById('raritySwitcherModal');
            modal.classList.add('show');
        }

        function selectRarityVersion(setCode, setNumber, oldDeckKey, cardName) {
            if (!window.cityLeagueDeck) return;

            // Extract card name from oldDeckKey if needed
            const match = oldDeckKey.match(/^(.+?)\s*\(/);
            const actualCardName = cardName || (match ? match[1] : oldDeckKey);
            
            // Create new key with new version
            const newKey = `${actualCardName} (${setCode} ${setNumber})`;
            
            // Get current count for this card
            const currentCount = window.cityLeagueDeck[oldDeckKey] || 0;
            
            if (currentCount > 0) {
                // Remove from old key
                delete window.cityLeagueDeck[oldDeckKey];
                
                // Add to new key
                window.cityLeagueDeck[newKey] = currentCount;

                // CRITICAL: Update order array to preserve card position
                if (window.cityLeagueDeckOrder) {
                    const oldKeyIndex = window.cityLeagueDeckOrder.indexOf(oldDeckKey);
                    if (oldKeyIndex !== -1) {
                        // Replace old key with new key at same position
                        window.cityLeagueDeckOrder[oldKeyIndex] = newKey;
                        console.log(`Updated deck order: ${oldDeckKey} -> ${newKey} at position ${oldKeyIndex}`);
                    }
                }

                // Save preference
                setRarityPreference(actualCardName, { mode: 'specific', set: setCode, number: setNumber });
                
                // Refresh the grid display
                renderMyDeckGrid('cityLeague');
            }

            closeRaritySwitcher();
        }

        function closeRaritySwitcher() {
            const modal = document.getElementById('raritySwitcherModal');
            modal.classList.remove('show');
            currentRaritySwitcherCard = null;
        }

        function openCardmarket(cardmarketUrl, cardName) {
            if (!cardmarketUrl || cardmarketUrl.trim() === '') {
                alert(`❌ Cardmarket Link nicht verfügbar für ${cardName}\n\nMögliche Gründe:\n- Price Scraper noch nicht gelaufen\n- Karte hat keine Cardmarket Daten\n\nBitte RUN_PRICE_SCRAPER.bat ausführen.`);
                return;
            }
            
            // Open Cardmarket URL in new tab
            window.open(cardmarketUrl, '_blank');
        }

        function getRarityColor(rarity) {
            const colors = {
                'Common': '#A0A0A0',
                'Uncommon': '#6B8E23',
                'Rare': '#DAA520',
                'Holo Rare': '#FFD700',
                'Double Rare': '#FF6B9D',
                'Double Rare Holo': '#FF1493',
                'Secret Rare': '#8B008B',
                'Secret Rare Gold': '#FF8C00'
            };
            return colors[rarity] || '#CCCCCC';
        }

        function getRarityRank(rarity) {
            // Higher number = rarer/more valuable
            const rarityHierarchy = {
                'Common': 1,
                'Uncommon': 2,
                'Rare': 3,
                'Holo Rare': 4,
                'Rare Holo': 4,
                'Radiant Rare': 5,
                'Art Rare': 6,
                'Illustration Rare': 6,
                'Double Rare': 7,
                'Ultra Rare': 8,
                'Shiny Rare': 9,
                'Special Illustration Rare': 10,
                'Hyper Rare': 11,
                'Secret Rare': 12,
                'Secret Rare Gold': 13,
                'Promo': 14  // Promo highest priority for MEP cards
            };
            return rarityHierarchy[rarity] || 0;
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            const lastUpdate = localStorage.getItem('lastScraperUpdate') || new Date().toLocaleDateString('de-DE');
            document.getElementById('last-update').textContent = lastUpdate;
            
            // Load all cards database for deck builder
            loadAllCardsDatabase();
            loadSetMapping();
            loadRarityPreferences();
            
            // Load first tab automatically
            loadCityLeagueData();
            window.cityLeagueLoaded = true;
        });
        
        // ========================================================================
        // CURRENT META DECK ANALYSIS - Complete Implementation
        // ========================================================================
        
        // Current Meta Global Variables
        let currentMetaFormatFilter = 'all'; // 'all', 'live', 'play'
        let currentMetaRarityMode = 'min'; // 'min', 'max', 'all'
        let currentMetaGlobalRarityPreference = 'min';
        
        // Initialize Current Meta Deck from localStorage
        if (!window.currentMetaDeck) {
            window.currentMetaDeck = {};
        }
        if (!window.currentMetaDeckOrder) {
            window.currentMetaDeckOrder = [];
        }
        
        // Load Current Meta Analysis Data
        async function loadCurrentMetaAnalysis() {
            console.log('Loading Current Meta Analysis...');
            const data = await loadCSV('current_meta_card_data.csv');
            console.log('Loaded data:', data ? `${data.length} rows` : 'null');
            
            // Load deck stats (winrates)
            const deckStats = await loadCSV('limitless_online_decks.csv');
            if (deckStats) {
                window.currentMetaDeckStats = deckStats;
                console.log('Loaded deck stats:', deckStats.length, 'decks');
            }
            
            // Load matchup data
            const matchupData = await loadCSV('limitless_online_decks_matchups.csv');
            if (matchupData) {
                window.currentMetaMatchupData = matchupData;
                console.log('Loaded matchup data:', matchupData.length, 'matchups');
            }
            
            if (data && data.length > 0) {
                window.currentMetaAnalysisData = data;
                populateCurrentMetaDeckSelect(data);
                setCurrentMetaFormatFilter('all'); // Set default filter
                window.currentMetaAnalysisLoaded = true;
            } else {
                const content = document.getElementById('currentMetaDeckSelect');
                if (content) {
                    content.innerHTML = '<option value="">Error loading data</option>';
                }
            }
        }
        
        // Populate deck select dropdown
        function populateCurrentMetaDeckSelect(data) {
            // Apply format filter to data BEFORE building archetype list
            let filteredData = data;
            if (currentMetaFormatFilter !== 'all') {
                const filterValue = currentMetaFormatFilter === 'live' ? 'Meta Live' : 'Meta Play!';
                filteredData = data.filter(row => row.meta === filterValue);
                console.log(`Filtered archetypes by ${currentMetaFormatFilter}: ${filteredData.length} cards`);
            }
            
            const archetypeMap = new Map();
            filteredData.forEach(row => {
                const archetype = row.archetype;
                if (!archetype) return;
                
                if (!archetypeMap.has(archetype)) {
                    archetypeMap.set(archetype, {
                        name: archetype,
                        deckCount: parseInt(row.total_decks_in_archetype || 0),
                        limitlessCount: 0,
                        majorCount: 0
                    });
                }
            });
            
            // Calculate split between Limitless and Major for each archetype
            archetypeMap.forEach((archetypeInfo, archetypeName) => {
                const archetypeDecks = data.filter(row => row.archetype === archetypeName);
                
                // Find an entry with Meta Live to get total_decks_in_archetype
                const liveEntry = archetypeDecks.find(row => row.meta === 'Meta Live');
                const limitlessCount = liveEntry ? parseInt(liveEntry.total_decks_in_archetype || 0) : 0;
                
                // Find an entry with Meta Play! to get total_decks_in_archetype
                const playEntry = archetypeDecks.find(row => row.meta === 'Meta Play!');
                const majorCount = playEntry ? parseInt(playEntry.total_decks_in_archetype || 0) : 0;
                
                archetypeInfo.limitlessCount = limitlessCount;
                archetypeInfo.majorCount = majorCount;
            });
            
            const archetypeList = Array.from(archetypeMap.values());
            console.log('Found archetypes:', archetypeList.length);
            
            // Sort by deck count descending
            const sortedByMeta = [...archetypeList].sort((a, b) => b.deckCount - a.deckCount);
            const top10 = sortedByMeta.slice(0, 10);
            const rest = sortedByMeta.slice(10).sort((a, b) => a.name.localeCompare(b.name));
            
            const select = document.getElementById('currentMetaDeckSelect');
            if (!select) return;
            
            select.innerHTML = '<option value="">-- Bitte Deck auswählen --</option>';
            
            if (top10.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = '🔥 Top 10 Meta Decks';
                top10.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.name;
                    option.textContent = `${deck.name} (${deck.limitlessCount} Limitless / ${deck.majorCount} Major)`;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            if (rest.length > 0) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = '📋 Alle Decks';
                rest.forEach(deck => {
                    const option = document.createElement('option');
                    option.value = deck.name;
                    option.textContent = `${deck.name} (${deck.limitlessCount} Limitless / ${deck.majorCount} Major)`;
                    optgroup.appendChild(option);
                });
                select.appendChild(optgroup);
            }
            
            select.onchange = function() {
                const archetype = this.value;
                if (archetype) {
                    loadCurrentMetaDeckData(archetype);
                    // Display the deck after loading archetype data
                    if (window.currentMetaDeck && Object.keys(window.currentMetaDeck).length > 0) {
                        updateDeckDisplay('currentMeta');
                        console.log('[Dropdown] Displaying saved deck for selected archetype');
                    }
                } else {
                    clearCurrentMetaDeckView();
                }
            };
            
            // Enable search functionality
            const searchInput = document.getElementById('currentMetaDeckSearch');
            if (searchInput) {
                searchInput.oninput = function() {
                    const searchTerm = this.value.toLowerCase();
                    const options = select.querySelectorAll('option');
                    options.forEach(opt => {
                        if (opt.value === '') return;
                        const text = opt.textContent.toLowerCase();
                        opt.style.display = text.includes(searchTerm) ? '' : 'none';
                    });
                };
            }
        }
        
        // Format filter functions
        function setCurrentMetaFormatFilter(format) {
            currentMetaFormatFilter = format;
            console.log('[Current Meta] Format filter set to:', format);
            
            // Update button styles with null-checks
            ['All', 'Live', 'Play'].forEach(f => {
                const btn = document.getElementById(`currentMetaFilter${f}`);
                if (btn) {
                    if (f.toLowerCase() === format) {
                        btn.className = 'btn btn-primary';
                    } else {
                        btn.className = 'btn btn-secondary';
                    }
                }
            });
            
            // Update status text
            const statusEl = document.getElementById('currentMetaFilterStatus');
            if (statusEl) {
                const labels = {
                    'all': 'Alle Turniere',
                    'live': 'Nur Limitless Decks',
                    'play': 'Nur Major Tournament Decks'
                };
                statusEl.textContent = `Filter aktiv: ${labels[format]}`;
            }
            
            // Refresh dropdown list to show only archetypes matching the filter
            const currentMetaDeckSelect = document.getElementById('currentMetaDeckSelect');
            const previouslySelected = currentMetaDeckSelect ? currentMetaDeckSelect.value : null;
            
            if (window.currentMetaAnalysisData) {
                populateCurrentMetaDeckSelect(window.currentMetaAnalysisData);
            }
            
            // Check if previously selected archetype still exists in filtered list
            if (previouslySelected && currentMetaDeckSelect) {
                const stillExists = Array.from(currentMetaDeckSelect.options).some(opt => opt.value === previouslySelected);
                
                if (stillExists) {
                    // Restore selection and reload deck
                    currentMetaDeckSelect.value = previouslySelected;
                    loadCurrentMetaDeckData(previouslySelected);
                } else {
                    // Clear selection and deck view
                    currentMetaDeckSelect.value = '';
                    clearCurrentMetaDeckView();
                    console.log('⚠️ Previously selected archetype not available in this filter');
                }
            } else {
                console.warn('⚠️ No deck selected - filter saved for when deck is selected');
            }
        }
        
        // Load deck data with format filtering
        function loadCurrentMetaDeckData(archetype) {
            console.log('Loading Current Meta deck data for:', archetype);
            const data = window.currentMetaAnalysisData;
            if (!data) return;
            
            window.currentCurrentMetaArchetype = archetype;
            
            // Check if we have a saved deck for this archetype
            const savedDeck = localStorage.getItem('currentMetaDeck');
            if (savedDeck) {
                try {
                    const parsed = JSON.parse(savedDeck);
                    if (parsed.archetype === archetype) {
                        console.log('[loadCurrentMetaDeckData] Deck already loaded for this archetype');
                    } else {
                        // Different archetype - CLEAR old deck
                        console.log('[loadCurrentMetaDeckData] Clearing old deck from different archetype:', parsed.archetype);
                        window.currentMetaDeck = {};
                        window.currentMetaDeckOrder = [];
                        saveCurrentMetaDeck();
                    }
                } catch (e) {
                    console.error('[loadCurrentMetaDeckData] Error reading saved deck:', e);
                }
            }
            
            // Filter by archetype
            let deckCards = data.filter(row => 
                row.archetype && row.archetype.toLowerCase() === archetype.toLowerCase()
            );
            
            console.log(`Found ${deckCards.length} cards for archetype ${archetype}`);
            
            // Apply format filter
            if (currentMetaFormatFilter !== 'all') {
                const filterValue = currentMetaFormatFilter === 'live' ? 'Meta Live' : 'Meta Play!';
                deckCards = deckCards.filter(row => row.meta === filterValue);
                console.log(`After ${currentMetaFormatFilter} filter: ${deckCards.length} cards`);
            }
            
            if (deckCards.length === 0) {
                alert(`Keine Daten für ${archetype} mit Filter "${currentMetaFormatFilter}" gefunden!`);
                clearCurrentMetaDeckView();
                return;
            }
            
            // Deduplicate
            deckCards = deduplicateCards(deckCards);
            console.log('Found cards (after deduplication):', deckCards.length);
            
            window.currentCurrentMetaDeckCards = deckCards;
            
            // Calculate stats
            const totalCardsInDeck = deckCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            const uniqueCards = deckCards.length;
            
            // Get winrate from deck stats
            let winrate = '-';
            const deckStats = window.currentMetaDeckStats || [];
            const deckStatEntry = deckStats.find(d => d.deck_name && d.deck_name.toLowerCase() === archetype.toLowerCase());
            if (deckStatEntry && deckStatEntry.win_rate) {
                winrate = deckStatEntry.win_rate;
            }
            
            // Calculate matchup vs Top 20
            let matchupVsTop20 = '-';
            const matchupData = window.currentMetaMatchupData || [];
            if (deckStats.length > 0 && matchupData.length > 0) {
                // Get top 20 decks by rank
                const top20Decks = deckStats
                    .filter(d => d.rank && parseInt(d.rank) <= 20)
                    .map(d => d.deck_name);
                
                // Get matchups against top 20
                const relevantMatchups = matchupData.filter(m => 
                    m.deck_name && m.deck_name.toLowerCase() === archetype.toLowerCase() &&
                    m.opponent && top20Decks.some(deck => deck && deck.toLowerCase() === m.opponent.toLowerCase())
                );
                
                if (relevantMatchups.length > 0) {
                    // Calculate weighted average winrate
                    let totalGames = 0;
                    let totalWins = 0;
                    
                    relevantMatchups.forEach(m => {
                        const games = parseInt(m.total_games) || 0;
                        const winRate = parseFloat((m.win_rate || '0').replace(',', '.'));
                        totalGames += games;
                        totalWins += (games * winRate / 100);
                    });
                    
                    if (totalGames > 0) {
                        const avgWinrate = (totalWins / totalGames * 100).toFixed(2);
                        matchupVsTop20 = `${avgWinrate}% (${relevantMatchups.length} MU)`;
                    }
                }
            }
            
            // Update stats  
            document.getElementById('currentMetaStatCards').textContent = `${uniqueCards} / ${totalCardsInDeck}`;
            document.getElementById('currentMetaStatWinrate').textContent = winrate;
            document.getElementById('currentMetaStatMatchup').textContent = matchupVsTop20;
            document.getElementById('currentMetaStatsSection').style.display = 'block';
            
            // Render matchups
            renderCurrentMetaMatchups(archetype);
            
            // Show deck visual
            renderCurrentMetaDeckGrid(deckCards);
            
            // Apply current filter
            applyCurrentMetaFilter();
            
            // DON'T auto-display deck here - let the caller decide
            // (only display when user actively selects archetype from dropdown)
        }
        
        function clearCurrentMetaDeckView() {
            document.getElementById('currentMetaStatsSection').style.display = 'none';
            document.getElementById('currentMetaMatchupsSection').style.display = 'none';
            document.getElementById('currentMetaDeckVisual').style.display = 'none';
            document.getElementById('currentMetaDeckTableView').style.display = 'none';
            document.getElementById('currentMetaCardCount').textContent = '0 Karten';
            document.getElementById('currentMetaCardCountSummary').textContent = '/ 0 Total';
        }
        
        // Render best/worst matchups for Current Meta
        function renderCurrentMetaMatchups(archetype) {
            console.log('Rendering matchups for:', archetype);
            const deckStats = window.currentMetaDeckStats || [];
            const matchupsSection = document.getElementById('currentMetaMatchupsSection');
            const bestTable = document.getElementById('currentMetaBestMatchups');
            const worstTable = document.getElementById('currentMetaWorstMatchups');
            const titleEl = document.getElementById('currentMetaMatchupsTitle');
            
            // Try to use data from loaded HTML first (window.matchupData_DeckName)
            const deckNameForVar = archetype.replace(/\s+/g, '_').replace(/'/g, '');
            const htmlMatchupData = window['matchupData_' + deckNameForVar];
            
            let deckMatchups = [];
            
            if (htmlMatchupData) {
                // Use data from HTML file (more accurate)
                console.log('Using matchup data from HTML for:', archetype);
                deckMatchups = Object.entries(htmlMatchupData).map(([opponent, data]) => ({
                    opponent: opponent,
                    win_rate: data.win_rate,
                    win_rate_numeric: data.win_rate_numeric,
                    record: data.record,
                    total_games: data.total_games
                }));
            } else {
                // Fallback to CSV data
                console.log('Using matchup data from CSV for:', archetype);
                const matchupData = window.currentMetaMatchupData || [];
                if (!matchupData || matchupData.length === 0) {
                    matchupsSection.style.display = 'none';
                    return;
                }
                
                deckMatchups = matchupData.filter(m => 
                    m.deck_name && m.deck_name.toLowerCase() === archetype.toLowerCase()
                ).map(m => ({
                    ...m,
                    win_rate_numeric: parseFloat((m.win_rate || '0').replace(',', '.'))
                }));
            }
            
            if (deckMatchups.length === 0) {
                matchupsSection.style.display = 'none';
                return;
            }
            
            // Sort by win rate
            const sortedMatchups = deckMatchups.map(m => ({
                ...m,
                win_rate_numeric: parseFloat((m.win_rate || '0').replace(',', '.'))
            })).sort((a, b) => b.win_rate_numeric - a.win_rate_numeric);
            
            // Get best 5 and worst 5
            const best5 = sortedMatchups.slice(0, 5);
            const worst5 = sortedMatchups.slice(-5).reverse();
            
            // Get deck winrate for title
            let deckWinrate = '-';
            let vsTop20Display = '-';
            const deckStatEntry = deckStats.find(d => d.deck_name && d.deck_name.toLowerCase() === archetype.toLowerCase());
            if (deckStatEntry && deckStatEntry.win_rate) {
                deckWinrate = deckStatEntry.win_rate;
            }
            
            // Calculate vs Top 20 for title
            const top20Decks = deckStats.filter(d => d.rank && parseInt(d.rank) <= 20).map(d => d.deck_name);
            const top20Matchups = sortedMatchups.filter(m => 
                top20Decks.some(deck => deck && deck.toLowerCase() === m.opponent.toLowerCase())
            );
            if (top20Matchups.length > 0) {
                const wins = top20Matchups.filter(m => m.win_rate_numeric > 50).length;
                const losses = top20Matchups.length - wins;
                vsTop20Display = `${wins}:${losses}`;
            }
            
            // Update title
            titleEl.innerHTML = `${archetype} <span style="font-size: 0.8em; color: #7f8c8d;">(Total WR: ${deckWinrate}, Vs Top20: ${vsTop20Display})</span>`;
            
            // Populate best matchups
            let bestHtml = '';
            best5.forEach(m => {
                const games = parseInt(m.total_games) || 0;
                const record = m.record || '-';
                bestHtml += `
                    <tr>
                        <td><strong>${m.opponent || 'Unknown'}</strong></td>
                        <td><strong>${m.win_rate || '-'}</strong></td>
                        <td>${record} (${games} games)</td>
                    </tr>
                `;
            });
            bestTable.innerHTML = bestHtml || '<tr><td colspan="3" style="text-align: center; padding: 20px;">Keine Daten verfügbar</td></tr>';
            
            // Populate worst matchups
            let worstHtml = '';
            worst5.forEach(m => {
                const games = parseInt(m.total_games) || 0;
                const record = m.record || '-';
                worstHtml += `
                    <tr>
                        <td><strong>${m.opponent || 'Unknown'}</strong></td>
                        <td><strong>${m.win_rate || '-'}</strong></td>
                        <td>${record} (${games} games)</td>
                    </tr>
                `;
            });
            worstTable.innerHTML = worstHtml || '<tr><td colspan="3" style="text-align: center; padding: 20px;">Keine Daten verfügbar</td></tr>';
            
            // Populate opponent dropdown
            const dropdown = document.getElementById('currentMetaOpponentDropdown');
            const allOpponents = [...new Set(deckMatchups.map(m => m.opponent))].filter(o => o).sort();
            let dropdownHtml = '';
            allOpponents.forEach(opponent => {
                dropdownHtml += `<div class="opponent-option" data-value="${opponent}" onclick="selectCurrentMetaOpponent(this, '${opponent}')" style="padding: 10px; cursor: pointer; border-bottom: 1px solid #eee; transition: background 0.2s;">${opponent}</div>`;
            });
            dropdown.innerHTML = dropdownHtml;
            
            // Store current deck matchups for filtering
            window.currentMetaDeckMatchups = deckMatchups;
            
            matchupsSection.style.display = 'block';
        }
        
        // Filter opponents in dropdown
        function filterCurrentMetaOpponents(inputEl) {
            const searchValue = inputEl.value.toLowerCase();
            const dropdown = document.getElementById('currentMetaOpponentDropdown');
            const options = dropdown.querySelectorAll('.opponent-option');
            
            let hasVisibleOptions = false;
            options.forEach(option => {
                const opponentName = option.getAttribute('data-value').toLowerCase();
                if (opponentName.includes(searchValue)) {
                    option.style.display = 'block';
                    hasVisibleOptions = true;
                } else {
                    option.style.display = 'none';
                }
            });
            
            dropdown.style.display = hasVisibleOptions ? 'block' : 'none';
        }
        
        // Select opponent and show matchup details
        function selectCurrentMetaOpponent(optionEl, opponent) {
            const inputEl = document.getElementById('currentMetaOpponentSearch');
            const hiddenEl = document.getElementById('currentMetaOpponentSelected');
            const dropdown = document.getElementById('currentMetaOpponentDropdown');
            const detailsEl = document.getElementById('currentMetaMatchupDetails');
            
            // Update input and hidden field
            inputEl.value = opponent;
            hiddenEl.value = opponent;
            dropdown.style.display = 'none';
            
            // Find matchup data
            const deckMatchups = window.currentMetaDeckMatchups || [];
            const matchup = deckMatchups.find(m => m.opponent === opponent);
            
            if (matchup) {
                const winRate = matchup.win_rate || '-';
                const record = matchup.record || '-';
                const totalGames = matchup.total_games || '0';
                
                detailsEl.innerHTML = `
                    <h4 style="margin-top: 0; color: #2c3e50;">📊 Matchup: vs ${opponent}</h4>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-top: 10px;">
                        <div>
                            <strong style="color: #666;">Win Rate:</strong><br>
                            <span style="font-size: 1.5em; color: #3498db;">${winRate}</span>
                        </div>
                        <div>
                            <strong style="color: #666;">Record:</strong><br>
                            <span style="font-size: 1.2em; color: #2c3e50;">${record}</span>
                        </div>
                        <div>
                            <strong style="color: #666;">Total Games:</strong><br>
                            <span style="font-size: 1.5em; color: #2c3e50;">${totalGames}</span>
                        </div>
                    </div>
                `;
                detailsEl.style.display = 'block';
            } else {
                detailsEl.innerHTML = '<p style="color: #999; text-align: center;">Keine Matchup-Daten gefunden</p>';
                detailsEl.style.display = 'block';
            }
        }
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('currentMetaOpponentDropdown');
            const input = document.getElementById('currentMetaOpponentSearch');
            if (dropdown && input && !input.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });
        
        function applyCurrentMetaFilter() {
            const filterSelect = document.getElementById('currentMetaFilterSelect');
            const archetype = document.getElementById('currentMetaDeckSelect')?.value;
            
            if (!filterSelect || !archetype || !window.currentCurrentMetaDeckCards) return;
            
            const filterValue = filterSelect.value;
            const allCards = window.currentCurrentMetaDeckCards;
            let filteredCards = [...allCards];
            
            if (filterValue !== 'all') {
                const threshold = parseInt(filterValue);
                filteredCards = filteredCards.filter(card => parseFloat(card.percentage_in_archetype || 0) >= threshold);
            }
            
            console.log(`Filter applied: ${filterValue}, showing ${filteredCards.length} of ${allCards.length} cards`);
            
            const filteredTotal = filteredCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            const allTotal = allCards.reduce((sum, card) => sum + parseInt(card.max_count || 0), 0);
            
            const tableViewContainer = document.getElementById('currentMetaDeckTableView');
            const gridViewContainer = document.getElementById('currentMetaDeckVisual');
            const isTableViewActive = tableViewContainer && tableViewContainer.style.display !== 'none';
            
            if (isTableViewActive) {
                renderCurrentMetaDeckTable(filteredCards);
            } else {
                renderCurrentMetaDeckGrid(filteredCards);
            }
            
            updateCurrentMetaCardCounts(filteredCards.length, filteredTotal, allTotal);
        }
        
        function updateCurrentMetaCardCounts(uniqueCount, filteredTotal, allTotal) {
            const countEl = document.getElementById('currentMetaCardCount');
            const summaryEl = document.getElementById('currentMetaCardCountSummary');
            
            if (countEl) countEl.textContent = `${uniqueCount} Karten`;
            if (summaryEl) summaryEl.textContent = `/ ${filteredTotal} Total`;
        }
        
        // Set overview rarity mode
        function setCurrentMetaOverviewRarityMode(mode) {
            console.log('🔄 Setting Current Meta overview rarity mode to:', mode);
            currentMetaRarityMode = mode;
            
            if (mode === 'all') {
                currentMetaGlobalRarityPreference = null;
            } else {
                currentMetaGlobalRarityPreference = mode;
            }
            
            // Update button styles with null-checks
            const btnMin = document.getElementById('currentMetaOverviewRarityMin');
            const btnMax = document.getElementById('currentMetaOverviewRarityMax');
            const btnAll = document.getElementById('currentMetaOverviewRarityAll');
            
            if (btnMin) btnMin.style.opacity = mode === 'min' ? '1' : '0.6';
            if (btnMax) btnMax.style.opacity = mode === 'max' ? '1' : '0.6';
            if (btnAll) btnAll.style.opacity = mode === 'all' ? '1' : '0.6';
            
            const cards = window.currentCurrentMetaDeckCards;
            if (cards && cards.length > 0) {
                applyCurrentMetaFilter();  // Use filter function to preserve percentage filter
            } else {
                console.warn('⚠️ No cards available to render - mode saved for when deck is selected');
            }
            
            if (window.currentMetaDeck && Object.keys(window.currentMetaDeck).length > 0) {
                updateDeckDisplay('currentMeta');
            }
        }
        
        // Render grid view
        function renderCurrentMetaDeckGrid(cards) {
            console.log('🎨 renderCurrentMetaDeckGrid called with:', cards.length, 'cards');
            const visualContainer = document.getElementById('currentMetaDeckVisual');
            const gridContainer = document.getElementById('currentMetaDeckGrid');
            if (!gridContainer) return;
            
            const sortedCards = sortCardsByType([...cards]);
            const currentDeck = window.currentMetaDeck || {};
            
            let html = '';
            sortedCards.forEach(card => {
                const cardName = card.card_name;
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                const originalSetCode = card.set_code || '';
                const originalSetNumber = card.set_number || '';
                
                let versionsToRender = [];
                
                if (currentMetaRarityMode === 'all') {
                    let allVersions = getInternationalPrintsForCard(originalSetCode, originalSetNumber);
                    if (allVersions && allVersions.length > 0) {
                        versionsToRender = allVersions.map(v => ({
                            ...card,
                            set_code: v.set,
                            set_number: v.number,
                            image_url: v.image_url,
                            rarity: v.rarity
                        }));
                    } else {
                        versionsToRender = [card];
                    }
                } else {
                    const preferredVersion = getPreferredVersionForCard(cardName, originalSetCode, originalSetNumber);
                    if (preferredVersion) {
                        versionsToRender = [{
                            ...card,
                            set_code: preferredVersion.set,
                            set_number: preferredVersion.number,
                            image_url: preferredVersion.image_url,
                            rarity: preferredVersion.rarity
                        }];
                    } else {
                        versionsToRender = [card];
                    }
                }
                
                versionsToRender.forEach(displayCard => {
                    const setCode = displayCard.set_code || '';
                    const setNumber = displayCard.set_number || '';
                    const imageUrl = fixJapaneseCardImageUrl(displayCard.image_url || '', setCode);
                    const percentage = parseFloat(card.percentage_in_archetype || 0).toFixed(1);
                    const maxCount = card.max_count || '?';
                    
                    let deckCount = 0;
                    if (setCode && setNumber) {
                        for (const deckKey in currentDeck) {
                            const match = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                            if (match) {
                                const deckSetCode = match[1];
                                const deckSetNumber = match[2];
                                if (deckSetCode === setCode && deckSetNumber === setNumber) {
                                    deckCount = currentDeck[deckKey] || 0;
                                    break;
                                }
                            }
                        }
                    } else {
                        deckCount = currentDeck[cardName] || 0;
                    }
                    
                    const decksWithCard = parseInt(card.deck_count || 0);
                    const totalDecksInArchetype = parseInt(card.total_decks_in_archetype || 1);
                    const totalCount = parseInt(card.total_count || 0);
                    const avgCountOverall = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0.00';
                    const avgCountInUsedDecks = decksWithCard > 0 ? (totalCount / decksWithCard).toFixed(2) : '0.00';
                    
                    let eurPrice = '';
                    let cardmarketUrl = '';
                    if (setCode && setNumber && allCardsDatabase) {
                        const priceCard = allCardsDatabase.find(c => c.set === setCode && c.number === setNumber);
                        if (priceCard) {
                            eurPrice = priceCard.eur_price || '';
                            cardmarketUrl = priceCard.cardmarket_url || '';
                        }
                    }
                    const priceDisplay = eurPrice || '0,00€';
                    const priceBackground = eurPrice ? 'linear-gradient(135deg, #ff6b35 0%, #ff8c42 100%)' : 'linear-gradient(135deg, #777 0%, #999 100%)';
                    const cardmarketUrlEscaped = (cardmarketUrl || '').replace(/'/g, "\\'");
                    
                    html += `
                        <div class="card-item" data-card-name="${cardName.toLowerCase()}" style="position: relative; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 8px rgba(0,0,0,0.15); cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; background: white;">
                            <div style="position: relative; width: 100%;">
                                <img src="${imageUrl}" alt="${cardName}" referrerpolicy="no-referrer" style="width: 100%; aspect-ratio: 2.5/3.5; object-fit: cover; cursor: zoom-in;" onerror="this.style.opacity='0.3'" onclick="event.stopPropagation(); showSingleCard('${imageUrl}', '${cardNameEscaped}');">
                                <div style="position: absolute; top: 5px; right: 5px; background: #dc3545; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">${maxCount}</div>
                                ${deckCount > 0 ? `<div style="position: absolute; top: 5px; left: 5px; background: #28a745; color: white; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9em; box-shadow: 0 2px 4px rgba(0,0,0,0.3); z-index: 2;">${deckCount}</div>` : ''}
                            </div>
                            <div style="padding: 8px; background: white; font-size: 0.75em; text-align: center; min-height: 60px; display: flex; flex-direction: column; justify-content: space-between;">
                                <div>
                                    <div style="white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 600; margin-bottom: 3px; color: #333; font-size: 0.9em;">${cardName}</div>
                                    <div style="color: #999; font-size: 0.75em; margin-bottom: 3px;">${setCode} ${setNumber}</div>
                                    <div style="color: #666; font-size: 0.85em; margin-bottom: 3px;">${percentage}% | Ø ${avgCountInUsedDecks}x (${avgCountOverall}x)</div>
                                    <div style="font-weight: 600; color: #333; font-size: 0.9em;">${decksWithCard} / ${totalDecksInArchetype} Decks</div>
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 3px; margin-top: 8px;">
                                    <button onclick="event.stopPropagation(); removeCardFromDeck('currentMeta', '${cardNameEscaped}')" style="background: #dc3545; color: white; border: none; border-radius: 3px; height: 22px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 13px;">−</button>
                                    <button onclick="event.stopPropagation(); openRaritySwitcher('${cardNameEscaped}', '${cardNameEscaped}')" style="background: #ffc107; color: #333; border: none; border-radius: 3px; height: 22px; cursor: pointer; font-size: 12px; font-weight: bold; text-align: center; padding: 0; display: flex; align-items: center; justify-content: center;">★</button>
                                    <button onclick="event.stopPropagation(); openCardmarket('${cardmarketUrlEscaped}', '${cardNameEscaped}')" style="background: ${priceBackground}; color: white; height: 22px; border: none; border-radius: 3px; cursor: ${eurPrice ? 'pointer' : 'not-allowed'}; font-size: 9px; font-weight: bold; padding: 0 2px; display: flex; align-items: center; justify-content: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; text-shadow: 0 1px 2px rgba(0, 0, 0, 0.4);">${priceDisplay}</button>
                                    <button onclick="event.stopPropagation(); addCardToDeck('currentMeta', '${cardNameEscaped}', '${setCode}', '${setNumber}')" style="background: #28a745; color: white; border: none; border-radius: 3px; height: 22px; cursor: pointer; font-weight: bold; padding: 0; display: flex; align-items: center; justify-content: center; font-size: 13px;">+</button>
                                </div>
                            </div>
                        </div>
                    `;
                });
            });
            
            gridContainer.innerHTML = html;
            visualContainer.style.display = 'block';
        }
        
        function renderCurrentMetaDeckTable(cards) {
            const tableContainer = document.getElementById('currentMetaDeckTable');
            const tableViewContainer = document.getElementById('currentMetaDeckTableView');
            if (!tableContainer) return;
            
            const sortedCards = sortCardsByType([...cards]);
            const currentDeck = window.currentMetaDeck || {};
            
            let html = '<div style="display: flex; flex-direction: column; gap: 15px;">';
            sortedCards.forEach(card => {
                const cardName = card.card_name;
                let displayCard = card;
                const allCards = window.allCardsDatabase || [];
                const allVersions = allCards.filter(c => c.name === cardName && c.set && c.number);
                
                if (currentMetaRarityMode !== 'all' && allVersions.length > 0) {
                    const SET_ORDER = {
                        'PRE': 108, 'SFA': 107, 'ASC': 106,
                        'MEG': 105, 'MEP': 104, 'SP': 103, 'SVE': 102,
                        'SCR': 101, 'TWM': 100, 'TEF': 99, 'PAR': 98, 'PAF': 97, 'PAL': 96, 'OBF': 95,
                        'MEW': 94, 'SVI': 93, 'CRZ': 92, 'SIT': 91, 'LOR': 90, 'PGO': 89
                    };
                    
                    const getRarityValue = (card) => {
                        const r = (card.rarity || card.card_rarity || '').toLowerCase();
                        if (!r || r === '') return 0;
                        if (r.includes('common')) return 1;
                        if (r.includes('uncommon')) return 2;
                        if (r.includes('rare')) return 3;
                        return -1;
                    };
                    
                    allVersions.sort((a, b) => {
                        const rarityDiff = currentMetaRarityMode === 'min' ? getRarityValue(a) - getRarityValue(b) : getRarityValue(b) - getRarityValue(a);
                        if (rarityDiff !== 0) return rarityDiff;
                        return (SET_ORDER[b.set] || 0) - (SET_ORDER[a.set] || 0);
                    });
                    
                    const preferredVersion = allVersions[0];
                    displayCard = {
                        ...card,
                        set_code: preferredVersion.set,
                        set_number: preferredVersion.number,
                        image_url: preferredVersion.image_url || card.image_url
                    };
                }
                
                const imageUrl = fixJapaneseCardImageUrl(displayCard.image_url || '', displayCard.set_code);
                const percentage = parseFloat(card.percentage_in_archetype || 0).toFixed(1);
                const maxCount = card.max_count || '?';
                const cardNameEscaped = cardName.replace(/'/g, "\\'");
                const setCode = displayCard.set_code || '';
                const setNumber = displayCard.set_number || '';
                
                let deckCount = 0;
                if (setCode && setNumber) {
                    for (const deckKey in currentDeck) {
                        const match = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                        if (match && match[1] === setCode && match[2] === setNumber) {
                            deckCount = currentDeck[deckKey] || 0;
                            break;
                        }
                    }
                } else {
                    deckCount = currentDeck[cardName] || 0;
                }
                
                const decksWithCard = parseInt(card.deck_count || 0);
                const totalDecksInArchetype = parseInt(card.total_decks_in_archetype || 1);
                const totalCount = parseInt(card.total_count || 0);
                const avgCountOverall = totalDecksInArchetype > 0 ? (totalCount / totalDecksInArchetype).toFixed(2) : '0.00';
                const avgCountInUsedDecks = decksWithCard > 0 ? (totalCount / decksWithCard).toFixed(2) : '0.00';
                
                html += `
                    <div class="card-table-row" data-card-name="${cardName.toLowerCase()}" style="display: flex; align-items: center; background: white; border-radius: 8px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); gap: 20px;">
                        <div style="flex-shrink: 0; position: relative; width: 120px;">
                            <img src="${imageUrl}" alt="${cardName}" referrerpolicy="no-referrer" style="width: 100%; border-radius: 6px; cursor: zoom-in; aspect-ratio: 2.5/3.5; object-fit: cover;" onerror="this.style.opacity='0.3'" onclick="showSingleCard('${imageUrl}', '${cardNameEscaped}');">
                            ${deckCount > 0 ? `<div style="position: absolute; top: 5px; left: 5px; background: #28a745; color: white; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.85em; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${deckCount}</div>` : ''}
                        </div>
                        <div style="flex-grow: 1; min-width: 0;">
                            <h3 style="margin: 0 0 8px 0; font-size: 1.2em; color: #333;">${cardName}</h3>
                            <div style="color: #666; font-size: 0.9em; margin-bottom: 10px;">${setCode} ${setNumber}</div>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-bottom: 10px;">
                                <div><span style="color: #999; font-size: 0.85em;">Nutzungs Share:</span> <span style="font-weight: 600; color: #333; margin-left: 5px;">${percentage}%</span></div>
                                <div><span style="color: #999; font-size: 0.85em;">Ø in genutzten Decks:</span> <span style="font-weight: 600; color: #333; margin-left: 5px;">${avgCountInUsedDecks}x</span></div>
                                <div><span style="color: #999; font-size: 0.85em;">Ø durch alle Decks:</span> <span style="font-weight: 600; color: #333; margin-left: 5px;">${avgCountOverall}x</span></div>
                                <div><span style="color: #999; font-size: 0.85em;">Deck Count:</span> <span style="font-weight: 600; color: #333; margin-left: 5px;">${decksWithCard} / ${totalDecksInArchetype} Decks</span></div>
                                <div><span style="color: #999; font-size: 0.85em;">Max Count:</span> <span style="font-weight: 600; color: #dc3545; margin-left: 5px;">${maxCount}</span></div>
                            </div>
                        </div>
                        <div style="flex-shrink: 0;">
                            <button class="btn btn-success" style="padding: 10px 20px; font-size: 0.95em;" onclick="addCardToDeck('currentMeta', '${cardNameEscaped}', '${setCode}', '${setNumber}')">Add to Deck</button>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            tableContainer.innerHTML = html;
            tableViewContainer.style.display = 'block';
        }
        
        function filterCurrentMetaOverviewCards() {
            const searchInput = document.getElementById('currentMetaOverviewSearch');
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const gridContainer = document.getElementById('currentMetaDeckGrid');
            if (!gridContainer) return;
            
            const cards = gridContainer.querySelectorAll('.card-item');
            cards.forEach(card => {
                const cardName = card.getAttribute('data-card-name') || '';
                card.style.display = (searchTerm === '' || cardName.includes(searchTerm)) ? '' : 'none';
            });
        }
        
        function toggleCurrentMetaDeckGridView() {
            const gridViewContainer = document.getElementById('currentMetaDeckVisual');
            const tableViewContainer = document.getElementById('currentMetaDeckTableView');
            // Get button from DOM instead of event
            const gridButtons = document.querySelectorAll('button[onclick*="toggleCurrentMetaDeckGridView"]');
            const button = gridButtons[0];
            
            if (!gridViewContainer || !tableViewContainer) {
                console.warn('⚠️ Grid or table container not found');
                return;
            }
            
            const cards = window.currentCurrentMetaDeckCards;
            if (!cards || cards.length === 0) {
                alert('❌ Bitte zuerst ein Deck auswählen!');
                return;
            }
            
            const isGridViewActive = gridViewContainer.style.display !== 'none';
            
            if (isGridViewActive) {
                gridViewContainer.style.display = 'none';
                if (button) button.textContent = '🖼️ Grid View';
            } else {
                tableViewContainer.style.display = 'none';
                if (button) button.textContent = '📋 List View';
            }
            
            // Re-apply filter to preserve percentage filter and render correct view
            applyCurrentMetaFilter();
            
            filterCurrentMetaOverviewCards();
        }
        
        function copyCurrentMetaDeckOverview() {
            const deck = window.currentMetaDeck;
            const hasDeck = deck && Object.keys(deck).length > 0;
            
            const allCards = window.currentCurrentMetaDeckCards || [];
            const allCardsFromDb = window.allCardsDatabase || [];
            
            if (!hasDeck && allCards.length === 0) {
                alert('❌ Keine Karten zum Kopieren!\n\nBitte wähle zuerst einen Archetyp aus.');
                return;
            }
            
            const cardDataByName = {};
            allCards.forEach(card => {
                cardDataByName[card.card_name] = card;
            });
            allCardsFromDb.forEach(card => {
                if (!cardDataByName[card.name]) {
                    cardDataByName[card.name] = {
                        card_name: card.name,
                        type: card.type || 'Unknown',
                        card_type: card.type || 'Unknown',
                        set_code: card.set,
                        set_number: card.number,
                        rarity: card.rarity
                    };
                }
            });
            
            const deckCards = [];
            
            if (hasDeck) {
                for (const [deckKey, count] of Object.entries(deck)) {
                    if (count <= 0) continue;
                    
                    const baseNameMatch = deckKey.match(/^(.+?)\s*\(/);
                    const baseName = baseNameMatch ? baseNameMatch[1] : deckKey;
                    const setMatch = deckKey.match(/\(([A-Z0-9]+)\s+([A-Z0-9]+)\)$/);
                    const originalSet = setMatch ? setMatch[1] : null;
                    const originalNumber = setMatch ? setMatch[2] : null;
                    
                    let cardData = cardDataByName[baseName];
                    if (!cardData) continue;
                    
                    cardData = { ...cardData };
                    
                    const pref = getRarityPreference(baseName);
                    
                    if (pref && pref.mode === 'specific' && pref.set && pref.number) {
                        const specificCard = allCardsFromDb.find(c => 
                            c.name === baseName && c.set === pref.set && c.number === pref.number
                        );
                        if (specificCard) {
                            cardData.set_code = specificCard.set;
                            cardData.set_number = specificCard.number;
                        }
                    }
                    else if (currentMetaGlobalRarityPreference === 'max' || currentMetaGlobalRarityPreference === 'min') {
                        if (originalSet && originalNumber) {
                            const preferredVersion = getPreferredVersionForCard(baseName, originalSet, originalNumber);
                            if (preferredVersion) {
                                cardData.set_code = preferredVersion.set;
                                cardData.set_number = preferredVersion.number;
                            }
                        }
                    }
                    else if (originalSet && originalNumber) {
                        cardData.set_code = originalSet;
                        cardData.set_number = originalNumber;
                    }
                    
                    deckCards.push({ ...cardData, count: count });
                }
            } else {
                allCards.forEach(card => {
                    const cardName = card.card_name;
                    const maxCount = parseInt(card.max_count) || 0;
                    if (maxCount <= 0) return;
                    
                    const originalSet = card.set_code || '';
                    const originalNumber = card.set_number || '';
                    let cardData = { ...card };
                    
                    if (currentMetaRarityMode === 'min' || currentMetaRarityMode === 'max') {
                        if (originalSet && originalNumber) {
                            const preferredVersion = getPreferredVersionForCard(cardName, originalSet, originalNumber);
                            if (preferredVersion) {
                                cardData.set_code = preferredVersion.set;
                                cardData.set_number = preferredVersion.number;
                            }
                        }
                    }
                    
                    deckCards.push({
                        card_name: cardName,
                        type: cardData.type || cardData.card_type || 'Unknown',
                        card_type: cardData.type || cardData.card_type || 'Unknown',
                        set_code: cardData.set_code || '',
                        set_number: cardData.set_number || '',
                        count: maxCount
                    });
                });
            }
            
            const sortedCards = sortCardsByType(deckCards);
            
            const pokemon = [];
            const trainer = [];
            const energy = [];
            let pokemonCount = 0;
            let trainerCount = 0;
            let energyCount = 0;
            
            sortedCards.forEach(card => {
                const cardType = card.type || card.card_type || '';
                const category = getCardTypeCategory(cardType);
                const count = card.count;
                const cardName = card.card_name || '';
                const setCode = card.set_code || '';
                const setNumber = card.set_number || '';
                
                const line = `${count} ${cardName} ${setCode} ${setNumber}`.trim();
                
                if (category === 'Pokemon') {
                    pokemon.push(line);
                    pokemonCount += count;
                } else if (category === 'Energy' || category === 'Special Energy') {
                    energy.push(line);
                    energyCount += count;
                } else {
                    trainer.push(line);
                    trainerCount += count;
                }
            });
            
            let output = '';
            if (pokemon.length > 0) output += `Pokémon: ${pokemonCount}\n` + pokemon.join('\n') + '\n\n';
            if (trainer.length > 0) output += `Trainer: ${trainerCount}\n` + trainer.join('\n') + '\n\n';
            if (energy.length > 0) output += `Energy: ${energyCount}\n` + energy.join('\n');
            
            navigator.clipboard.writeText(output).then(() => {
                alert('✅ Deck wurde in die Zwischenablage kopiert!');
            }).catch(err => {
                console.error('Fehler beim Kopieren:', err);
                alert('❌ Fehler beim Kopieren in die Zwischenablage!');
            });
        }
        
        // Add filter change listener
        document.addEventListener('DOMContentLoaded', function() {
            const filterSelect = document.getElementById('currentMetaFilterSelect');
            if (filterSelect) {
                filterSelect.onchange = applyCurrentMetaFilter;
            }
        });
    </script>
    
    <!-- Image View Modal -->
    <div id="imageViewModal" class="image-view-modal" onclick="if(event.target === this) closeImageView()">
        <div class="image-view-content">
            <div class="image-view-header">
                <h3>🎨 Deck Karten Übersicht</h3>
                <button class="image-view-close" onclick="closeImageView()">✕</button>
            </div>
            <div id="compactCardGrid" class="compact-card-grid"></div>
        </div>
    </div>
    
    <!-- Single Card View Modal -->
    <div id="singleCardModal" class="single-card-modal" onclick="if(event.target === this) closeSingleCard()">
        <div class="single-card-modal-content">
            <button class="single-card-close" onclick="closeSingleCard()">✕</button>
            <img id="singleCardImage" src="" alt="" referrerpolicy="no-referrer">
        </div>
    </div>

    <!-- Rarity Switcher Modal -->
    <div id="raritySwitcherModal" class="rarity-switcher-modal" onclick="if(event.target === this) closeRaritySwitcher()">
        <div class="rarity-switcher-modal-content">
            <span class="rarity-switcher-close" onclick="closeRaritySwitcher()">✕</span>
            <h2 id="raritySwitcherTitle">Karte - Rarity Switcher</h2>
            
            <div id="rarityOptionsList" class="rarity-options-list">
                <!-- Wird dynamisch gefüllt -->
            </div>
            
        </div>
    </div>
</body>
</html>
